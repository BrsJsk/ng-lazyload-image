{"version":3,"sources":["webpack:///main.bundle.js","webpack:///./example/boot.ts","webpack:///./~/rxjs/operator/mergeMap.js","webpack:///./~/rxjs/util/EmptyError.js","webpack:///./~/rxjs/observable/PromiseObservable.js","webpack:///./~/rxjs/operator/catch.js","webpack:///./~/@angular/router/bundles/router.umd.js","webpack:///./example/app.component.ts","webpack:///./example/app.module.ts","webpack:///./example/bg-image.component.ts","webpack:///./example/default-image.component.ts","webpack:///./example/fade-in-image.component.ts","webpack:///./example/pixelated-image.component.ts","webpack:///./example/scroll-container.component.ts","webpack:///./src/lazyload-image.directive.ts","webpack:///./src/lazyload-image.module.ts","webpack:///./src/lazyload-image.ts","webpack:///./src/scroll-listener.ts","webpack:///./~/rxjs/BehaviorSubject.js","webpack:///./~/rxjs/Notification.js","webpack:///./~/rxjs/add/observable/empty.js","webpack:///./~/rxjs/add/operator/catch.js","webpack:///./~/rxjs/add/operator/do.js","webpack:///./~/rxjs/add/operator/let.js","webpack:///./~/rxjs/add/operator/mergeMap.js","webpack:///./~/rxjs/add/operator/share.js","webpack:///./~/rxjs/add/operator/startWith.js","webpack:///./~/rxjs/observable/ArrayLikeObservable.js","webpack:///./~/rxjs/observable/ConnectableObservable.js","webpack:///./~/rxjs/observable/FromObservable.js","webpack:///./~/rxjs/observable/IteratorObservable.js","webpack:///./~/rxjs/observable/empty.js","webpack:///./~/rxjs/observable/from.js","webpack:///./~/rxjs/observable/fromPromise.js","webpack:///./~/rxjs/operator/concat.js","webpack:///./~/rxjs/operator/concatAll.js","webpack:///./~/rxjs/operator/concatMap.js","webpack:///./~/rxjs/operator/do.js","webpack:///./~/rxjs/operator/every.js","webpack:///./~/rxjs/operator/first.js","webpack:///./~/rxjs/operator/last.js","webpack:///./~/rxjs/operator/let.js","webpack:///./~/rxjs/operator/multicast.js","webpack:///./~/rxjs/operator/observeOn.js","webpack:///./~/rxjs/operator/reduce.js","webpack:///./~/rxjs/operator/share.js","webpack:///./~/rxjs/operator/startWith.js"],"names":["webpackJsonp","module","exports","__webpack_require__","main","platform_browser_dynamic_1","platformBrowserDynamic","bootstrapModule","app_module_1","AppModule","core_1","enableProdMode","mergeMap","project","resultSelector","concurrent","Number","POSITIVE_INFINITY","this","lift","MergeMapOperator","__extends","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","subscribeToResult_1","OuterSubscriber_1","call","observer","source","subscribe","MergeMapSubscriber","_super","destination","hasCompleted","buffer","active","index","_next","value","_tryNext","push","result","err","error","_innerSub","ish","add","subscribeToResult","_complete","length","complete","notifyNext","outerValue","innerValue","outerIndex","innerIndex","innerSub","_notifyResultSelector","next","notifyComplete","remove","shift","OuterSubscriber","EmptyError","name","stack","message","Error","dispatchNext","arg","subscriber","closed","dispatchError","root_1","Observable_1","PromiseObservable","promise","scheduler","_subscribe","_this","_isScalar","then","root","setTimeout","schedule","Observable","_catch","selector","operator","CatchOperator","caught","CatchSubscriber","isStopped","unsubscribe","global","factory","_angular_common","_angular_core","rxjs_BehaviorSubject","rxjs_Subject","rxjs_observable_from","rxjs_observable_of","rxjs_operator_concatMap","rxjs_operator_every","rxjs_operator_first","rxjs_operator_map","rxjs_operator_mergeMap","rxjs_operator_reduce","rxjs_Observable","rxjs_operator_catch","rxjs_operator_concatAll","rxjs_util_EmptyError","rxjs_observable_fromPromise","l","rxjs_operator_mergeAll","_angular_platformBrowser","rxjs_operator_filter","defaultUrlMatcher","segments","segmentGroup","route","path","parts","split","posParams","consumed","currentIndex","i","current","isPosParam","startsWith","substring","pathMatch","hasChildren","shallowEqualArrays","a","shallowEqual","k1","keys","k2","key","flatten","target","j","last","merge","m1","m2","m","attr","forEach","map","callback","prop","waitForMap","obj","fn","waitFor","res","k","PRIMARY_OUTLET","_","concatted$","concatAll","of","apply","last$","andObservables","observables","merged$","mergeAll","every","wrapIntoObservable","Promise","fromPromise","createEmptyUrlTree","UrlTree","UrlSegmentGroup","containsTree","container","containee","exact","equalQueryParams","queryParams","equalSegmentGroups","containsQueryParams","containsSegmentGroup","equalPath","numberOfChildren","c","children","containsSegmentGroupHelper","containeePaths","slice","equalSegments","parameters","mapChildrenIntoArray","segment","child","childOutlet","concat","serializePaths","serializePath","join","serializeSegment","primary","children_1","v","encode","s","encodeURIComponent","decode","decodeURIComponent","serializeParams","params","pairs","first","second","serializeQueryParams","strParams","Array","isArray","Pair","matchSegments","str","SEGMENT_RE","lastIndex","match","matchQueryParams","QUERY_PARAM_RE","matchUrlQueryParamValue","QUERY_PARAM_VALUE_RE","noMatch","obs","NoMatch","absoluteRedirect","newTree","AbsoluteRedirect","namedOutletsRedirect","redirectTo","canLoadFails","NavigationCancelingError","applyRedirects","injector","configLoader","urlSerializer","urlTree","config","ApplyRedirects","runGuards","canLoad","from","guard","get","matched","consumedSegments","lastChild","positionalParamSegments","matcher","slicedSegments","containsEmptyPathRedirectsWithNamedOutlets","createChildrenForEmptySegments","mergeTrivialChildren","containsEmptyPathRedirects","addEmptySegmentsToChildrenIfNeeded","routes","_i","routes_1","r","emptyPathRedirect","getOutlet$1","primarySegmentGroup","routes_2","filter","undefined","outlet","validateConfig","parentPath","fullPath","getFullPath","validateNode","component","loadChildren","charAt","exp","currentRoute","findNode","expected","_a","cc","findPath","collected","cloned","createEmptyState","rootComponent","snapshot","createEmptyStateSnapshot","emptyUrl","BehaviorSubject","UrlSegment","emptyParams","emptyData","emptyQueryParams","fragment","activated","ActivatedRoute","RouterState","TreeNode","ActivatedRouteSnapshot","RouterStateSnapshot","inheritedParamsDataResolve","pathToRoot","pathFromRoot","inhertingStartingFrom","parent_1","routeConfig","reduce","curr","data","resolve","_resolvedData","setRouterStateSnapshot","state","node","_routerState","serializeNode","advanceActivatedRoute","_futureSnapshot","url","equalParamsAndUrlSegments","createRouterState","routeReuseStrategy","prevState","createNode","_root","shouldReuseRoute","createOrReuseChildren","retrieve","tree","setFutureSnapshotsOfActivatedRoutes","createActivatedRoute","createUrlTree","commands","nav","computeNavigation","toRoot","startingPosition","findStartingPosition","processChildren","updateSegmentGroupChildren","updateSegmentGroup","isMatrixParams","command","outlets","segmentPath","oldSegmentGroup","newSegmentGroup","stringify","replaceSegment","oldSegment","newSegment","outletName","Navigation","numberOfDoubleDots","isAbsolute","cmd","cmdIdx","outlets_1","urlPart","partIndex","Position","_lastPathIndex","_urlSegment","modifier","createPositionApplyingDoubleDots","group","g","ci","dd","parent","getPath","getOutlets","_b","startIndex","prefixedWith","slicedCommands","commandIndex","pathIndex","createNewSegmentGroup","outlets_2","currentCommandIndex","currentPathIndex","compare","paths","createNewSegmentChildren","recognize","rootComponentType","Recognizer","sortActivatedRouteSnapshots","nodes","sort","localeCompare","getChildConfig","_loadedConfig","match$1","NoMatch$1","checkOutletNameUniqueness","names","n","routeWithSameOutletName","toString","getSourceSegmentGroup","_sourceSegment","getPathIndexShift","_segmentIndexShift","split$1","containsEmptyPathMatchesWithNamedOutlets","createChildrenForEmptyPaths","containsEmptyPathMatches","addEmptyPathsToChildrenIfNeeded","emptyPathMatch","getOutlet$2","primarySegment","getData","getResolve","defaultErrorHandler","advanceActivatedRouteNodeAndItsChildren","parentLoadedConfig","_routeConfig","closestLoadedConfig","nodeChildrenAsMap","getOutlet","outletMap","_outlets","componentName","attrBoolValue","routerNgProbeToken","NgProbeToken","Router","provideLocationStrategy","platformLocationStrategy","baseHref","options","useHash","HashLocationStrategy","PathLocationStrategy","provideForRootGuard","router","provideRoutes","provide","ANALYZE_FOR_ENTRY_COMPONENTS","multi","useValue","ROUTES","setupRouter","ref","location","loader","compiler","opts","urlHandlingStrategy","errorHandler","enableTracing","dom_1","getDOM","events","e","logGroup","log","logGroupEnd","rootRoute","routerState","initialRouterNavigation","preloader","bootstrappedComponentRef","components","resetRootComponentType","componentTypes","setUpPreloading","initialNavigation","setUpLocationChangeListener","provideRouterInitializer","ROUTER_INITIALIZER","useFactory","deps","ApplicationRef","RouterPreloader","ROUTER_CONFIGURATION","APP_BOOTSTRAP_LISTENER","useExisting","OpaqueToken","LoadedRouterConfig","factoryResolver","injectorFactory","RouterConfigLoader","load","parentInjector","loadModuleFactory","componentFactoryResolver","offlineMode_1","Compiler","t","compileModuleAsync","DefaultUrlSerializer","serialize","defineProperty","enumerable","configurable","UrlSerializer","parse","UrlParser","parseRootSegment","parseQueryParams","parseFragment","query","encodeURI","remaining","peekStartsWith","capture","parseChildren","parseSegments","parseParens","matrixParams","parseMatrixParams","parseQueryParam","decodeURI","parseParam","valueMatch","decodedKey","decodedVal","currentVal","allowPrimary","indexOf","substr","allowRedirects","expanded$","expandSegmentGroup","urlTrees$","rootSegmentGroup","noMatchError","mapped$","rootCandidate","expandChildren","expandSegment","routes$","processedRoutes$","expandSegmentAgainstRoute","concattedProcessedRoutes$","first$","noLeftoversInUrl","matchSegmentAgainstRoute","expandSegmentAgainstRouteUsingRedirect","expandWildCardWithParamsAgainstRouteUsingRedirect","expandRegularSegmentAgainstRouteUsingRedirect","applyRedirectCommands","lineralizeSegments","newSegments","rawSegmentGroup","consumedSegments_1","rawSlicedSegments_1","childConfig$","routerConfig","childInjector","childConfig","cs","shouldLoad","applyRedirectCreatreUrlTree","newRoot","createSegmentGroup","createQueryParams","redirectToParams","actualParams","updatedSegments","createSegments","redirectToSegments","actualSegments","findPosParam","findOrReturn","redirectToUrlSegment","pos","idx","actualSegments_1","splice","Tree","firstChild","siblings","__extends$1","futureSnapshot","urlSegment","lastPathIndex","_resolve","cmdWithOutlet","find","processSegmentGroup","freeze","rootNode","routeState","inheriteParamsAndData","routeNode","processSegment","config_1","processSegmentAgainstRoute","rawSegment","snapshot_1","rawSlicedSegments","RouterOutletMap","registerOutlet","removeOutlet","UrlHandlingStrategy","shouldProcessUrl","extract","newUrlPart","rawUrl","DefaultUrlHandlingStrategy","wholeUrl","NavigationStart","id","NavigationEnd","urlAfterRedirects","NavigationCancel","reason","NavigationError","RoutesRecognized","DefaultRouteReuseStrategy","shouldDetach","store","detachedTree","shouldAttach","future","navigations","routerEvents","Subject","navigationId","navigated","resetConfig","currentUrlTree","rawUrlTree","currentRouterState","processNavigations","navigateByUrl","replaceUrl","locationSubscription","Zone","wrap","change","scheduleNavigation","serializeUrl","ngOnDestroy","dispose","relativeTo","preserveQueryParams","preserveFragment","q","f","extras","skipLocationChange","navigate","removeEmptyProps","parseUrl","isActive","concatMap","executeScheduledNavigation","catch","lastNavigation","reject","rej","urlTransition","runNavigate","shouldPreventPushState","shouldReplaceUrl","precreatedState","go","resolvePromise","rejectPromise","urlAndSnapshot$","appliedUrl","redirectsApplied$","preActivation","navigationIsSuccessful","preactivationTraverse$","PreActivation","traverse","preactivationCheckGuards","checkGuards","shouldActivate","preactivationResolveData$","resolveData","routerState$","storedState","storedUrl","isCurrentPathEqualTo","replaceState","ActivateRoutes","activate","resetUrlToCurrentUrlTree","ee","CanActivate","CanDeactivate","checks","parentOutletMap","futureRoot","currRoot","traverseChildRoutes","checks$","runningChecks$","runCanActivateChild","runCanActivate","s2","runCanDeactivate","runResolve","futureNode","currNode","futurePath","prevChildren","traverseRoutes","deactiveRouteAndItsChildren","isActivated","canActivate","observable","getToken","canActivateChildGuards","reverse","extractCanActivateChild","guards","canActivateChild","canDeactivate","canDeactivate$","resolveNode","resolvedData","resolver","token","futureState","currState","deactivateChildRoutes","activateChildRoutes","deactivateRoutes","activateRoutes","stored","attach","componentRef","placeComponentIntoOutlet","resolved","locationInjector","ComponentFactoryResolver","locationFactoryResolver","ReflectiveInjector","detachAndStoreRouteSubtree","deactiveRouteAndOutlet","detach","childOutletMap","deactivate","RouterLink","set","onClick","decorators","type","Directive","args","ctorParameters","propDecorators","Input","routerLink","HostListener","RouterLinkWithHref","locationStrategy","subscription","updateTargetUrlAndHref","ngOnChanges","changes","button","ctrlKey","metaKey","href","prepareExternalUrl","LocationStrategy","HostBinding","RouterLinkActive","element","renderer","classes","routerLinkActiveOptions","update","hasActiveLink","ngAfterContentInit","links","linksWithHrefs","setElementClass","nativeElement","isLinkActive","link","some","exportAs","ElementRef","Renderer","ContentChildren","descendants","routerLinkActive","RouterOutlet","activateEvents","EventEmitter","deactivateEvents","instance","_activatedRoute","activatedRoute","insert","hostView","destroy","emit","providers","resolveComponentFactory","inj","fromResolvedProviders","createComponent","changeDetectorRef","detectChanges","ViewContainerRef","Attribute","Output","RouteReuseStrategy","handle","__platform_browser_private__","PreloadingStrategy","preload","PreloadAllModules","NoPreloading","moduleLoader","preloadingStrategy","processRoutes","preloadConfig","loaded","Injectable","NgModuleFactoryLoader","Injector","ROUTER_DIRECTIVES","ROUTER_FORROOT_GUARD","ROUTER_PROVIDERS","Location","useClass","Optional","SystemJsNgModuleLoader","RouterModule","forRoot","ngModule","SkipSelf","PlatformLocation","Inject","APP_BASE_HREF","forChild","NgModule","declarations","VERSION","Version","__router_private__","__decorate","desc","arguments","getOwnPropertyDescriptor","Reflect","decorate","__metadata","metadata","AppComponent","Component","styles","template","changeDetection","ChangeDetectionStrategy","OnPush","platform_browser_1","router_1","lazyload_image_module_1","app_component_1","fade_in_image_component_1","bg_image_component_1","default_image_component_1","pixelated_image_component_1","scroll_container_component_1","FadeInImageComponent","BgImageComponent","DefaultImageComponent","PixelatedImageComponent","ScrollContainerComponent","imports","BrowserModule","LazyLoadImageModule","bootstrap","errorImage","images","defaultImage","elmRef","ngOnInit","myScrollCOntainer","querySelector","scroll_listener_1","lazyload_image_1","LazyLoadImageDirective","el","ngZone","scrollTarget","window","elementRef","runOutsideAngular","scrollObservable","scrollSubscription","startWith","let","lazyLoadImage","lazyImage","offset","getScrollListener","isUnsubscribed","String","NgZone","lazyload_image_directive_1","isVisible","threshold","_window","rect","getBoundingClientRect","elementLargerThenViewport","top","bottom","topInsideViewport","innerHeight","belowInsideViewport","rightsideInViewport","right","innerWidth","leftsideInViewport","left","loadImage","imagePath","img","Image","src","onload","onerror","setImage","isImgNode","nodeName","toLowerCase","style","backgroundImage","setLoadedStyle","className","image","errorImgPath","take","do","sampleObservable","sampleTime","share","scrollListeners","WeakMap","addEventListener","console","warn","empty","has","srollEvent","eventName","handler","event","passive","removeEventListener","listener","Subject_1","ObjectUnsubscribedError_1","_value","getValue","hasError","thrownError","ObjectUnsubscribedError","Notification","kind","hasValue","observe","accept","nextOrObserver","toObservable","throw","createNext","undefinedValueNotification","createError","createComplete","completeNotification","empty_1","catch_1","do_1","_do","let_1","letProto","letBind","mergeMap_1","flatMap","share_1","startWith_1","ScalarObservable_1","EmptyObservable_1","ArrayLikeObservable","arrayLike","EmptyObservable","ScalarObservable","dispatch","Subscriber_1","Subscription_1","ConnectableObservable","subjectFactory","_refCount","getSubject","subject","_subject","connect","connection","_connection","Subscription","ConnectableSubscriber","EMPTY","refCount","RefCountOperator","connectableObservableDescriptor","writable","connectable","_error","_unsubscribe","SubjectSubscriber","refCounter","RefCountSubscriber","sharedConnection","Subscriber","isArray_1","isPromise_1","PromiseObservable_1","IteratorObservable_1","ArrayObservable_1","ArrayLikeObservable_1","iterator_1","observeOn_1","observable_1","isArrayLike","x","FromObservable","$$observable","ArrayObservable","isPromise","$$iterator","IteratorObservable","TypeError","ObserveOnSubscriber","getIterator","StringIterator","ArrayIterator","toLength","o","len","isNaN","numberIsFinite","sign","Math","floor","abs","maxSafeInteger","isFinite","valueAsNumber","iterator","done","return","arr","pow","FromObservable_1","concatStatic","isScheduler_1","isScheduler","pop","mergeAll_1","MergeAllOperator","DoOperator","DoSubscriber","safeSubscriber","syncErrorThrowable","syncErrorThrown","syncErrorValue","predicate","thisArg","EveryOperator","EverySubscriber","everyValueMatch","defaultValue","FirstOperator","EmptyError_1","FirstSubscriber","_emitted","_tryPredicate","_emit","_tryResultSelector","_emitFinal","LastOperator","LastSubscriber","lastValue","func","multicast","subjectOrSubjectFactory","MulticastOperator","ConnectableObservable_1","observeOn","delay","ObserveOnOperator","Notification_1","notification","scheduleMessage","ObserveOnMessage","accumulator","seed","hasSeed","ReduceOperator","ReduceSubscriber","acc","_tryReduce","shareSubjectFactory","multicast_1","array","concat_1"],"mappings":"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","file":"main.bundle.js","sourcesContent":["webpackJsonp([2],[\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(2);\r\n\tvar platform_browser_dynamic_1 = __webpack_require__(56);\r\n\tvar app_module_1 = __webpack_require__(85);\r\n\tfunction main() {\r\n\t    platform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(app_module_1.AppModule);\r\n\t}\r\n\tif (false) {\r\n\t    if (document.readyState === 'complete') {\r\n\t        console.clear();\r\n\t        main();\r\n\t    }\r\n\t    else {\r\n\t        document.addEventListener('DOMContentLoaded', main);\r\n\t    }\r\n\t    module.hot.accept();\r\n\t}\r\n\telse {\r\n\t    core_1.enableProdMode();\r\n\t    main();\r\n\t}\r\n\n\n/***/ },\n/* 1 */,\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */,\n/* 6 */,\n/* 7 */,\n/* 8 */,\n/* 9 */,\n/* 10 */,\n/* 11 */,\n/* 12 */,\n/* 13 */,\n/* 14 */,\n/* 15 */,\n/* 16 */,\n/* 17 */,\n/* 18 */,\n/* 19 */,\n/* 20 */,\n/* 21 */,\n/* 22 */,\n/* 23 */,\n/* 24 */,\n/* 25 */,\n/* 26 */,\n/* 27 */,\n/* 28 */,\n/* 29 */,\n/* 30 */,\n/* 31 */,\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar subscribeToResult_1 = __webpack_require__(24);\n\tvar OuterSubscriber_1 = __webpack_require__(21);\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Projects each source value to an Observable which is merged in the output\n\t * Observable.\n\t *\n\t * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n\t * these inner Observables using {@link mergeAll}.</span>\n\t *\n\t * <img src=\"./img/mergeMap.png\" width=\"100%\">\n\t *\n\t * Returns an Observable that emits items based on applying a function that you\n\t * supply to each item emitted by the source Observable, where that function\n\t * returns an Observable, and then merging those resulting Observables and\n\t * emitting the results of this merger.\n\t *\n\t * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n\t * var letters = Rx.Observable.of('a', 'b', 'c');\n\t * var result = letters.mergeMap(x =>\n\t *   Rx.Observable.interval(1000).map(i => x+i)\n\t * );\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * // Results in the following:\n\t * // a0\n\t * // b0\n\t * // c0\n\t * // a1\n\t * // b1\n\t * // c1\n\t * // continues to list a,b,c with respective ascending integers\n\t *\n\t * @see {@link concatMap}\n\t * @see {@link exhaustMap}\n\t * @see {@link merge}\n\t * @see {@link mergeAll}\n\t * @see {@link mergeMapTo}\n\t * @see {@link mergeScan}\n\t * @see {@link switchMap}\n\t *\n\t * @param {function(value: T, ?index: number): Observable} project A function\n\t * that, when applied to an item emitted by the source Observable, returns an\n\t * Observable.\n\t * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n\t * A function to produce the value on the output Observable based on the values\n\t * and the indices of the source (outer) emission and the inner Observable\n\t * emission. The arguments passed to this function are:\n\t * - `outerValue`: the value that came from the source\n\t * - `innerValue`: the value that came from the projected Observable\n\t * - `outerIndex`: the \"index\" of the value that came from the source\n\t * - `innerIndex`: the \"index\" of the value from the projected Observable\n\t * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n\t * Observables being subscribed to concurrently.\n\t * @return {Observable} An Observable that emits the result of applying the\n\t * projection function (and the optional `resultSelector`) to each item emitted\n\t * by the source Observable and merging the results of the Observables obtained\n\t * from this transformation.\n\t * @method mergeMap\n\t * @owner Observable\n\t */\n\tfunction mergeMap(project, resultSelector, concurrent) {\n\t    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t    if (typeof resultSelector === 'number') {\n\t        concurrent = resultSelector;\n\t        resultSelector = null;\n\t    }\n\t    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));\n\t}\n\texports.mergeMap = mergeMap;\n\tvar MergeMapOperator = (function () {\n\t    function MergeMapOperator(project, resultSelector, concurrent) {\n\t        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t        this.project = project;\n\t        this.resultSelector = resultSelector;\n\t        this.concurrent = concurrent;\n\t    }\n\t    MergeMapOperator.prototype.call = function (observer, source) {\n\t        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));\n\t    };\n\t    return MergeMapOperator;\n\t}());\n\texports.MergeMapOperator = MergeMapOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar MergeMapSubscriber = (function (_super) {\n\t    __extends(MergeMapSubscriber, _super);\n\t    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {\n\t        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t        _super.call(this, destination);\n\t        this.project = project;\n\t        this.resultSelector = resultSelector;\n\t        this.concurrent = concurrent;\n\t        this.hasCompleted = false;\n\t        this.buffer = [];\n\t        this.active = 0;\n\t        this.index = 0;\n\t    }\n\t    MergeMapSubscriber.prototype._next = function (value) {\n\t        if (this.active < this.concurrent) {\n\t            this._tryNext(value);\n\t        }\n\t        else {\n\t            this.buffer.push(value);\n\t        }\n\t    };\n\t    MergeMapSubscriber.prototype._tryNext = function (value) {\n\t        var result;\n\t        var index = this.index++;\n\t        try {\n\t            result = this.project(value, index);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.active++;\n\t        this._innerSub(result, value, index);\n\t    };\n\t    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n\t        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n\t    };\n\t    MergeMapSubscriber.prototype._complete = function () {\n\t        this.hasCompleted = true;\n\t        if (this.active === 0 && this.buffer.length === 0) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n\t        if (this.resultSelector) {\n\t            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n\t        }\n\t        else {\n\t            this.destination.next(innerValue);\n\t        }\n\t    };\n\t    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n\t        var result;\n\t        try {\n\t            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.destination.next(result);\n\t    };\n\t    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n\t        var buffer = this.buffer;\n\t        this.remove(innerSub);\n\t        this.active--;\n\t        if (buffer.length > 0) {\n\t            this._next(buffer.shift());\n\t        }\n\t        else if (this.active === 0 && this.hasCompleted) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    return MergeMapSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\texports.MergeMapSubscriber = MergeMapSubscriber;\n\t//# sourceMappingURL=mergeMap.js.map\n\n/***/ },\n/* 33 */,\n/* 34 */,\n/* 35 */,\n/* 36 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t/**\n\t * An error thrown when an Observable or a sequence was queried but has no\n\t * elements.\n\t *\n\t * @see {@link first}\n\t * @see {@link last}\n\t * @see {@link single}\n\t *\n\t * @class EmptyError\n\t */\n\tvar EmptyError = (function (_super) {\n\t    __extends(EmptyError, _super);\n\t    function EmptyError() {\n\t        var err = _super.call(this, 'no elements in sequence');\n\t        this.name = err.name = 'EmptyError';\n\t        this.stack = err.stack;\n\t        this.message = err.message;\n\t    }\n\t    return EmptyError;\n\t}(Error));\n\texports.EmptyError = EmptyError;\n\t//# sourceMappingURL=EmptyError.js.map\n\n/***/ },\n/* 37 */,\n/* 38 */,\n/* 39 */,\n/* 40 */,\n/* 41 */,\n/* 42 */,\n/* 43 */,\n/* 44 */,\n/* 45 */,\n/* 46 */,\n/* 47 */,\n/* 48 */,\n/* 49 */,\n/* 50 */,\n/* 51 */,\n/* 52 */,\n/* 53 */,\n/* 54 */,\n/* 55 */,\n/* 56 */,\n/* 57 */,\n/* 58 */,\n/* 59 */,\n/* 60 */,\n/* 61 */,\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar root_1 = __webpack_require__(8);\n\tvar Observable_1 = __webpack_require__(1);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar PromiseObservable = (function (_super) {\n\t    __extends(PromiseObservable, _super);\n\t    function PromiseObservable(promise, scheduler) {\n\t        _super.call(this);\n\t        this.promise = promise;\n\t        this.scheduler = scheduler;\n\t    }\n\t    /**\n\t     * Converts a Promise to an Observable.\n\t     *\n\t     * <span class=\"informal\">Returns an Observable that just emits the Promise's\n\t     * resolved value, then completes.</span>\n\t     *\n\t     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n\t     * Observable. If the Promise resolves with a value, the output Observable\n\t     * emits that resolved value as a `next`, and then completes. If the Promise\n\t     * is rejected, then the output Observable emits the corresponding Error.\n\t     *\n\t     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n\t     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n\t     * result.subscribe(x => console.log(x), e => console.error(e));\n\t     *\n\t     * @see {@link bindCallback}\n\t     * @see {@link from}\n\t     *\n\t     * @param {Promise<T>} promise The promise to be converted.\n\t     * @param {Scheduler} [scheduler] An optional Scheduler to use for scheduling\n\t     * the delivery of the resolved value (or the rejection).\n\t     * @return {Observable<T>} An Observable which wraps the Promise.\n\t     * @static true\n\t     * @name fromPromise\n\t     * @owner Observable\n\t     */\n\t    PromiseObservable.create = function (promise, scheduler) {\n\t        return new PromiseObservable(promise, scheduler);\n\t    };\n\t    PromiseObservable.prototype._subscribe = function (subscriber) {\n\t        var _this = this;\n\t        var promise = this.promise;\n\t        var scheduler = this.scheduler;\n\t        if (scheduler == null) {\n\t            if (this._isScalar) {\n\t                if (!subscriber.closed) {\n\t                    subscriber.next(this.value);\n\t                    subscriber.complete();\n\t                }\n\t            }\n\t            else {\n\t                promise.then(function (value) {\n\t                    _this.value = value;\n\t                    _this._isScalar = true;\n\t                    if (!subscriber.closed) {\n\t                        subscriber.next(value);\n\t                        subscriber.complete();\n\t                    }\n\t                }, function (err) {\n\t                    if (!subscriber.closed) {\n\t                        subscriber.error(err);\n\t                    }\n\t                })\n\t                    .then(null, function (err) {\n\t                    // escape the promise trap, throw unhandled errors\n\t                    root_1.root.setTimeout(function () { throw err; });\n\t                });\n\t            }\n\t        }\n\t        else {\n\t            if (this._isScalar) {\n\t                if (!subscriber.closed) {\n\t                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });\n\t                }\n\t            }\n\t            else {\n\t                promise.then(function (value) {\n\t                    _this.value = value;\n\t                    _this._isScalar = true;\n\t                    if (!subscriber.closed) {\n\t                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));\n\t                    }\n\t                }, function (err) {\n\t                    if (!subscriber.closed) {\n\t                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));\n\t                    }\n\t                })\n\t                    .then(null, function (err) {\n\t                    // escape the promise trap, throw unhandled errors\n\t                    root_1.root.setTimeout(function () { throw err; });\n\t                });\n\t            }\n\t        }\n\t    };\n\t    return PromiseObservable;\n\t}(Observable_1.Observable));\n\texports.PromiseObservable = PromiseObservable;\n\tfunction dispatchNext(arg) {\n\t    var value = arg.value, subscriber = arg.subscriber;\n\t    if (!subscriber.closed) {\n\t        subscriber.next(value);\n\t        subscriber.complete();\n\t    }\n\t}\n\tfunction dispatchError(arg) {\n\t    var err = arg.err, subscriber = arg.subscriber;\n\t    if (!subscriber.closed) {\n\t        subscriber.error(err);\n\t    }\n\t}\n\t//# sourceMappingURL=PromiseObservable.js.map\n\n/***/ },\n/* 63 */,\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar OuterSubscriber_1 = __webpack_require__(21);\n\tvar subscribeToResult_1 = __webpack_require__(24);\n\t/**\n\t * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n\t * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n\t *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n\t *  is returned by the `selector` will be used to continue the observable chain.\n\t * @return {Observable} an observable that originates from either the source or the observable returned by the\n\t *  catch `selector` function.\n\t * @method catch\n\t * @name catch\n\t * @owner Observable\n\t */\n\tfunction _catch(selector) {\n\t    var operator = new CatchOperator(selector);\n\t    var caught = this.lift(operator);\n\t    return (operator.caught = caught);\n\t}\n\texports._catch = _catch;\n\tvar CatchOperator = (function () {\n\t    function CatchOperator(selector) {\n\t        this.selector = selector;\n\t    }\n\t    CatchOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n\t    };\n\t    return CatchOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar CatchSubscriber = (function (_super) {\n\t    __extends(CatchSubscriber, _super);\n\t    function CatchSubscriber(destination, selector, caught) {\n\t        _super.call(this, destination);\n\t        this.selector = selector;\n\t        this.caught = caught;\n\t    }\n\t    // NOTE: overriding `error` instead of `_error` because we don't want\n\t    // to have this flag this subscriber as `isStopped`.\n\t    CatchSubscriber.prototype.error = function (err) {\n\t        if (!this.isStopped) {\n\t            var result = void 0;\n\t            try {\n\t                result = this.selector(err, this.caught);\n\t            }\n\t            catch (err) {\n\t                this.destination.error(err);\n\t                return;\n\t            }\n\t            this.unsubscribe();\n\t            this.destination.remove(this);\n\t            subscribeToResult_1.subscribeToResult(this, result);\n\t        }\n\t    };\n\t    return CatchSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\t//# sourceMappingURL=catch.js.map\n\n/***/ },\n/* 65 */,\n/* 66 */,\n/* 67 */,\n/* 68 */,\n/* 69 */,\n/* 70 */,\n/* 71 */,\n/* 72 */,\n/* 73 */,\n/* 74 */,\n/* 75 */,\n/* 76 */,\n/* 77 */,\n/* 78 */,\n/* 79 */,\n/* 80 */,\n/* 81 */,\n/* 82 */,\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @license Angular v3.4.1\n\t * (c) 2010-2016 Google, Inc. https://angular.io/\n\t * License: MIT\n\t */(function (global, factory) {\n\t   true ? factory(exports, __webpack_require__(55), __webpack_require__(2), __webpack_require__(95), __webpack_require__(14), __webpack_require__(118), __webpack_require__(63), __webpack_require__(124), __webpack_require__(126), __webpack_require__(128), __webpack_require__(66), __webpack_require__(32), __webpack_require__(134), __webpack_require__(1), __webpack_require__(64), __webpack_require__(123), __webpack_require__(36), __webpack_require__(120), __webpack_require__(129), __webpack_require__(22), __webpack_require__(20), __webpack_require__(65)) :\n\t  typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/core', 'rxjs/BehaviorSubject', 'rxjs/Subject', 'rxjs/observable/from', 'rxjs/observable/of', 'rxjs/operator/concatMap', 'rxjs/operator/every', 'rxjs/operator/first', 'rxjs/operator/map', 'rxjs/operator/mergeMap', 'rxjs/operator/reduce', 'rxjs/Observable', 'rxjs/operator/catch', 'rxjs/operator/concatAll', 'rxjs/util/EmptyError', 'rxjs/observable/fromPromise', 'rxjs/operator/last', 'rxjs/operator/mergeAll', '@angular/platform-browser', 'rxjs/operator/filter'], factory) :\n\t  (factory((global.ng = global.ng || {}, global.ng.router = global.ng.router || {}),global.ng.common,global.ng.core,global.Rx,global.Rx,global.Rx.Observable,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.ng.platformBrowser,global.Rx.Observable.prototype));\n\t}(this, function (exports,_angular_common,_angular_core,rxjs_BehaviorSubject,rxjs_Subject,rxjs_observable_from,rxjs_observable_of,rxjs_operator_concatMap,rxjs_operator_every,rxjs_operator_first,rxjs_operator_map,rxjs_operator_mergeMap,rxjs_operator_reduce,rxjs_Observable,rxjs_operator_catch,rxjs_operator_concatAll,rxjs_util_EmptyError,rxjs_observable_fromPromise,l,rxjs_operator_mergeAll,_angular_platformBrowser,rxjs_operator_filter) { 'use strict';\n\t\n\t  /**\n\t   * @license\n\t   * Copyright Google Inc. All Rights Reserved.\n\t   *\n\t   * Use of this source code is governed by an MIT-style license that can be\n\t   * found in the LICENSE file at https://angular.io/license\n\t   */\n\t  var __extends = (this && this.__extends) || function (d, b) {\n\t      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t      function __() { this.constructor = d; }\n\t      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t  };\n\t  /**\n\t   * @whatItDoes Name of the primary outlet.\n\t   *\n\t   * @stable\n\t   */\n\t  var /** @type {?} */ PRIMARY_OUTLET = 'primary';\n\t  var NavigationCancelingError = (function (_super) {\n\t      __extends(NavigationCancelingError, _super);\n\t      /**\n\t       * @param {?} message\n\t       */\n\t      function NavigationCancelingError(message) {\n\t          _super.call(this, message);\n\t          this.message = message;\n\t          this.stack = (new Error(message)).stack;\n\t      }\n\t      /**\n\t       * @return {?}\n\t       */\n\t      NavigationCancelingError.prototype.toString = function () { return this.message; };\n\t      return NavigationCancelingError;\n\t  }(Error));\n\t  /**\n\t   * @param {?} segments\n\t   * @param {?} segmentGroup\n\t   * @param {?} route\n\t   * @return {?}\n\t   */\n\t  function defaultUrlMatcher(segments, segmentGroup, route) {\n\t      var /** @type {?} */ path = route.path;\n\t      var /** @type {?} */ parts = path.split('/');\n\t      var /** @type {?} */ posParams = {};\n\t      var /** @type {?} */ consumed = [];\n\t      var /** @type {?} */ currentIndex = 0;\n\t      for (var /** @type {?} */ i = 0; i < parts.length; ++i) {\n\t          if (currentIndex >= segments.length)\n\t              return null;\n\t          var /** @type {?} */ current = segments[currentIndex];\n\t          var /** @type {?} */ p = parts[i];\n\t          var /** @type {?} */ isPosParam = p.startsWith(':');\n\t          if (!isPosParam && p !== current.path)\n\t              return null;\n\t          if (isPosParam) {\n\t              posParams[p.substring(1)] = current;\n\t          }\n\t          consumed.push(current);\n\t          currentIndex++;\n\t      }\n\t      if (route.pathMatch === 'full' &&\n\t          (segmentGroup.hasChildren() || currentIndex < segments.length)) {\n\t          return null;\n\t      }\n\t      else {\n\t          return { consumed: consumed, posParams: posParams };\n\t      }\n\t  }\n\t\n\t  /**\n\t   * @param {?} a\n\t   * @param {?} b\n\t   * @return {?}\n\t   */\n\t  function shallowEqualArrays(a, b) {\n\t      if (a.length !== b.length)\n\t          return false;\n\t      for (var /** @type {?} */ i = 0; i < a.length; ++i) {\n\t          if (!shallowEqual(a[i], b[i]))\n\t              return false;\n\t      }\n\t      return true;\n\t  }\n\t  /**\n\t   * @param {?} a\n\t   * @param {?} b\n\t   * @return {?}\n\t   */\n\t  function shallowEqual(a, b) {\n\t      var /** @type {?} */ k1 = Object.keys(a);\n\t      var /** @type {?} */ k2 = Object.keys(b);\n\t      if (k1.length != k2.length) {\n\t          return false;\n\t      }\n\t      var /** @type {?} */ key;\n\t      for (var /** @type {?} */ i = 0; i < k1.length; i++) {\n\t          key = k1[i];\n\t          if (a[key] !== b[key]) {\n\t              return false;\n\t          }\n\t      }\n\t      return true;\n\t  }\n\t  /**\n\t   * @param {?} a\n\t   * @return {?}\n\t   */\n\t  function flatten(a) {\n\t      var /** @type {?} */ target = [];\n\t      for (var /** @type {?} */ i = 0; i < a.length; ++i) {\n\t          for (var /** @type {?} */ j = 0; j < a[i].length; ++j) {\n\t              target.push(a[i][j]);\n\t          }\n\t      }\n\t      return target;\n\t  }\n\t  /**\n\t   * @param {?} a\n\t   * @return {?}\n\t   */\n\t  function last(a) {\n\t      return a.length > 0 ? a[a.length - 1] : null;\n\t  }\n\t  /**\n\t   * @param {?} m1\n\t   * @param {?} m2\n\t   * @return {?}\n\t   */\n\t  function merge(m1, m2) {\n\t      var /** @type {?} */ m = {};\n\t      for (var attr in m1) {\n\t          if (m1.hasOwnProperty(attr)) {\n\t              m[attr] = m1[attr];\n\t          }\n\t      }\n\t      for (var attr in m2) {\n\t          if (m2.hasOwnProperty(attr)) {\n\t              m[attr] = m2[attr];\n\t          }\n\t      }\n\t      return m;\n\t  }\n\t  /**\n\t   * @param {?} map\n\t   * @param {?} callback\n\t   * @return {?}\n\t   */\n\t  function forEach(map, callback) {\n\t      for (var prop in map) {\n\t          if (map.hasOwnProperty(prop)) {\n\t              callback(map[prop], prop);\n\t          }\n\t      }\n\t  }\n\t  /**\n\t   * @param {?} obj\n\t   * @param {?} fn\n\t   * @return {?}\n\t   */\n\t  function waitForMap(obj, fn) {\n\t      var /** @type {?} */ waitFor = [];\n\t      var /** @type {?} */ res = {};\n\t      forEach(obj, function (a, k) {\n\t          if (k === PRIMARY_OUTLET) {\n\t              waitFor.push(rxjs_operator_map.map.call(fn(k, a), function (_) {\n\t                  res[k] = _;\n\t                  return _;\n\t              }));\n\t          }\n\t      });\n\t      forEach(obj, function (a, k) {\n\t          if (k !== PRIMARY_OUTLET) {\n\t              waitFor.push(rxjs_operator_map.map.call(fn(k, a), function (_) {\n\t                  res[k] = _;\n\t                  return _;\n\t              }));\n\t          }\n\t      });\n\t      if (waitFor.length > 0) {\n\t          var /** @type {?} */ concatted$ = rxjs_operator_concatAll.concatAll.call(rxjs_observable_of.of.apply(void 0, waitFor));\n\t          var /** @type {?} */ last$ = l.last.call(concatted$);\n\t          return rxjs_operator_map.map.call(last$, function () { return res; });\n\t      }\n\t      return rxjs_observable_of.of(res);\n\t  }\n\t  /**\n\t   * @param {?} observables\n\t   * @return {?}\n\t   */\n\t  function andObservables(observables) {\n\t      var /** @type {?} */ merged$ = rxjs_operator_mergeAll.mergeAll.call(observables);\n\t      return rxjs_operator_every.every.call(merged$, function (result) { return result === true; });\n\t  }\n\t  /**\n\t   * @param {?} value\n\t   * @return {?}\n\t   */\n\t  function wrapIntoObservable(value) {\n\t      if (value instanceof rxjs_Observable.Observable) {\n\t          return value;\n\t      }\n\t      if (value instanceof Promise) {\n\t          return rxjs_observable_fromPromise.fromPromise(value);\n\t      }\n\t      return rxjs_observable_of.of(value);\n\t  }\n\t\n\t  /**\n\t   * @experimental\n\t   */\n\t  var /** @type {?} */ ROUTES = new _angular_core.OpaqueToken('ROUTES');\n\t  var LoadedRouterConfig = (function () {\n\t      /**\n\t       * @param {?} routes\n\t       * @param {?} injector\n\t       * @param {?} factoryResolver\n\t       * @param {?} injectorFactory\n\t       */\n\t      function LoadedRouterConfig(routes, injector, factoryResolver, injectorFactory) {\n\t          this.routes = routes;\n\t          this.injector = injector;\n\t          this.factoryResolver = factoryResolver;\n\t          this.injectorFactory = injectorFactory;\n\t      }\n\t      return LoadedRouterConfig;\n\t  }());\n\t  var RouterConfigLoader = (function () {\n\t      /**\n\t       * @param {?} loader\n\t       * @param {?} compiler\n\t       */\n\t      function RouterConfigLoader(loader, compiler) {\n\t          this.loader = loader;\n\t          this.compiler = compiler;\n\t      }\n\t      /**\n\t       * @param {?} parentInjector\n\t       * @param {?} loadChildren\n\t       * @return {?}\n\t       */\n\t      RouterConfigLoader.prototype.load = function (parentInjector, loadChildren) {\n\t          return rxjs_operator_map.map.call(this.loadModuleFactory(loadChildren), function (r) {\n\t              var /** @type {?} */ ref = r.create(parentInjector);\n\t              var /** @type {?} */ injectorFactory = function (parent) { return r.create(parent).injector; };\n\t              return new LoadedRouterConfig(flatten(ref.injector.get(ROUTES)), ref.injector, ref.componentFactoryResolver, injectorFactory);\n\t          });\n\t      };\n\t      /**\n\t       * @param {?} loadChildren\n\t       * @return {?}\n\t       */\n\t      RouterConfigLoader.prototype.loadModuleFactory = function (loadChildren) {\n\t          var _this = this;\n\t          if (typeof loadChildren === 'string') {\n\t              return rxjs_observable_fromPromise.fromPromise(this.loader.load(loadChildren));\n\t          }\n\t          else {\n\t              var /** @type {?} */ offlineMode_1 = this.compiler instanceof _angular_core.Compiler;\n\t              return rxjs_operator_mergeMap.mergeMap.call(wrapIntoObservable(loadChildren()), function (t) { return offlineMode_1 ? rxjs_observable_of.of(/** @type {?} */ (t)) : rxjs_observable_fromPromise.fromPromise(_this.compiler.compileModuleAsync(t)); });\n\t          }\n\t      };\n\t      return RouterConfigLoader;\n\t  }());\n\t\n\t  /**\n\t   * @return {?}\n\t   */\n\t  function createEmptyUrlTree() {\n\t      return new UrlTree(new UrlSegmentGroup([], {}), {}, null);\n\t  }\n\t  /**\n\t   * @param {?} container\n\t   * @param {?} containee\n\t   * @param {?} exact\n\t   * @return {?}\n\t   */\n\t  function containsTree(container, containee, exact) {\n\t      if (exact) {\n\t          return equalQueryParams(container.queryParams, containee.queryParams) &&\n\t              equalSegmentGroups(container.root, containee.root);\n\t      }\n\t      return containsQueryParams(container.queryParams, containee.queryParams) &&\n\t          containsSegmentGroup(container.root, containee.root);\n\t  }\n\t  /**\n\t   * @param {?} container\n\t   * @param {?} containee\n\t   * @return {?}\n\t   */\n\t  function equalQueryParams(container, containee) {\n\t      return shallowEqual(container, containee);\n\t  }\n\t  /**\n\t   * @param {?} container\n\t   * @param {?} containee\n\t   * @return {?}\n\t   */\n\t  function equalSegmentGroups(container, containee) {\n\t      if (!equalPath(container.segments, containee.segments))\n\t          return false;\n\t      if (container.numberOfChildren !== containee.numberOfChildren)\n\t          return false;\n\t      for (var c in containee.children) {\n\t          if (!container.children[c])\n\t              return false;\n\t          if (!equalSegmentGroups(container.children[c], containee.children[c]))\n\t              return false;\n\t      }\n\t      return true;\n\t  }\n\t  /**\n\t   * @param {?} container\n\t   * @param {?} containee\n\t   * @return {?}\n\t   */\n\t  function containsQueryParams(container, containee) {\n\t      return Object.keys(containee) <= Object.keys(container) &&\n\t          Object.keys(containee).every(function (key) { return containee[key] === container[key]; });\n\t  }\n\t  /**\n\t   * @param {?} container\n\t   * @param {?} containee\n\t   * @return {?}\n\t   */\n\t  function containsSegmentGroup(container, containee) {\n\t      return containsSegmentGroupHelper(container, containee, containee.segments);\n\t  }\n\t  /**\n\t   * @param {?} container\n\t   * @param {?} containee\n\t   * @param {?} containeePaths\n\t   * @return {?}\n\t   */\n\t  function containsSegmentGroupHelper(container, containee, containeePaths) {\n\t      if (container.segments.length > containeePaths.length) {\n\t          var /** @type {?} */ current = container.segments.slice(0, containeePaths.length);\n\t          if (!equalPath(current, containeePaths))\n\t              return false;\n\t          if (containee.hasChildren())\n\t              return false;\n\t          return true;\n\t      }\n\t      else if (container.segments.length === containeePaths.length) {\n\t          if (!equalPath(container.segments, containeePaths))\n\t              return false;\n\t          for (var c in containee.children) {\n\t              if (!container.children[c])\n\t                  return false;\n\t              if (!containsSegmentGroup(container.children[c], containee.children[c]))\n\t                  return false;\n\t          }\n\t          return true;\n\t      }\n\t      else {\n\t          var /** @type {?} */ current = containeePaths.slice(0, container.segments.length);\n\t          var /** @type {?} */ next = containeePaths.slice(container.segments.length);\n\t          if (!equalPath(container.segments, current))\n\t              return false;\n\t          if (!container.children[PRIMARY_OUTLET])\n\t              return false;\n\t          return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);\n\t      }\n\t  }\n\t  /**\n\t   *  *\n\t    * *\n\t    * ```\n\t    * class MyComponent {\n\t    * constructor(router: Router) {\n\t    * const tree: UrlTree =\n\t    * router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n\t    * const f = tree.fragment; // return 'fragment'\n\t    * const q = tree.queryParams; // returns {debug: 'true'}\n\t    * const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n\t    * const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n\t    * g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n\t    * g.children['support'].segments; // return 1 segment 'help'\n\t    * }\n\t    * }\n\t    * ```\n\t    * *\n\t    * *\n\t    * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n\t    * serialized tree.\n\t    * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n\t    * *\n\t   */\n\t  var UrlTree = (function () {\n\t      /**\n\t       * @param {?} root\n\t       * @param {?} queryParams\n\t       * @param {?} fragment\n\t       */\n\t      function UrlTree(root, queryParams, fragment) {\n\t          this.root = root;\n\t          this.queryParams = queryParams;\n\t          this.fragment = fragment;\n\t      }\n\t      /**\n\t       * @return {?}\n\t       */\n\t      UrlTree.prototype.toString = function () { return new DefaultUrlSerializer().serialize(this); };\n\t      return UrlTree;\n\t  }());\n\t  /**\n\t   *  *\n\t    * See {@link UrlTree} for more information.\n\t    * *\n\t   */\n\t  var UrlSegmentGroup = (function () {\n\t      /**\n\t       * @param {?} segments\n\t       * @param {?} children\n\t       */\n\t      function UrlSegmentGroup(segments, children) {\n\t          var _this = this;\n\t          this.segments = segments;\n\t          this.children = children;\n\t          /** The parent node in the url tree */\n\t          this.parent = null;\n\t          forEach(children, function (v, k) { return v.parent = _this; });\n\t      }\n\t      /**\n\t       *  Wether the segment has child segments\n\t       * @return {?}\n\t       */\n\t      UrlSegmentGroup.prototype.hasChildren = function () { return this.numberOfChildren > 0; };\n\t      Object.defineProperty(UrlSegmentGroup.prototype, \"numberOfChildren\", {\n\t          /**\n\t           *  Number of child segments\n\t           * @return {?}\n\t           */\n\t          get: function () { return Object.keys(this.children).length; },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      /**\n\t       * @return {?}\n\t       */\n\t      UrlSegmentGroup.prototype.toString = function () { return serializePaths(this); };\n\t      return UrlSegmentGroup;\n\t  }());\n\t  /**\n\t   *  *\n\t    * *\n\t    * ```\n\t    * class MyComponent {\n\t    * constructor(router: Router) {\n\t    * const tree: UrlTree = router.parseUrl('/team;id=33');\n\t    * const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n\t    * const s: UrlSegment[] = g.segments;\n\t    * s[0].path; // returns 'team'\n\t    * s[0].parameters; // returns {id: 33}\n\t    * }\n\t    * }\n\t    * ```\n\t    * *\n\t    * *\n\t    * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n\t    * parameters associated with the segment.\n\t    * *\n\t   */\n\t  var UrlSegment = (function () {\n\t      /**\n\t       * @param {?} path\n\t       * @param {?} parameters\n\t       */\n\t      function UrlSegment(path, parameters) {\n\t          this.path = path;\n\t          this.parameters = parameters;\n\t      }\n\t      /**\n\t       * @return {?}\n\t       */\n\t      UrlSegment.prototype.toString = function () { return serializePath(this); };\n\t      return UrlSegment;\n\t  }());\n\t  /**\n\t   * @param {?} a\n\t   * @param {?} b\n\t   * @return {?}\n\t   */\n\t  function equalSegments(a, b) {\n\t      if (a.length !== b.length)\n\t          return false;\n\t      for (var /** @type {?} */ i = 0; i < a.length; ++i) {\n\t          if (a[i].path !== b[i].path)\n\t              return false;\n\t          if (!shallowEqual(a[i].parameters, b[i].parameters))\n\t              return false;\n\t      }\n\t      return true;\n\t  }\n\t  /**\n\t   * @param {?} a\n\t   * @param {?} b\n\t   * @return {?}\n\t   */\n\t  function equalPath(a, b) {\n\t      if (a.length !== b.length)\n\t          return false;\n\t      for (var /** @type {?} */ i = 0; i < a.length; ++i) {\n\t          if (a[i].path !== b[i].path)\n\t              return false;\n\t      }\n\t      return true;\n\t  }\n\t  /**\n\t   * @param {?} segment\n\t   * @param {?} fn\n\t   * @return {?}\n\t   */\n\t  function mapChildrenIntoArray(segment, fn) {\n\t      var /** @type {?} */ res = [];\n\t      forEach(segment.children, function (child, childOutlet) {\n\t          if (childOutlet === PRIMARY_OUTLET) {\n\t              res = res.concat(fn(child, childOutlet));\n\t          }\n\t      });\n\t      forEach(segment.children, function (child, childOutlet) {\n\t          if (childOutlet !== PRIMARY_OUTLET) {\n\t              res = res.concat(fn(child, childOutlet));\n\t          }\n\t      });\n\t      return res;\n\t  }\n\t  /**\n\t   *  *\n\t    * make all URLs case insensitive by providing a custom UrlSerializer.\n\t    * *\n\t    * See {@link DefaultUrlSerializer} for an example of a URL serializer.\n\t    * *\n\t   * @abstract\n\t   */\n\t  var UrlSerializer = (function () {\n\t      function UrlSerializer() {\n\t      }\n\t      /**\n\t       *  Parse a url into a {@link UrlTree}\n\t       * @abstract\n\t       * @param {?} url\n\t       * @return {?}\n\t       */\n\t      UrlSerializer.prototype.parse = function (url) { };\n\t      /**\n\t       *  Converts a {@link UrlTree} into a url\n\t       * @abstract\n\t       * @param {?} tree\n\t       * @return {?}\n\t       */\n\t      UrlSerializer.prototype.serialize = function (tree) { };\n\t      return UrlSerializer;\n\t  }());\n\t  /**\n\t   *  *\n\t    * *\n\t    * Example URLs:\n\t    * *\n\t    * ```\n\t    * /inbox/33(popup:compose)\n\t    * /inbox/33;open=true/messages/44\n\t    * ```\n\t    * *\n\t    * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n\t    * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n\t    * specify route specific parameters.\n\t    * *\n\t   */\n\t  var DefaultUrlSerializer = (function () {\n\t      function DefaultUrlSerializer() {\n\t      }\n\t      /**\n\t       *  Parses a url into a {@link UrlTree}\n\t       * @param {?} url\n\t       * @return {?}\n\t       */\n\t      DefaultUrlSerializer.prototype.parse = function (url) {\n\t          var /** @type {?} */ p = new UrlParser(url);\n\t          return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n\t      };\n\t      /**\n\t       *  Converts a {@link UrlTree} into a url\n\t       * @param {?} tree\n\t       * @return {?}\n\t       */\n\t      DefaultUrlSerializer.prototype.serialize = function (tree) {\n\t          var /** @type {?} */ segment = \"/\" + serializeSegment(tree.root, true);\n\t          var /** @type {?} */ query = serializeQueryParams(tree.queryParams);\n\t          var /** @type {?} */ fragment = tree.fragment !== null && tree.fragment !== undefined ? \"#\" + encodeURI(tree.fragment) : '';\n\t          return \"\" + segment + query + fragment;\n\t      };\n\t      return DefaultUrlSerializer;\n\t  }());\n\t  /**\n\t   * @param {?} segment\n\t   * @return {?}\n\t   */\n\t  function serializePaths(segment) {\n\t      return segment.segments.map(function (p) { return serializePath(p); }).join('/');\n\t  }\n\t  /**\n\t   * @param {?} segment\n\t   * @param {?} root\n\t   * @return {?}\n\t   */\n\t  function serializeSegment(segment, root) {\n\t      if (segment.hasChildren() && root) {\n\t          var /** @type {?} */ primary = segment.children[PRIMARY_OUTLET] ?\n\t              serializeSegment(segment.children[PRIMARY_OUTLET], false) :\n\t              '';\n\t          var /** @type {?} */ children_1 = [];\n\t          forEach(segment.children, function (v, k) {\n\t              if (k !== PRIMARY_OUTLET) {\n\t                  children_1.push(k + \":\" + serializeSegment(v, false));\n\t              }\n\t          });\n\t          if (children_1.length > 0) {\n\t              return primary + \"(\" + children_1.join('//') + \")\";\n\t          }\n\t          else {\n\t              return \"\" + primary;\n\t          }\n\t      }\n\t      else if (segment.hasChildren() && !root) {\n\t          var /** @type {?} */ children = mapChildrenIntoArray(segment, function (v, k) {\n\t              if (k === PRIMARY_OUTLET) {\n\t                  return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n\t              }\n\t              else {\n\t                  return [(k + \":\" + serializeSegment(v, false))];\n\t              }\n\t          });\n\t          return serializePaths(segment) + \"/(\" + children.join('//') + \")\";\n\t      }\n\t      else {\n\t          return serializePaths(segment);\n\t      }\n\t  }\n\t  /**\n\t   * @param {?} s\n\t   * @return {?}\n\t   */\n\t  function encode(s) {\n\t      return encodeURIComponent(s);\n\t  }\n\t  /**\n\t   * @param {?} s\n\t   * @return {?}\n\t   */\n\t  function decode(s) {\n\t      return decodeURIComponent(s);\n\t  }\n\t  /**\n\t   * @param {?} path\n\t   * @return {?}\n\t   */\n\t  function serializePath(path) {\n\t      return \"\" + encode(path.path) + serializeParams(path.parameters);\n\t  }\n\t  /**\n\t   * @param {?} params\n\t   * @return {?}\n\t   */\n\t  function serializeParams(params) {\n\t      return pairs(params).map(function (p) { return (\";\" + encode(p.first) + \"=\" + encode(p.second)); }).join('');\n\t  }\n\t  /**\n\t   * @param {?} params\n\t   * @return {?}\n\t   */\n\t  function serializeQueryParams(params) {\n\t      var /** @type {?} */ strParams = Object.keys(params).map(function (name) {\n\t          var /** @type {?} */ value = params[name];\n\t          return Array.isArray(value) ? value.map(function (v) { return (encode(name) + \"=\" + encode(v)); }).join('&') :\n\t              encode(name) + \"=\" + encode(value);\n\t      });\n\t      return strParams.length ? \"?\" + strParams.join(\"&\") : '';\n\t  }\n\t  var Pair = (function () {\n\t      /**\n\t       * @param {?} first\n\t       * @param {?} second\n\t       */\n\t      function Pair(first, second) {\n\t          this.first = first;\n\t          this.second = second;\n\t      }\n\t      return Pair;\n\t  }());\n\t  /**\n\t   * @param {?} obj\n\t   * @return {?}\n\t   */\n\t  function pairs(obj) {\n\t      var /** @type {?} */ res = [];\n\t      for (var prop in obj) {\n\t          if (obj.hasOwnProperty(prop)) {\n\t              res.push(new Pair(prop, obj[prop]));\n\t          }\n\t      }\n\t      return res;\n\t  }\n\t  var /** @type {?} */ SEGMENT_RE = /^[^\\/()?;=&#]+/;\n\t  /**\n\t   * @param {?} str\n\t   * @return {?}\n\t   */\n\t  function matchSegments(str) {\n\t      SEGMENT_RE.lastIndex = 0;\n\t      var /** @type {?} */ match = str.match(SEGMENT_RE);\n\t      return match ? match[0] : '';\n\t  }\n\t  var /** @type {?} */ QUERY_PARAM_RE = /^[^=?&#]+/;\n\t  /**\n\t   * @param {?} str\n\t   * @return {?}\n\t   */\n\t  function matchQueryParams(str) {\n\t      QUERY_PARAM_RE.lastIndex = 0;\n\t      var /** @type {?} */ match = str.match(SEGMENT_RE);\n\t      return match ? match[0] : '';\n\t  }\n\t  var /** @type {?} */ QUERY_PARAM_VALUE_RE = /^[^?&#]+/;\n\t  /**\n\t   * @param {?} str\n\t   * @return {?}\n\t   */\n\t  function matchUrlQueryParamValue(str) {\n\t      QUERY_PARAM_VALUE_RE.lastIndex = 0;\n\t      var /** @type {?} */ match = str.match(QUERY_PARAM_VALUE_RE);\n\t      return match ? match[0] : '';\n\t  }\n\t  var UrlParser = (function () {\n\t      /**\n\t       * @param {?} url\n\t       */\n\t      function UrlParser(url) {\n\t          this.url = url;\n\t          this.remaining = url;\n\t      }\n\t      /**\n\t       * @param {?} str\n\t       * @return {?}\n\t       */\n\t      UrlParser.prototype.peekStartsWith = function (str) { return this.remaining.startsWith(str); };\n\t      /**\n\t       * @param {?} str\n\t       * @return {?}\n\t       */\n\t      UrlParser.prototype.capture = function (str) {\n\t          if (!this.remaining.startsWith(str)) {\n\t              throw new Error(\"Expected \\\"\" + str + \"\\\".\");\n\t          }\n\t          this.remaining = this.remaining.substring(str.length);\n\t      };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      UrlParser.prototype.parseRootSegment = function () {\n\t          if (this.remaining.startsWith('/')) {\n\t              this.capture('/');\n\t          }\n\t          if (this.remaining === '' || this.remaining.startsWith('?') || this.remaining.startsWith('#')) {\n\t              return new UrlSegmentGroup([], {});\n\t          }\n\t          return new UrlSegmentGroup([], this.parseChildren());\n\t      };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      UrlParser.prototype.parseChildren = function () {\n\t          if (this.remaining.length == 0) {\n\t              return {};\n\t          }\n\t          if (this.peekStartsWith('/')) {\n\t              this.capture('/');\n\t          }\n\t          var /** @type {?} */ paths = [];\n\t          if (!this.peekStartsWith('(')) {\n\t              paths.push(this.parseSegments());\n\t          }\n\t          while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n\t              this.capture('/');\n\t              paths.push(this.parseSegments());\n\t          }\n\t          var /** @type {?} */ children = {};\n\t          if (this.peekStartsWith('/(')) {\n\t              this.capture('/');\n\t              children = this.parseParens(true);\n\t          }\n\t          var /** @type {?} */ res = {};\n\t          if (this.peekStartsWith('(')) {\n\t              res = this.parseParens(false);\n\t          }\n\t          if (paths.length > 0 || Object.keys(children).length > 0) {\n\t              res[PRIMARY_OUTLET] = new UrlSegmentGroup(paths, children);\n\t          }\n\t          return res;\n\t      };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      UrlParser.prototype.parseSegments = function () {\n\t          var /** @type {?} */ path = matchSegments(this.remaining);\n\t          if (path === '' && this.peekStartsWith(';')) {\n\t              throw new Error(\"Empty path url segment cannot have parameters: '\" + this.remaining + \"'.\");\n\t          }\n\t          this.capture(path);\n\t          var /** @type {?} */ matrixParams = {};\n\t          if (this.peekStartsWith(';')) {\n\t              matrixParams = this.parseMatrixParams();\n\t          }\n\t          return new UrlSegment(decode(path), matrixParams);\n\t      };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      UrlParser.prototype.parseQueryParams = function () {\n\t          var /** @type {?} */ params = {};\n\t          if (this.peekStartsWith('?')) {\n\t              this.capture('?');\n\t              this.parseQueryParam(params);\n\t              while (this.remaining.length > 0 && this.peekStartsWith('&')) {\n\t                  this.capture('&');\n\t                  this.parseQueryParam(params);\n\t              }\n\t          }\n\t          return params;\n\t      };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      UrlParser.prototype.parseFragment = function () {\n\t          if (this.peekStartsWith('#')) {\n\t              return decodeURI(this.remaining.substring(1));\n\t          }\n\t          return null;\n\t      };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      UrlParser.prototype.parseMatrixParams = function () {\n\t          var /** @type {?} */ params = {};\n\t          while (this.remaining.length > 0 && this.peekStartsWith(';')) {\n\t              this.capture(';');\n\t              this.parseParam(params);\n\t          }\n\t          return params;\n\t      };\n\t      /**\n\t       * @param {?} params\n\t       * @return {?}\n\t       */\n\t      UrlParser.prototype.parseParam = function (params) {\n\t          var /** @type {?} */ key = matchSegments(this.remaining);\n\t          if (!key) {\n\t              return;\n\t          }\n\t          this.capture(key);\n\t          var /** @type {?} */ value = '';\n\t          if (this.peekStartsWith('=')) {\n\t              this.capture('=');\n\t              var /** @type {?} */ valueMatch = matchSegments(this.remaining);\n\t              if (valueMatch) {\n\t                  value = valueMatch;\n\t                  this.capture(value);\n\t              }\n\t          }\n\t          params[decode(key)] = decode(value);\n\t      };\n\t      /**\n\t       * @param {?} params\n\t       * @return {?}\n\t       */\n\t      UrlParser.prototype.parseQueryParam = function (params) {\n\t          var /** @type {?} */ key = matchQueryParams(this.remaining);\n\t          if (!key) {\n\t              return;\n\t          }\n\t          this.capture(key);\n\t          var /** @type {?} */ value = '';\n\t          if (this.peekStartsWith('=')) {\n\t              this.capture('=');\n\t              var /** @type {?} */ valueMatch = matchUrlQueryParamValue(this.remaining);\n\t              if (valueMatch) {\n\t                  value = valueMatch;\n\t                  this.capture(value);\n\t              }\n\t          }\n\t          var /** @type {?} */ decodedKey = decode(key);\n\t          var /** @type {?} */ decodedVal = decode(value);\n\t          if (params.hasOwnProperty(decodedKey)) {\n\t              // Append to existing values\n\t              var /** @type {?} */ currentVal = params[decodedKey];\n\t              if (!Array.isArray(currentVal)) {\n\t                  currentVal = [currentVal];\n\t                  params[decodedKey] = currentVal;\n\t              }\n\t              currentVal.push(decodedVal);\n\t          }\n\t          else {\n\t              // Create a new value\n\t              params[decodedKey] = decodedVal;\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} allowPrimary\n\t       * @return {?}\n\t       */\n\t      UrlParser.prototype.parseParens = function (allowPrimary) {\n\t          var /** @type {?} */ segments = {};\n\t          this.capture('(');\n\t          while (!this.peekStartsWith(')') && this.remaining.length > 0) {\n\t              var /** @type {?} */ path = matchSegments(this.remaining);\n\t              var /** @type {?} */ next = this.remaining[path.length];\n\t              // if is is not one of these characters, then the segment was unescaped\n\t              // or the group was not closed\n\t              if (next !== '/' && next !== ')' && next !== ';') {\n\t                  throw new Error(\"Cannot parse url '\" + this.url + \"'\");\n\t              }\n\t              var /** @type {?} */ outletName = void 0;\n\t              if (path.indexOf(':') > -1) {\n\t                  outletName = path.substr(0, path.indexOf(':'));\n\t                  this.capture(outletName);\n\t                  this.capture(':');\n\t              }\n\t              else if (allowPrimary) {\n\t                  outletName = PRIMARY_OUTLET;\n\t              }\n\t              var /** @type {?} */ children = this.parseChildren();\n\t              segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :\n\t                  new UrlSegmentGroup([], children);\n\t              if (this.peekStartsWith('//')) {\n\t                  this.capture('//');\n\t              }\n\t          }\n\t          this.capture(')');\n\t          return segments;\n\t      };\n\t      return UrlParser;\n\t  }());\n\t\n\t  var NoMatch = (function () {\n\t      /**\n\t       * @param {?=} segmentGroup\n\t       */\n\t      function NoMatch(segmentGroup) {\n\t          if (segmentGroup === void 0) { segmentGroup = null; }\n\t          this.segmentGroup = segmentGroup;\n\t      }\n\t      return NoMatch;\n\t  }());\n\t  var AbsoluteRedirect = (function () {\n\t      /**\n\t       * @param {?} urlTree\n\t       */\n\t      function AbsoluteRedirect(urlTree) {\n\t          this.urlTree = urlTree;\n\t      }\n\t      return AbsoluteRedirect;\n\t  }());\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @return {?}\n\t   */\n\t  function noMatch(segmentGroup) {\n\t      return new rxjs_Observable.Observable(function (obs) { return obs.error(new NoMatch(segmentGroup)); });\n\t  }\n\t  /**\n\t   * @param {?} newTree\n\t   * @return {?}\n\t   */\n\t  function absoluteRedirect(newTree) {\n\t      return new rxjs_Observable.Observable(function (obs) { return obs.error(new AbsoluteRedirect(newTree)); });\n\t  }\n\t  /**\n\t   * @param {?} redirectTo\n\t   * @return {?}\n\t   */\n\t  function namedOutletsRedirect(redirectTo) {\n\t      return new rxjs_Observable.Observable(function (obs) { return obs.error(new Error(\"Only absolute redirects can have named outlets. redirectTo: '\" + redirectTo + \"'\")); });\n\t  }\n\t  /**\n\t   * @param {?} route\n\t   * @return {?}\n\t   */\n\t  function canLoadFails(route) {\n\t      return new rxjs_Observable.Observable(function (obs) { return obs.error(new NavigationCancelingError(\"Cannot load children because the guard of the route \\\"path: '\" + route.path + \"'\\\" returned false\")); });\n\t  }\n\t  /**\n\t   * @param {?} injector\n\t   * @param {?} configLoader\n\t   * @param {?} urlSerializer\n\t   * @param {?} urlTree\n\t   * @param {?} config\n\t   * @return {?}\n\t   */\n\t  function applyRedirects(injector, configLoader, urlSerializer, urlTree, config) {\n\t      return new ApplyRedirects(injector, configLoader, urlSerializer, urlTree, config).apply();\n\t  }\n\t  var ApplyRedirects = (function () {\n\t      /**\n\t       * @param {?} injector\n\t       * @param {?} configLoader\n\t       * @param {?} urlSerializer\n\t       * @param {?} urlTree\n\t       * @param {?} config\n\t       */\n\t      function ApplyRedirects(injector, configLoader, urlSerializer, urlTree, config) {\n\t          this.injector = injector;\n\t          this.configLoader = configLoader;\n\t          this.urlSerializer = urlSerializer;\n\t          this.urlTree = urlTree;\n\t          this.config = config;\n\t          this.allowRedirects = true;\n\t      }\n\t      /**\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.apply = function () {\n\t          var _this = this;\n\t          var /** @type {?} */ expanded$ = this.expandSegmentGroup(this.injector, this.config, this.urlTree.root, PRIMARY_OUTLET);\n\t          var /** @type {?} */ urlTrees$ = rxjs_operator_map.map.call(expanded$, function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup, _this.urlTree.queryParams, _this.urlTree.fragment); });\n\t          return rxjs_operator_catch._catch.call(urlTrees$, function (e) {\n\t              if (e instanceof AbsoluteRedirect) {\n\t                  // after an absolute redirect we do not apply any more redirects!\n\t                  _this.allowRedirects = false;\n\t                  // we need to run matching, so we can fetch all lazy-loaded modules\n\t                  return _this.match(e.urlTree);\n\t              }\n\t              else if (e instanceof NoMatch) {\n\t                  throw _this.noMatchError(e);\n\t              }\n\t              else {\n\t                  throw e;\n\t              }\n\t          });\n\t      };\n\t      /**\n\t       * @param {?} tree\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.match = function (tree) {\n\t          var _this = this;\n\t          var /** @type {?} */ expanded$ = this.expandSegmentGroup(this.injector, this.config, tree.root, PRIMARY_OUTLET);\n\t          var /** @type {?} */ mapped$ = rxjs_operator_map.map.call(expanded$, function (rootSegmentGroup) {\n\t              return _this.createUrlTree(rootSegmentGroup, tree.queryParams, tree.fragment);\n\t          });\n\t          return rxjs_operator_catch._catch.call(mapped$, function (e) {\n\t              if (e instanceof NoMatch) {\n\t                  throw _this.noMatchError(e);\n\t              }\n\t              else {\n\t                  throw e;\n\t              }\n\t          });\n\t      };\n\t      /**\n\t       * @param {?} e\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.noMatchError = function (e) {\n\t          return new Error(\"Cannot match any routes. URL Segment: '\" + e.segmentGroup + \"'\");\n\t      };\n\t      /**\n\t       * @param {?} rootCandidate\n\t       * @param {?} queryParams\n\t       * @param {?} fragment\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.createUrlTree = function (rootCandidate, queryParams, fragment) {\n\t          var /** @type {?} */ root = rootCandidate.segments.length > 0 ?\n\t              new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = rootCandidate, _a)) :\n\t              rootCandidate;\n\t          return new UrlTree(root, queryParams, fragment);\n\t          var _a;\n\t      };\n\t      /**\n\t       * @param {?} injector\n\t       * @param {?} routes\n\t       * @param {?} segmentGroup\n\t       * @param {?} outlet\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.expandSegmentGroup = function (injector, routes, segmentGroup, outlet) {\n\t          if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n\t              return rxjs_operator_map.map.call(this.expandChildren(injector, routes, segmentGroup), function (children) { return new UrlSegmentGroup([], children); });\n\t          }\n\t          else {\n\t              return this.expandSegment(injector, segmentGroup, routes, segmentGroup.segments, outlet, true);\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} injector\n\t       * @param {?} routes\n\t       * @param {?} segmentGroup\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.expandChildren = function (injector, routes, segmentGroup) {\n\t          var _this = this;\n\t          return waitForMap(segmentGroup.children, function (childOutlet, child) { return _this.expandSegmentGroup(injector, routes, child, childOutlet); });\n\t      };\n\t      /**\n\t       * @param {?} injector\n\t       * @param {?} segmentGroup\n\t       * @param {?} routes\n\t       * @param {?} segments\n\t       * @param {?} outlet\n\t       * @param {?} allowRedirects\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.expandSegment = function (injector, segmentGroup, routes, segments, outlet, allowRedirects) {\n\t          var _this = this;\n\t          var /** @type {?} */ routes$ = rxjs_observable_of.of.apply(void 0, routes);\n\t          var /** @type {?} */ processedRoutes$ = rxjs_operator_map.map.call(routes$, function (r) {\n\t              var /** @type {?} */ expanded$ = _this.expandSegmentAgainstRoute(injector, segmentGroup, routes, r, segments, outlet, allowRedirects);\n\t              return rxjs_operator_catch._catch.call(expanded$, function (e) {\n\t                  if (e instanceof NoMatch)\n\t                      return rxjs_observable_of.of(null);\n\t                  else\n\t                      throw e;\n\t              });\n\t          });\n\t          var /** @type {?} */ concattedProcessedRoutes$ = rxjs_operator_concatAll.concatAll.call(processedRoutes$);\n\t          var /** @type {?} */ first$ = rxjs_operator_first.first.call(concattedProcessedRoutes$, function (s) { return !!s; });\n\t          return rxjs_operator_catch._catch.call(first$, function (e, _) {\n\t              if (e instanceof rxjs_util_EmptyError.EmptyError) {\n\t                  if (_this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n\t                      return rxjs_observable_of.of(new UrlSegmentGroup([], {}));\n\t                  }\n\t                  else {\n\t                      throw new NoMatch(segmentGroup);\n\t                  }\n\t              }\n\t              else {\n\t                  throw e;\n\t              }\n\t          });\n\t      };\n\t      /**\n\t       * @param {?} segmentGroup\n\t       * @param {?} segments\n\t       * @param {?} outlet\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {\n\t          return segments.length === 0 && !segmentGroup.children[outlet];\n\t      };\n\t      /**\n\t       * @param {?} injector\n\t       * @param {?} segmentGroup\n\t       * @param {?} routes\n\t       * @param {?} route\n\t       * @param {?} paths\n\t       * @param {?} outlet\n\t       * @param {?} allowRedirects\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.expandSegmentAgainstRoute = function (injector, segmentGroup, routes, route, paths, outlet, allowRedirects) {\n\t          if (getOutlet$1(route) !== outlet)\n\t              return noMatch(segmentGroup);\n\t          if (route.redirectTo !== undefined && !(allowRedirects && this.allowRedirects))\n\t              return noMatch(segmentGroup);\n\t          if (route.redirectTo === undefined) {\n\t              return this.matchSegmentAgainstRoute(injector, segmentGroup, route, paths);\n\t          }\n\t          else {\n\t              return this.expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, paths, outlet);\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} injector\n\t       * @param {?} segmentGroup\n\t       * @param {?} routes\n\t       * @param {?} route\n\t       * @param {?} segments\n\t       * @param {?} outlet\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.expandSegmentAgainstRouteUsingRedirect = function (injector, segmentGroup, routes, route, segments, outlet) {\n\t          if (route.path === '**') {\n\t              return this.expandWildCardWithParamsAgainstRouteUsingRedirect(injector, routes, route, outlet);\n\t          }\n\t          else {\n\t              return this.expandRegularSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet);\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} injector\n\t       * @param {?} routes\n\t       * @param {?} route\n\t       * @param {?} outlet\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.expandWildCardWithParamsAgainstRouteUsingRedirect = function (injector, routes, route, outlet) {\n\t          var _this = this;\n\t          var /** @type {?} */ newTree = this.applyRedirectCommands([], route.redirectTo, {});\n\t          if (route.redirectTo.startsWith('/')) {\n\t              return absoluteRedirect(newTree);\n\t          }\n\t          else {\n\t              return rxjs_operator_mergeMap.mergeMap.call(this.lineralizeSegments(route, newTree), function (newSegments) {\n\t                  var /** @type {?} */ group = new UrlSegmentGroup(newSegments, {});\n\t                  return _this.expandSegment(injector, group, routes, newSegments, outlet, false);\n\t              });\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} injector\n\t       * @param {?} segmentGroup\n\t       * @param {?} routes\n\t       * @param {?} route\n\t       * @param {?} segments\n\t       * @param {?} outlet\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.expandRegularSegmentAgainstRouteUsingRedirect = function (injector, segmentGroup, routes, route, segments, outlet) {\n\t          var _this = this;\n\t          var _a = match(segmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild, positionalParamSegments = _a.positionalParamSegments;\n\t          if (!matched)\n\t              return noMatch(segmentGroup);\n\t          var /** @type {?} */ newTree = this.applyRedirectCommands(consumedSegments, route.redirectTo, /** @type {?} */ (positionalParamSegments));\n\t          if (route.redirectTo.startsWith('/')) {\n\t              return absoluteRedirect(newTree);\n\t          }\n\t          else {\n\t              return rxjs_operator_mergeMap.mergeMap.call(this.lineralizeSegments(route, newTree), function (newSegments) {\n\t                  return _this.expandSegment(injector, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);\n\t              });\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} injector\n\t       * @param {?} rawSegmentGroup\n\t       * @param {?} route\n\t       * @param {?} segments\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.matchSegmentAgainstRoute = function (injector, rawSegmentGroup, route, segments) {\n\t          var _this = this;\n\t          if (route.path === '**') {\n\t              if (route.loadChildren) {\n\t                  return rxjs_operator_map.map.call(this.configLoader.load(injector, route.loadChildren), function (r) {\n\t                      ((route))._loadedConfig = r;\n\t                      return rxjs_observable_of.of(new UrlSegmentGroup(segments, {}));\n\t                  });\n\t              }\n\t              else {\n\t                  return rxjs_observable_of.of(new UrlSegmentGroup(segments, {}));\n\t              }\n\t          }\n\t          else {\n\t              var _a = match(rawSegmentGroup, route, segments), matched = _a.matched, consumedSegments_1 = _a.consumedSegments, lastChild = _a.lastChild;\n\t              if (!matched)\n\t                  return noMatch(rawSegmentGroup);\n\t              var /** @type {?} */ rawSlicedSegments_1 = segments.slice(lastChild);\n\t              var /** @type {?} */ childConfig$ = this.getChildConfig(injector, route);\n\t              return rxjs_operator_mergeMap.mergeMap.call(childConfig$, function (routerConfig) {\n\t                  var /** @type {?} */ childInjector = routerConfig.injector;\n\t                  var /** @type {?} */ childConfig = routerConfig.routes;\n\t                  var _a = split(rawSegmentGroup, consumedSegments_1, rawSlicedSegments_1, childConfig), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;\n\t                  if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n\t                      var /** @type {?} */ expanded$ = _this.expandChildren(childInjector, childConfig, segmentGroup);\n\t                      return rxjs_operator_map.map.call(expanded$, function (children) { return new UrlSegmentGroup(consumedSegments_1, children); });\n\t                  }\n\t                  else if (childConfig.length === 0 && slicedSegments.length === 0) {\n\t                      return rxjs_observable_of.of(new UrlSegmentGroup(consumedSegments_1, {}));\n\t                  }\n\t                  else {\n\t                      var /** @type {?} */ expanded$ = _this.expandSegment(childInjector, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);\n\t                      return rxjs_operator_map.map.call(expanded$, function (cs) { return new UrlSegmentGroup(consumedSegments_1.concat(cs.segments), cs.children); });\n\t                  }\n\t              });\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} injector\n\t       * @param {?} route\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.getChildConfig = function (injector, route) {\n\t          var _this = this;\n\t          if (route.children) {\n\t              return rxjs_observable_of.of(new LoadedRouterConfig(route.children, injector, null, null));\n\t          }\n\t          else if (route.loadChildren) {\n\t              return rxjs_operator_mergeMap.mergeMap.call(runGuards(injector, route), function (shouldLoad) {\n\t                  if (shouldLoad) {\n\t                      if (((route))._loadedConfig) {\n\t                          return rxjs_observable_of.of(((route))._loadedConfig);\n\t                      }\n\t                      else {\n\t                          return rxjs_operator_map.map.call(_this.configLoader.load(injector, route.loadChildren), function (r) {\n\t                              ((route))._loadedConfig = r;\n\t                              return r;\n\t                          });\n\t                      }\n\t                  }\n\t                  else {\n\t                      return canLoadFails(route);\n\t                  }\n\t              });\n\t          }\n\t          else {\n\t              return rxjs_observable_of.of(new LoadedRouterConfig([], injector, null, null));\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} route\n\t       * @param {?} urlTree\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.lineralizeSegments = function (route, urlTree) {\n\t          var /** @type {?} */ res = [];\n\t          var /** @type {?} */ c = urlTree.root;\n\t          while (true) {\n\t              res = res.concat(c.segments);\n\t              if (c.numberOfChildren === 0) {\n\t                  return rxjs_observable_of.of(res);\n\t              }\n\t              else if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n\t                  return namedOutletsRedirect(route.redirectTo);\n\t              }\n\t              else {\n\t                  c = c.children[PRIMARY_OUTLET];\n\t              }\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} segments\n\t       * @param {?} redirectTo\n\t       * @param {?} posParams\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.applyRedirectCommands = function (segments, redirectTo, posParams) {\n\t          var /** @type {?} */ t = this.urlSerializer.parse(redirectTo);\n\t          return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\n\t      };\n\t      /**\n\t       * @param {?} redirectTo\n\t       * @param {?} urlTree\n\t       * @param {?} segments\n\t       * @param {?} posParams\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.applyRedirectCreatreUrlTree = function (redirectTo, urlTree, segments, posParams) {\n\t          var /** @type {?} */ newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n\t          return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\n\t      };\n\t      /**\n\t       * @param {?} redirectToParams\n\t       * @param {?} actualParams\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.createQueryParams = function (redirectToParams, actualParams) {\n\t          var /** @type {?} */ res = {};\n\t          forEach(redirectToParams, function (v, k) {\n\t              if (v.startsWith(':')) {\n\t                  res[k] = actualParams[v.substring(1)];\n\t              }\n\t              else {\n\t                  res[k] = v;\n\t              }\n\t          });\n\t          return res;\n\t      };\n\t      /**\n\t       * @param {?} redirectTo\n\t       * @param {?} group\n\t       * @param {?} segments\n\t       * @param {?} posParams\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.createSegmentGroup = function (redirectTo, group, segments, posParams) {\n\t          var _this = this;\n\t          var /** @type {?} */ updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n\t          var /** @type {?} */ children = {};\n\t          forEach(group.children, function (child, name) {\n\t              children[name] = _this.createSegmentGroup(redirectTo, child, segments, posParams);\n\t          });\n\t          return new UrlSegmentGroup(updatedSegments, children);\n\t      };\n\t      /**\n\t       * @param {?} redirectTo\n\t       * @param {?} redirectToSegments\n\t       * @param {?} actualSegments\n\t       * @param {?} posParams\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.createSegments = function (redirectTo, redirectToSegments, actualSegments, posParams) {\n\t          var _this = this;\n\t          return redirectToSegments.map(function (s) { return s.path.startsWith(':') ? _this.findPosParam(redirectTo, s, posParams) :\n\t              _this.findOrReturn(s, actualSegments); });\n\t      };\n\t      /**\n\t       * @param {?} redirectTo\n\t       * @param {?} redirectToUrlSegment\n\t       * @param {?} posParams\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.findPosParam = function (redirectTo, redirectToUrlSegment, posParams) {\n\t          var /** @type {?} */ pos = posParams[redirectToUrlSegment.path.substring(1)];\n\t          if (!pos)\n\t              throw new Error(\"Cannot redirect to '\" + redirectTo + \"'. Cannot find '\" + redirectToUrlSegment.path + \"'.\");\n\t          return pos;\n\t      };\n\t      /**\n\t       * @param {?} redirectToUrlSegment\n\t       * @param {?} actualSegments\n\t       * @return {?}\n\t       */\n\t      ApplyRedirects.prototype.findOrReturn = function (redirectToUrlSegment, actualSegments) {\n\t          var /** @type {?} */ idx = 0;\n\t          for (var _i = 0, actualSegments_1 = actualSegments; _i < actualSegments_1.length; _i++) {\n\t              var s = actualSegments_1[_i];\n\t              if (s.path === redirectToUrlSegment.path) {\n\t                  actualSegments.splice(idx);\n\t                  return s;\n\t              }\n\t              idx++;\n\t          }\n\t          return redirectToUrlSegment;\n\t      };\n\t      return ApplyRedirects;\n\t  }());\n\t  /**\n\t   * @param {?} injector\n\t   * @param {?} route\n\t   * @return {?}\n\t   */\n\t  function runGuards(injector, route) {\n\t      var /** @type {?} */ canLoad = route.canLoad;\n\t      if (!canLoad || canLoad.length === 0)\n\t          return rxjs_observable_of.of(true);\n\t      var /** @type {?} */ obs = rxjs_operator_map.map.call(rxjs_observable_from.from(canLoad), function (c) {\n\t          var /** @type {?} */ guard = injector.get(c);\n\t          if (guard.canLoad) {\n\t              return wrapIntoObservable(guard.canLoad(route));\n\t          }\n\t          else {\n\t              return wrapIntoObservable(guard(route));\n\t          }\n\t      });\n\t      return andObservables(obs);\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @param {?} route\n\t   * @param {?} segments\n\t   * @return {?}\n\t   */\n\t  function match(segmentGroup, route, segments) {\n\t      var /** @type {?} */ noMatch = { matched: false, consumedSegments: /** @type {?} */ ([]), lastChild: 0, positionalParamSegments: {} };\n\t      if (route.path === '') {\n\t          if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {\n\t              return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n\t          }\n\t          else {\n\t              return { matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n\t          }\n\t      }\n\t      var /** @type {?} */ matcher = route.matcher || defaultUrlMatcher;\n\t      var /** @type {?} */ res = matcher(segments, segmentGroup, route);\n\t      if (!res)\n\t          return noMatch;\n\t      return {\n\t          matched: true,\n\t          consumedSegments: res.consumed,\n\t          lastChild: res.consumed.length,\n\t          positionalParamSegments: res.posParams\n\t      };\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @param {?} consumedSegments\n\t   * @param {?} slicedSegments\n\t   * @param {?} config\n\t   * @return {?}\n\t   */\n\t  function split(segmentGroup, consumedSegments, slicedSegments, config) {\n\t      if (slicedSegments.length > 0 &&\n\t          containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n\t          var /** @type {?} */ s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n\t          return { segmentGroup: mergeTrivialChildren(s), slicedSegments: [] };\n\t      }\n\t      else if (slicedSegments.length === 0 &&\n\t          containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {\n\t          var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n\t          return { segmentGroup: mergeTrivialChildren(s), slicedSegments: slicedSegments };\n\t      }\n\t      else {\n\t          return { segmentGroup: segmentGroup, slicedSegments: slicedSegments };\n\t      }\n\t  }\n\t  /**\n\t   * @param {?} s\n\t   * @return {?}\n\t   */\n\t  function mergeTrivialChildren(s) {\n\t      if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n\t          var /** @type {?} */ c = s.children[PRIMARY_OUTLET];\n\t          return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n\t      }\n\t      else {\n\t          return s;\n\t      }\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @param {?} slicedSegments\n\t   * @param {?} routes\n\t   * @param {?} children\n\t   * @return {?}\n\t   */\n\t  function addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n\t      var /** @type {?} */ res = {};\n\t      for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n\t          var r = routes_1[_i];\n\t          if (emptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {\n\t              res[getOutlet$1(r)] = new UrlSegmentGroup([], {});\n\t          }\n\t      }\n\t      return merge(children, res);\n\t  }\n\t  /**\n\t   * @param {?} routes\n\t   * @param {?} primarySegmentGroup\n\t   * @return {?}\n\t   */\n\t  function createChildrenForEmptySegments(routes, primarySegmentGroup) {\n\t      var /** @type {?} */ res = {};\n\t      res[PRIMARY_OUTLET] = primarySegmentGroup;\n\t      for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {\n\t          var r = routes_2[_i];\n\t          if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {\n\t              res[getOutlet$1(r)] = new UrlSegmentGroup([], {});\n\t          }\n\t      }\n\t      return res;\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @param {?} slicedSegments\n\t   * @param {?} routes\n\t   * @return {?}\n\t   */\n\t  function containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n\t      return routes\n\t          .filter(function (r) { return emptyPathRedirect(segmentGroup, slicedSegments, r) &&\n\t          getOutlet$1(r) !== PRIMARY_OUTLET; })\n\t          .length > 0;\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @param {?} slicedSegments\n\t   * @param {?} routes\n\t   * @return {?}\n\t   */\n\t  function containsEmptyPathRedirects(segmentGroup, slicedSegments, routes) {\n\t      return routes.filter(function (r) { return emptyPathRedirect(segmentGroup, slicedSegments, r); }).length > 0;\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @param {?} slicedSegments\n\t   * @param {?} r\n\t   * @return {?}\n\t   */\n\t  function emptyPathRedirect(segmentGroup, slicedSegments, r) {\n\t      if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full')\n\t          return false;\n\t      return r.path === '' && r.redirectTo !== undefined;\n\t  }\n\t  /**\n\t   * @param {?} route\n\t   * @return {?}\n\t   */\n\t  function getOutlet$1(route) {\n\t      return route.outlet ? route.outlet : PRIMARY_OUTLET;\n\t  }\n\t\n\t  /**\n\t   * @param {?} config\n\t   * @param {?=} parentPath\n\t   * @return {?}\n\t   */\n\t  function validateConfig(config, parentPath) {\n\t      if (parentPath === void 0) { parentPath = ''; }\n\t      // forEach doesn't iterate undefined values\n\t      for (var /** @type {?} */ i = 0; i < config.length; i++) {\n\t          var /** @type {?} */ route = config[i];\n\t          var /** @type {?} */ fullPath = getFullPath(parentPath, route);\n\t          validateNode(route, fullPath);\n\t      }\n\t  }\n\t  /**\n\t   * @param {?} route\n\t   * @param {?} fullPath\n\t   * @return {?}\n\t   */\n\t  function validateNode(route, fullPath) {\n\t      if (!route) {\n\t          throw new Error(\"\\n      Invalid configuration of route '\" + fullPath + \"': Encountered undefined route.\\n      The reason might be an extra comma.\\n       \\n      Example: \\n      const routes: Routes = [\\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\\n        { path: 'detail/:id', component: HeroDetailComponent }\\n      ];\\n    \");\n\t      }\n\t      if (Array.isArray(route)) {\n\t          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': Array cannot be specified\");\n\t      }\n\t      if (!route.component && (route.outlet && route.outlet !== PRIMARY_OUTLET)) {\n\t          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': a componentless route cannot have a named outlet set\");\n\t      }\n\t      if (route.redirectTo && route.children) {\n\t          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': redirectTo and children cannot be used together\");\n\t      }\n\t      if (route.redirectTo && route.loadChildren) {\n\t          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': redirectTo and loadChildren cannot be used together\");\n\t      }\n\t      if (route.children && route.loadChildren) {\n\t          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': children and loadChildren cannot be used together\");\n\t      }\n\t      if (route.redirectTo && route.component) {\n\t          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': redirectTo and component cannot be used together\");\n\t      }\n\t      if (route.path && route.matcher) {\n\t          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': path and matcher cannot be used together\");\n\t      }\n\t      if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {\n\t          throw new Error(\"Invalid configuration of route '\" + fullPath + \"'. One of the following must be provided: component, redirectTo, children or loadChildren\");\n\t      }\n\t      if (route.path === void 0 && route.matcher === void 0) {\n\t          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': routes must have either a path or a matcher specified\");\n\t      }\n\t      if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n\t          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': path cannot start with a slash\");\n\t      }\n\t      if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n\t          var /** @type {?} */ exp = \"The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.\";\n\t          throw new Error(\"Invalid configuration of route '{path: \\\"\" + fullPath + \"\\\", redirectTo: \\\"\" + route.redirectTo + \"\\\"}': please provide 'pathMatch'. \" + exp);\n\t      }\n\t      if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {\n\t          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': pathMatch can only be set to 'prefix' or 'full'\");\n\t      }\n\t      if (route.children) {\n\t          validateConfig(route.children, fullPath);\n\t      }\n\t  }\n\t  /**\n\t   * @param {?} parentPath\n\t   * @param {?} currentRoute\n\t   * @return {?}\n\t   */\n\t  function getFullPath(parentPath, currentRoute) {\n\t      if (!currentRoute) {\n\t          return parentPath;\n\t      }\n\t      if (!parentPath && !currentRoute.path) {\n\t          return '';\n\t      }\n\t      else if (parentPath && !currentRoute.path) {\n\t          return parentPath + \"/\";\n\t      }\n\t      else if (!parentPath && currentRoute.path) {\n\t          return currentRoute.path;\n\t      }\n\t      else {\n\t          return parentPath + \"/\" + currentRoute.path;\n\t      }\n\t  }\n\t\n\t  /**\n\t   * @license undefined\n\t    * Copyright Google Inc. All Rights Reserved.\n\t    * *\n\t    * Use of this source code is governed by an MIT-style license that can be\n\t    * found in the LICENSE file at https://angular.io/license\n\t   */\n\t  var Tree = (function () {\n\t      /**\n\t       * @param {?} root\n\t       */\n\t      function Tree(root) {\n\t          this._root = root;\n\t      }\n\t      Object.defineProperty(Tree.prototype, \"root\", {\n\t          /**\n\t           * @return {?}\n\t           */\n\t          get: function () { return this._root.value; },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      /**\n\t       * @param {?} t\n\t       * @return {?}\n\t       */\n\t      Tree.prototype.parent = function (t) {\n\t          var /** @type {?} */ p = this.pathFromRoot(t);\n\t          return p.length > 1 ? p[p.length - 2] : null;\n\t      };\n\t      /**\n\t       * @param {?} t\n\t       * @return {?}\n\t       */\n\t      Tree.prototype.children = function (t) {\n\t          var /** @type {?} */ n = findNode(t, this._root);\n\t          return n ? n.children.map(function (t) { return t.value; }) : [];\n\t      };\n\t      /**\n\t       * @param {?} t\n\t       * @return {?}\n\t       */\n\t      Tree.prototype.firstChild = function (t) {\n\t          var /** @type {?} */ n = findNode(t, this._root);\n\t          return n && n.children.length > 0 ? n.children[0].value : null;\n\t      };\n\t      /**\n\t       * @param {?} t\n\t       * @return {?}\n\t       */\n\t      Tree.prototype.siblings = function (t) {\n\t          var /** @type {?} */ p = findPath(t, this._root, []);\n\t          if (p.length < 2)\n\t              return [];\n\t          var /** @type {?} */ c = p[p.length - 2].children.map(function (c) { return c.value; });\n\t          return c.filter(function (cc) { return cc !== t; });\n\t      };\n\t      /**\n\t       * @param {?} t\n\t       * @return {?}\n\t       */\n\t      Tree.prototype.pathFromRoot = function (t) { return findPath(t, this._root, []).map(function (s) { return s.value; }); };\n\t      return Tree;\n\t  }());\n\t  /**\n\t   * @param {?} expected\n\t   * @param {?} c\n\t   * @return {?}\n\t   */\n\t  function findNode(expected, c) {\n\t      if (expected === c.value)\n\t          return c;\n\t      for (var _i = 0, _a = c.children; _i < _a.length; _i++) {\n\t          var cc = _a[_i];\n\t          var /** @type {?} */ r = findNode(expected, cc);\n\t          if (r)\n\t              return r;\n\t      }\n\t      return null;\n\t  }\n\t  /**\n\t   * @param {?} expected\n\t   * @param {?} c\n\t   * @param {?} collected\n\t   * @return {?}\n\t   */\n\t  function findPath(expected, c, collected) {\n\t      collected.push(c);\n\t      if (expected === c.value)\n\t          return collected;\n\t      for (var _i = 0, _a = c.children; _i < _a.length; _i++) {\n\t          var cc = _a[_i];\n\t          var /** @type {?} */ cloned = collected.slice(0);\n\t          var /** @type {?} */ r = findPath(expected, cc, cloned);\n\t          if (r.length > 0)\n\t              return r;\n\t      }\n\t      return [];\n\t  }\n\t  var TreeNode = (function () {\n\t      /**\n\t       * @param {?} value\n\t       * @param {?} children\n\t       */\n\t      function TreeNode(value, children) {\n\t          this.value = value;\n\t          this.children = children;\n\t      }\n\t      /**\n\t       * @return {?}\n\t       */\n\t      TreeNode.prototype.toString = function () { return \"TreeNode(\" + this.value + \")\"; };\n\t      return TreeNode;\n\t  }());\n\t\n\t  /**\n\t   * @license\n\t   * Copyright Google Inc. All Rights Reserved.\n\t   *\n\t   * Use of this source code is governed by an MIT-style license that can be\n\t   * found in the LICENSE file at https://angular.io/license\n\t   */\n\t  var __extends$1 = (this && this.__extends) || function (d, b) {\n\t      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t      function __() { this.constructor = d; }\n\t      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t  };\n\t  /**\n\t   *  *\n\t    * *\n\t    * ```\n\t    * class MyComponent {\n\t    * constructor(router: Router) {\n\t    * const state: RouterState = router.routerState;\n\t    * const root: ActivatedRoute = state.root;\n\t    * const child = root.firstChild;\n\t    * const id: Observable<string> = child.params.map(p => p.id);\n\t    * //...\n\t    * }\n\t    * }\n\t    * ```\n\t    * *\n\t    * RouterState is a tree of activated routes. Every node in this tree knows about the \"consumed\" URL\n\t    * segments,\n\t    * the extracted parameters, and the resolved data.\n\t    * *\n\t    * See {@link ActivatedRoute} for more information.\n\t    * *\n\t   */\n\t  var RouterState = (function (_super) {\n\t      __extends$1(RouterState, _super);\n\t      /**\n\t       * @param {?} root\n\t       * @param {?} snapshot\n\t       */\n\t      function RouterState(root, snapshot) {\n\t          _super.call(this, root);\n\t          this.snapshot = snapshot;\n\t          setRouterStateSnapshot(this, root);\n\t      }\n\t      /**\n\t       * @return {?}\n\t       */\n\t      RouterState.prototype.toString = function () { return this.snapshot.toString(); };\n\t      return RouterState;\n\t  }(Tree));\n\t  /**\n\t   * @param {?} urlTree\n\t   * @param {?} rootComponent\n\t   * @return {?}\n\t   */\n\t  function createEmptyState(urlTree, rootComponent) {\n\t      var /** @type {?} */ snapshot = createEmptyStateSnapshot(urlTree, rootComponent);\n\t      var /** @type {?} */ emptyUrl = new rxjs_BehaviorSubject.BehaviorSubject([new UrlSegment('', {})]);\n\t      var /** @type {?} */ emptyParams = new rxjs_BehaviorSubject.BehaviorSubject({});\n\t      var /** @type {?} */ emptyData = new rxjs_BehaviorSubject.BehaviorSubject({});\n\t      var /** @type {?} */ emptyQueryParams = new rxjs_BehaviorSubject.BehaviorSubject({});\n\t      var /** @type {?} */ fragment = new rxjs_BehaviorSubject.BehaviorSubject('');\n\t      var /** @type {?} */ activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n\t      activated.snapshot = snapshot.root;\n\t      return new RouterState(new TreeNode(activated, []), snapshot);\n\t  }\n\t  /**\n\t   * @param {?} urlTree\n\t   * @param {?} rootComponent\n\t   * @return {?}\n\t   */\n\t  function createEmptyStateSnapshot(urlTree, rootComponent) {\n\t      var /** @type {?} */ emptyParams = {};\n\t      var /** @type {?} */ emptyData = {};\n\t      var /** @type {?} */ emptyQueryParams = {};\n\t      var /** @type {?} */ fragment = '';\n\t      var /** @type {?} */ activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});\n\t      return new RouterStateSnapshot('', new TreeNode(activated, []));\n\t  }\n\t  /**\n\t   *  outlet.\n\t    * An `ActivatedRoute` can also be used to traverse the router state tree.\n\t    * *\n\t    * *\n\t    * ```\n\t    * class MyComponent {\n\t    * constructor(route: ActivatedRoute) {\n\t    * const id: Observable<string> = route.params.map(p => p.id);\n\t    * const url: Observable<string> = route.url.map(segments => segments.join(''));\n\t    * // route.data includes both `data` and `resolve`\n\t    * const user = route.data.map(d => d.user);\n\t    * }\n\t    * }\n\t    * ```\n\t    * *\n\t   */\n\t  var ActivatedRoute = (function () {\n\t      /**\n\t       * @param {?} url\n\t       * @param {?} params\n\t       * @param {?} queryParams\n\t       * @param {?} fragment\n\t       * @param {?} data\n\t       * @param {?} outlet\n\t       * @param {?} component\n\t       * @param {?} futureSnapshot\n\t       */\n\t      function ActivatedRoute(url, params, queryParams, fragment, data, outlet, component, futureSnapshot) {\n\t          this.url = url;\n\t          this.params = params;\n\t          this.queryParams = queryParams;\n\t          this.fragment = fragment;\n\t          this.data = data;\n\t          this.outlet = outlet;\n\t          this.component = component;\n\t          this._futureSnapshot = futureSnapshot;\n\t      }\n\t      Object.defineProperty(ActivatedRoute.prototype, \"routeConfig\", {\n\t          /**\n\t           *  The configuration used to match this route\n\t           * @return {?}\n\t           */\n\t          get: function () { return this._futureSnapshot.routeConfig; },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      Object.defineProperty(ActivatedRoute.prototype, \"root\", {\n\t          /**\n\t           *  The root of the router state\n\t           * @return {?}\n\t           */\n\t          get: function () { return this._routerState.root; },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      Object.defineProperty(ActivatedRoute.prototype, \"parent\", {\n\t          /**\n\t           *  The parent of this route in the router state tree\n\t           * @return {?}\n\t           */\n\t          get: function () { return this._routerState.parent(this); },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      Object.defineProperty(ActivatedRoute.prototype, \"firstChild\", {\n\t          /**\n\t           *  The first child of this route in the router state tree\n\t           * @return {?}\n\t           */\n\t          get: function () { return this._routerState.firstChild(this); },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      Object.defineProperty(ActivatedRoute.prototype, \"children\", {\n\t          /**\n\t           *  The children of this route in the router state tree\n\t           * @return {?}\n\t           */\n\t          get: function () { return this._routerState.children(this); },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      Object.defineProperty(ActivatedRoute.prototype, \"pathFromRoot\", {\n\t          /**\n\t           *  The path from the root of the router state tree to this route\n\t           * @return {?}\n\t           */\n\t          get: function () { return this._routerState.pathFromRoot(this); },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      /**\n\t       * @return {?}\n\t       */\n\t      ActivatedRoute.prototype.toString = function () {\n\t          return this.snapshot ? this.snapshot.toString() : \"Future(\" + this._futureSnapshot + \")\";\n\t      };\n\t      return ActivatedRoute;\n\t  }());\n\t  /**\n\t   * @param {?} route\n\t   * @return {?}\n\t   */\n\t  function inheritedParamsDataResolve(route) {\n\t      var /** @type {?} */ pathToRoot = route.pathFromRoot;\n\t      var /** @type {?} */ inhertingStartingFrom = pathToRoot.length - 1;\n\t      while (inhertingStartingFrom >= 1) {\n\t          var /** @type {?} */ current = pathToRoot[inhertingStartingFrom];\n\t          var /** @type {?} */ parent_1 = pathToRoot[inhertingStartingFrom - 1];\n\t          // current route is an empty path => inherits its parent's params and data\n\t          if (current.routeConfig && current.routeConfig.path === '') {\n\t              inhertingStartingFrom--;\n\t          }\n\t          else if (!parent_1.component) {\n\t              inhertingStartingFrom--;\n\t          }\n\t          else {\n\t              break;\n\t          }\n\t      }\n\t      return pathToRoot.slice(inhertingStartingFrom).reduce(function (res, curr) {\n\t          var /** @type {?} */ params = merge(res.params, curr.params);\n\t          var /** @type {?} */ data = merge(res.data, curr.data);\n\t          var /** @type {?} */ resolve = merge(res.resolve, curr._resolvedData);\n\t          return { params: params, data: data, resolve: resolve };\n\t      }, /** @type {?} */ ({ params: {}, data: {}, resolve: {} }));\n\t  }\n\t  /**\n\t   *  outlet\n\t    * at a particular moment in time. ActivatedRouteSnapshot can also be used to traverse the router\n\t    * state tree.\n\t    * *\n\t    * *\n\t    * ```\n\t    * class MyComponent {\n\t    * constructor(route: ActivatedRoute) {\n\t    * const id: string = route.snapshot.params.id;\n\t    * const url: string = route.snapshot.url.join('');\n\t    * const user = route.snapshot.data.user;\n\t    * }\n\t    * }\n\t    * ```\n\t    * *\n\t   */\n\t  var ActivatedRouteSnapshot = (function () {\n\t      /**\n\t       * @param {?} url\n\t       * @param {?} params\n\t       * @param {?} queryParams\n\t       * @param {?} fragment\n\t       * @param {?} data\n\t       * @param {?} outlet\n\t       * @param {?} component\n\t       * @param {?} routeConfig\n\t       * @param {?} urlSegment\n\t       * @param {?} lastPathIndex\n\t       * @param {?} resolve\n\t       */\n\t      function ActivatedRouteSnapshot(url, params, queryParams, fragment, data, outlet, component, routeConfig, urlSegment, lastPathIndex, resolve) {\n\t          this.url = url;\n\t          this.params = params;\n\t          this.queryParams = queryParams;\n\t          this.fragment = fragment;\n\t          this.data = data;\n\t          this.outlet = outlet;\n\t          this.component = component;\n\t          this._routeConfig = routeConfig;\n\t          this._urlSegment = urlSegment;\n\t          this._lastPathIndex = lastPathIndex;\n\t          this._resolve = resolve;\n\t      }\n\t      Object.defineProperty(ActivatedRouteSnapshot.prototype, \"routeConfig\", {\n\t          /**\n\t           *  The configuration used to match this route\n\t           * @return {?}\n\t           */\n\t          get: function () { return this._routeConfig; },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      Object.defineProperty(ActivatedRouteSnapshot.prototype, \"root\", {\n\t          /**\n\t           *  The root of the router state\n\t           * @return {?}\n\t           */\n\t          get: function () { return this._routerState.root; },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      Object.defineProperty(ActivatedRouteSnapshot.prototype, \"parent\", {\n\t          /**\n\t           *  The parent of this route in the router state tree\n\t           * @return {?}\n\t           */\n\t          get: function () { return this._routerState.parent(this); },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      Object.defineProperty(ActivatedRouteSnapshot.prototype, \"firstChild\", {\n\t          /**\n\t           *  The first child of this route in the router state tree\n\t           * @return {?}\n\t           */\n\t          get: function () { return this._routerState.firstChild(this); },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      Object.defineProperty(ActivatedRouteSnapshot.prototype, \"children\", {\n\t          /**\n\t           *  The children of this route in the router state tree\n\t           * @return {?}\n\t           */\n\t          get: function () { return this._routerState.children(this); },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      Object.defineProperty(ActivatedRouteSnapshot.prototype, \"pathFromRoot\", {\n\t          /**\n\t           *  The path from the root of the router state tree to this route\n\t           * @return {?}\n\t           */\n\t          get: function () { return this._routerState.pathFromRoot(this); },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      /**\n\t       * @return {?}\n\t       */\n\t      ActivatedRouteSnapshot.prototype.toString = function () {\n\t          var /** @type {?} */ url = this.url.map(function (segment) { return segment.toString(); }).join('/');\n\t          var /** @type {?} */ matched = this._routeConfig ? this._routeConfig.path : '';\n\t          return \"Route(url:'\" + url + \"', path:'\" + matched + \"')\";\n\t      };\n\t      return ActivatedRouteSnapshot;\n\t  }());\n\t  /**\n\t   *  *\n\t    * *\n\t    * ```\n\t    * class MyComponent {\n\t    * constructor(router: Router) {\n\t    * const state: RouterState = router.routerState;\n\t    * const snapshot: RouterStateSnapshot = state.snapshot;\n\t    * const root: ActivatedRouteSnapshot = snapshot.root;\n\t    * const child = root.firstChild;\n\t    * const id: Observable<string> = child.params.map(p => p.id);\n\t    * //...\n\t    * }\n\t    * }\n\t    * ```\n\t    * *\n\t    * RouterStateSnapshot is a tree of activated route snapshots. Every node in this tree knows about\n\t    * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n\t    * *\n\t   */\n\t  var RouterStateSnapshot = (function (_super) {\n\t      __extends$1(RouterStateSnapshot, _super);\n\t      /**\n\t       * @param {?} url\n\t       * @param {?} root\n\t       */\n\t      function RouterStateSnapshot(url, root) {\n\t          _super.call(this, root);\n\t          this.url = url;\n\t          setRouterStateSnapshot(this, root);\n\t      }\n\t      /**\n\t       * @return {?}\n\t       */\n\t      RouterStateSnapshot.prototype.toString = function () { return serializeNode(this._root); };\n\t      return RouterStateSnapshot;\n\t  }(Tree));\n\t  /**\n\t   * @param {?} state\n\t   * @param {?} node\n\t   * @return {?}\n\t   */\n\t  function setRouterStateSnapshot(state, node) {\n\t      node.value._routerState = state;\n\t      node.children.forEach(function (c) { return setRouterStateSnapshot(state, c); });\n\t  }\n\t  /**\n\t   * @param {?} node\n\t   * @return {?}\n\t   */\n\t  function serializeNode(node) {\n\t      var /** @type {?} */ c = node.children.length > 0 ? \" { \" + node.children.map(serializeNode).join(\", \") + \" } \" : '';\n\t      return \"\" + node.value + c;\n\t  }\n\t  /**\n\t   *  The expectation is that the activate route is created with the right set of parameters.\n\t    * So we push new values into the observables only when they are not the initial values.\n\t    * And we detect that by checking if the snapshot field is set.\n\t   * @param {?} route\n\t   * @return {?}\n\t   */\n\t  function advanceActivatedRoute(route) {\n\t      if (route.snapshot) {\n\t          if (!shallowEqual(route.snapshot.queryParams, route._futureSnapshot.queryParams)) {\n\t              ((route.queryParams)).next(route._futureSnapshot.queryParams);\n\t          }\n\t          if (route.snapshot.fragment !== route._futureSnapshot.fragment) {\n\t              ((route.fragment)).next(route._futureSnapshot.fragment);\n\t          }\n\t          if (!shallowEqual(route.snapshot.params, route._futureSnapshot.params)) {\n\t              ((route.params)).next(route._futureSnapshot.params);\n\t          }\n\t          if (!shallowEqualArrays(route.snapshot.url, route._futureSnapshot.url)) {\n\t              ((route.url)).next(route._futureSnapshot.url);\n\t          }\n\t          if (!equalParamsAndUrlSegments(route.snapshot, route._futureSnapshot)) {\n\t              ((route.data)).next(route._futureSnapshot.data);\n\t          }\n\t          route.snapshot = route._futureSnapshot;\n\t      }\n\t      else {\n\t          route.snapshot = route._futureSnapshot;\n\t          // this is for resolved data\n\t          ((route.data)).next(route._futureSnapshot.data);\n\t      }\n\t  }\n\t  /**\n\t   * @param {?} a\n\t   * @param {?} b\n\t   * @return {?}\n\t   */\n\t  function equalParamsAndUrlSegments(a, b) {\n\t      return shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n\t  }\n\t\n\t  /**\n\t   * @param {?} routeReuseStrategy\n\t   * @param {?} curr\n\t   * @param {?} prevState\n\t   * @return {?}\n\t   */\n\t  function createRouterState(routeReuseStrategy, curr, prevState) {\n\t      var /** @type {?} */ root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n\t      return new RouterState(root, curr);\n\t  }\n\t  /**\n\t   * @param {?} routeReuseStrategy\n\t   * @param {?} curr\n\t   * @param {?=} prevState\n\t   * @return {?}\n\t   */\n\t  function createNode(routeReuseStrategy, curr, prevState) {\n\t      // reuse an activated route that is currently displayed on the screen\n\t      if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n\t          var /** @type {?} */ value = prevState.value;\n\t          value._futureSnapshot = curr.value;\n\t          var /** @type {?} */ children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n\t          return new TreeNode(value, children);\n\t      }\n\t      else if (routeReuseStrategy.retrieve(curr.value)) {\n\t          var /** @type {?} */ tree = ((routeReuseStrategy.retrieve(curr.value))).route;\n\t          setFutureSnapshotsOfActivatedRoutes(curr, tree);\n\t          return tree;\n\t      }\n\t      else {\n\t          var /** @type {?} */ value = createActivatedRoute(curr.value);\n\t          var /** @type {?} */ children = curr.children.map(function (c) { return createNode(routeReuseStrategy, c); });\n\t          return new TreeNode(value, children);\n\t      }\n\t  }\n\t  /**\n\t   * @param {?} curr\n\t   * @param {?} result\n\t   * @return {?}\n\t   */\n\t  function setFutureSnapshotsOfActivatedRoutes(curr, result) {\n\t      if (curr.value.routeConfig !== result.value.routeConfig) {\n\t          throw new Error('Cannot reattach ActivatedRouteSnapshot created from a different route');\n\t      }\n\t      if (curr.children.length !== result.children.length) {\n\t          throw new Error('Cannot reattach ActivatedRouteSnapshot with a different number of children');\n\t      }\n\t      result.value._futureSnapshot = curr.value;\n\t      for (var /** @type {?} */ i = 0; i < curr.children.length; ++i) {\n\t          setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);\n\t      }\n\t  }\n\t  /**\n\t   * @param {?} routeReuseStrategy\n\t   * @param {?} curr\n\t   * @param {?} prevState\n\t   * @return {?}\n\t   */\n\t  function createOrReuseChildren(routeReuseStrategy, curr, prevState) {\n\t      return curr.children.map(function (child) {\n\t          for (var _i = 0, _a = prevState.children; _i < _a.length; _i++) {\n\t              var p = _a[_i];\n\t              if (routeReuseStrategy.shouldReuseRoute(p.value.snapshot, child.value)) {\n\t                  return createNode(routeReuseStrategy, child, p);\n\t              }\n\t          }\n\t          return createNode(routeReuseStrategy, child);\n\t      });\n\t  }\n\t  /**\n\t   * @param {?} c\n\t   * @return {?}\n\t   */\n\t  function createActivatedRoute(c) {\n\t      return new ActivatedRoute(new rxjs_BehaviorSubject.BehaviorSubject(c.url), new rxjs_BehaviorSubject.BehaviorSubject(c.params), new rxjs_BehaviorSubject.BehaviorSubject(c.queryParams), new rxjs_BehaviorSubject.BehaviorSubject(c.fragment), new rxjs_BehaviorSubject.BehaviorSubject(c.data), c.outlet, c.component, c);\n\t  }\n\t\n\t  /**\n\t   * @param {?} route\n\t   * @param {?} urlTree\n\t   * @param {?} commands\n\t   * @param {?} queryParams\n\t   * @param {?} fragment\n\t   * @return {?}\n\t   */\n\t  function createUrlTree(route, urlTree, commands, queryParams, fragment) {\n\t      if (commands.length === 0) {\n\t          return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);\n\t      }\n\t      var /** @type {?} */ nav = computeNavigation(commands);\n\t      if (nav.toRoot()) {\n\t          return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);\n\t      }\n\t      var /** @type {?} */ startingPosition = findStartingPosition(nav, urlTree, route);\n\t      var /** @type {?} */ segmentGroup = startingPosition.processChildren ?\n\t          updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) :\n\t          updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);\n\t      return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);\n\t  }\n\t  /**\n\t   * @param {?} command\n\t   * @return {?}\n\t   */\n\t  function isMatrixParams(command) {\n\t      return typeof command === 'object' && !command.outlets && !command.segmentPath;\n\t  }\n\t  /**\n\t   * @param {?} oldSegmentGroup\n\t   * @param {?} newSegmentGroup\n\t   * @param {?} urlTree\n\t   * @param {?} queryParams\n\t   * @param {?} fragment\n\t   * @return {?}\n\t   */\n\t  function tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {\n\t      if (urlTree.root === oldSegmentGroup) {\n\t          return new UrlTree(newSegmentGroup, stringify(queryParams), fragment);\n\t      }\n\t      return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), stringify(queryParams), fragment);\n\t  }\n\t  /**\n\t   * @param {?} current\n\t   * @param {?} oldSegment\n\t   * @param {?} newSegment\n\t   * @return {?}\n\t   */\n\t  function replaceSegment(current, oldSegment, newSegment) {\n\t      var /** @type {?} */ children = {};\n\t      forEach(current.children, function (c, outletName) {\n\t          if (c === oldSegment) {\n\t              children[outletName] = newSegment;\n\t          }\n\t          else {\n\t              children[outletName] = replaceSegment(c, oldSegment, newSegment);\n\t          }\n\t      });\n\t      return new UrlSegmentGroup(current.segments, children);\n\t  }\n\t  var Navigation = (function () {\n\t      /**\n\t       * @param {?} isAbsolute\n\t       * @param {?} numberOfDoubleDots\n\t       * @param {?} commands\n\t       */\n\t      function Navigation(isAbsolute, numberOfDoubleDots, commands) {\n\t          this.isAbsolute = isAbsolute;\n\t          this.numberOfDoubleDots = numberOfDoubleDots;\n\t          this.commands = commands;\n\t          if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n\t              throw new Error('Root segment cannot have matrix parameters');\n\t          }\n\t          var cmdWithOutlet = commands.find(function (c) { return typeof c === 'object' && c.outlets; });\n\t          if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\n\t              throw new Error('{outlets:{}} has to be the last command');\n\t          }\n\t      }\n\t      /**\n\t       * @return {?}\n\t       */\n\t      Navigation.prototype.toRoot = function () {\n\t          return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n\t      };\n\t      return Navigation;\n\t  }());\n\t  /**\n\t   *  Transforms commands to a normalized `Navigation`\n\t   * @param {?} commands\n\t   * @return {?}\n\t   */\n\t  function computeNavigation(commands) {\n\t      if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] === '/') {\n\t          return new Navigation(true, 0, commands);\n\t      }\n\t      var /** @type {?} */ numberOfDoubleDots = 0;\n\t      var /** @type {?} */ isAbsolute = false;\n\t      var /** @type {?} */ res = commands.reduce(function (res, cmd, cmdIdx) {\n\t          if (typeof cmd === 'object') {\n\t              if (cmd.outlets) {\n\t                  var /** @type {?} */ outlets_1 = {};\n\t                  forEach(cmd.outlets, function (commands, name) {\n\t                      outlets_1[name] = typeof commands === 'string' ? commands.split('/') : commands;\n\t                  });\n\t                  return res.concat([{ outlets: outlets_1 }]);\n\t              }\n\t              if (cmd.segmentPath) {\n\t                  return res.concat([cmd.segmentPath]);\n\t              }\n\t          }\n\t          if (!(typeof cmd === 'string')) {\n\t              return res.concat([cmd]);\n\t          }\n\t          if (cmdIdx === 0) {\n\t              cmd.split('/').forEach(function (urlPart, partIndex) {\n\t                  if (partIndex == 0 && urlPart === '.') {\n\t                  }\n\t                  else if (partIndex == 0 && urlPart === '') {\n\t                      isAbsolute = true;\n\t                  }\n\t                  else if (urlPart === '..') {\n\t                      numberOfDoubleDots++;\n\t                  }\n\t                  else if (urlPart != '') {\n\t                      res.push(urlPart);\n\t                  }\n\t              });\n\t              return res;\n\t          }\n\t          return res.concat([cmd]);\n\t      }, []);\n\t      return new Navigation(isAbsolute, numberOfDoubleDots, res);\n\t  }\n\t  var Position = (function () {\n\t      /**\n\t       * @param {?} segmentGroup\n\t       * @param {?} processChildren\n\t       * @param {?} index\n\t       */\n\t      function Position(segmentGroup, processChildren, index) {\n\t          this.segmentGroup = segmentGroup;\n\t          this.processChildren = processChildren;\n\t          this.index = index;\n\t      }\n\t      return Position;\n\t  }());\n\t  /**\n\t   * @param {?} nav\n\t   * @param {?} tree\n\t   * @param {?} route\n\t   * @return {?}\n\t   */\n\t  function findStartingPosition(nav, tree, route) {\n\t      if (nav.isAbsolute) {\n\t          return new Position(tree.root, true, 0);\n\t      }\n\t      if (route.snapshot._lastPathIndex === -1) {\n\t          return new Position(route.snapshot._urlSegment, true, 0);\n\t      }\n\t      var /** @type {?} */ modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n\t      var /** @type {?} */ index = route.snapshot._lastPathIndex + modifier;\n\t      return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, nav.numberOfDoubleDots);\n\t  }\n\t  /**\n\t   * @param {?} group\n\t   * @param {?} index\n\t   * @param {?} numberOfDoubleDots\n\t   * @return {?}\n\t   */\n\t  function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n\t      var /** @type {?} */ g = group;\n\t      var /** @type {?} */ ci = index;\n\t      var /** @type {?} */ dd = numberOfDoubleDots;\n\t      while (dd > ci) {\n\t          dd -= ci;\n\t          g = g.parent;\n\t          if (!g) {\n\t              throw new Error('Invalid number of \\'../\\'');\n\t          }\n\t          ci = g.segments.length;\n\t      }\n\t      return new Position(g, false, ci - dd);\n\t  }\n\t  /**\n\t   * @param {?} command\n\t   * @return {?}\n\t   */\n\t  function getPath(command) {\n\t      if (typeof command === 'object' && command.outlets)\n\t          return command.outlets[PRIMARY_OUTLET];\n\t      return \"\" + command;\n\t  }\n\t  /**\n\t   * @param {?} commands\n\t   * @return {?}\n\t   */\n\t  function getOutlets(commands) {\n\t      if (!(typeof commands[0] === 'object'))\n\t          return (_a = {}, _a[PRIMARY_OUTLET] = commands, _a);\n\t      if (commands[0].outlets === undefined)\n\t          return (_b = {}, _b[PRIMARY_OUTLET] = commands, _b);\n\t      return commands[0].outlets;\n\t      var _a, _b;\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @param {?} startIndex\n\t   * @param {?} commands\n\t   * @return {?}\n\t   */\n\t  function updateSegmentGroup(segmentGroup, startIndex, commands) {\n\t      if (!segmentGroup) {\n\t          segmentGroup = new UrlSegmentGroup([], {});\n\t      }\n\t      if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n\t          return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n\t      }\n\t      var /** @type {?} */ m = prefixedWith(segmentGroup, startIndex, commands);\n\t      var /** @type {?} */ slicedCommands = commands.slice(m.commandIndex);\n\t      if (m.match && m.pathIndex < segmentGroup.segments.length) {\n\t          var /** @type {?} */ g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n\t          g.children[PRIMARY_OUTLET] =\n\t              new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n\t          return updateSegmentGroupChildren(g, 0, slicedCommands);\n\t      }\n\t      else if (m.match && slicedCommands.length === 0) {\n\t          return new UrlSegmentGroup(segmentGroup.segments, {});\n\t      }\n\t      else if (m.match && !segmentGroup.hasChildren()) {\n\t          return createNewSegmentGroup(segmentGroup, startIndex, commands);\n\t      }\n\t      else if (m.match) {\n\t          return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n\t      }\n\t      else {\n\t          return createNewSegmentGroup(segmentGroup, startIndex, commands);\n\t      }\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @param {?} startIndex\n\t   * @param {?} commands\n\t   * @return {?}\n\t   */\n\t  function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n\t      if (commands.length === 0) {\n\t          return new UrlSegmentGroup(segmentGroup.segments, {});\n\t      }\n\t      else {\n\t          var /** @type {?} */ outlets_2 = getOutlets(commands);\n\t          var /** @type {?} */ children_1 = {};\n\t          forEach(outlets_2, function (commands, outlet) {\n\t              if (commands !== null) {\n\t                  children_1[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n\t              }\n\t          });\n\t          forEach(segmentGroup.children, function (child, childOutlet) {\n\t              if (outlets_2[childOutlet] === undefined) {\n\t                  children_1[childOutlet] = child;\n\t              }\n\t          });\n\t          return new UrlSegmentGroup(segmentGroup.segments, children_1);\n\t      }\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @param {?} startIndex\n\t   * @param {?} commands\n\t   * @return {?}\n\t   */\n\t  function prefixedWith(segmentGroup, startIndex, commands) {\n\t      var /** @type {?} */ currentCommandIndex = 0;\n\t      var /** @type {?} */ currentPathIndex = startIndex;\n\t      var /** @type {?} */ noMatch = { match: false, pathIndex: 0, commandIndex: 0 };\n\t      while (currentPathIndex < segmentGroup.segments.length) {\n\t          if (currentCommandIndex >= commands.length)\n\t              return noMatch;\n\t          var /** @type {?} */ path = segmentGroup.segments[currentPathIndex];\n\t          var /** @type {?} */ curr = getPath(commands[currentCommandIndex]);\n\t          var /** @type {?} */ next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n\t          if (currentPathIndex > 0 && curr === undefined)\n\t              break;\n\t          if (curr && next && (typeof next === 'object') && next.outlets === undefined) {\n\t              if (!compare(curr, next, path))\n\t                  return noMatch;\n\t              currentCommandIndex += 2;\n\t          }\n\t          else {\n\t              if (!compare(curr, {}, path))\n\t                  return noMatch;\n\t              currentCommandIndex++;\n\t          }\n\t          currentPathIndex++;\n\t      }\n\t      return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @param {?} startIndex\n\t   * @param {?} commands\n\t   * @return {?}\n\t   */\n\t  function createNewSegmentGroup(segmentGroup, startIndex, commands) {\n\t      var /** @type {?} */ paths = segmentGroup.segments.slice(0, startIndex);\n\t      var /** @type {?} */ i = 0;\n\t      while (i < commands.length) {\n\t          if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {\n\t              var /** @type {?} */ children = createNewSegmentChildren(commands[i].outlets);\n\t              return new UrlSegmentGroup(paths, children);\n\t          }\n\t          // if we start with an object literal, we need to reuse the path part from the segment\n\t          if (i === 0 && isMatrixParams(commands[0])) {\n\t              var /** @type {?} */ p = segmentGroup.segments[startIndex];\n\t              paths.push(new UrlSegment(p.path, commands[0]));\n\t              i++;\n\t              continue;\n\t          }\n\t          var /** @type {?} */ curr = getPath(commands[i]);\n\t          var /** @type {?} */ next = (i < commands.length - 1) ? commands[i + 1] : null;\n\t          if (curr && next && isMatrixParams(next)) {\n\t              paths.push(new UrlSegment(curr, stringify(next)));\n\t              i += 2;\n\t          }\n\t          else {\n\t              paths.push(new UrlSegment(curr, {}));\n\t              i++;\n\t          }\n\t      }\n\t      return new UrlSegmentGroup(paths, {});\n\t  }\n\t  /**\n\t   * @param {?} outlets\n\t   * @return {?}\n\t   */\n\t  function createNewSegmentChildren(outlets) {\n\t      var /** @type {?} */ children = {};\n\t      forEach(outlets, function (commands, outlet) {\n\t          if (commands !== null) {\n\t              children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n\t          }\n\t      });\n\t      return children;\n\t  }\n\t  /**\n\t   * @param {?} params\n\t   * @return {?}\n\t   */\n\t  function stringify(params) {\n\t      var /** @type {?} */ res = {};\n\t      forEach(params, function (v, k) { return res[k] = \"\" + v; });\n\t      return res;\n\t  }\n\t  /**\n\t   * @param {?} path\n\t   * @param {?} params\n\t   * @param {?} segment\n\t   * @return {?}\n\t   */\n\t  function compare(path, params, segment) {\n\t      return path == segment.path && shallowEqual(params, segment.parameters);\n\t  }\n\t\n\t  var NoMatch$1 = (function () {\n\t      function NoMatch() {\n\t      }\n\t      return NoMatch;\n\t  }());\n\t  /**\n\t   * @param {?} rootComponentType\n\t   * @param {?} config\n\t   * @param {?} urlTree\n\t   * @param {?} url\n\t   * @return {?}\n\t   */\n\t  function recognize(rootComponentType, config, urlTree, url) {\n\t      return new Recognizer(rootComponentType, config, urlTree, url).recognize();\n\t  }\n\t  var Recognizer = (function () {\n\t      /**\n\t       * @param {?} rootComponentType\n\t       * @param {?} config\n\t       * @param {?} urlTree\n\t       * @param {?} url\n\t       */\n\t      function Recognizer(rootComponentType, config, urlTree, url) {\n\t          this.rootComponentType = rootComponentType;\n\t          this.config = config;\n\t          this.urlTree = urlTree;\n\t          this.url = url;\n\t      }\n\t      /**\n\t       * @return {?}\n\t       */\n\t      Recognizer.prototype.recognize = function () {\n\t          try {\n\t              var /** @type {?} */ rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config).segmentGroup;\n\t              var /** @type {?} */ children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);\n\t              var /** @type {?} */ root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});\n\t              var /** @type {?} */ rootNode = new TreeNode(root, children);\n\t              var /** @type {?} */ routeState = new RouterStateSnapshot(this.url, rootNode);\n\t              this.inheriteParamsAndData(routeState._root);\n\t              return rxjs_observable_of.of(routeState);\n\t          }\n\t          catch (e) {\n\t              return new rxjs_Observable.Observable(function (obs) { return obs.error(e); });\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} routeNode\n\t       * @return {?}\n\t       */\n\t      Recognizer.prototype.inheriteParamsAndData = function (routeNode) {\n\t          var _this = this;\n\t          var /** @type {?} */ route = routeNode.value;\n\t          var /** @type {?} */ i = inheritedParamsDataResolve(route);\n\t          route.params = Object.freeze(i.params);\n\t          route.data = Object.freeze(i.data);\n\t          routeNode.children.forEach(function (n) { return _this.inheriteParamsAndData(n); });\n\t      };\n\t      /**\n\t       * @param {?} config\n\t       * @param {?} segmentGroup\n\t       * @param {?} outlet\n\t       * @return {?}\n\t       */\n\t      Recognizer.prototype.processSegmentGroup = function (config, segmentGroup, outlet) {\n\t          if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n\t              return this.processChildren(config, segmentGroup);\n\t          }\n\t          else {\n\t              return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} config\n\t       * @param {?} segmentGroup\n\t       * @return {?}\n\t       */\n\t      Recognizer.prototype.processChildren = function (config, segmentGroup) {\n\t          var _this = this;\n\t          var /** @type {?} */ children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) { return _this.processSegmentGroup(config, child, childOutlet); });\n\t          checkOutletNameUniqueness(children);\n\t          sortActivatedRouteSnapshots(children);\n\t          return children;\n\t      };\n\t      /**\n\t       * @param {?} config\n\t       * @param {?} segmentGroup\n\t       * @param {?} segments\n\t       * @param {?} outlet\n\t       * @return {?}\n\t       */\n\t      Recognizer.prototype.processSegment = function (config, segmentGroup, segments, outlet) {\n\t          for (var _i = 0, config_1 = config; _i < config_1.length; _i++) {\n\t              var r = config_1[_i];\n\t              try {\n\t                  return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);\n\t              }\n\t              catch (e) {\n\t                  if (!(e instanceof NoMatch$1))\n\t                      throw e;\n\t              }\n\t          }\n\t          if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n\t              return [];\n\t          }\n\t          else {\n\t              throw new NoMatch$1();\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} segmentGroup\n\t       * @param {?} segments\n\t       * @param {?} outlet\n\t       * @return {?}\n\t       */\n\t      Recognizer.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {\n\t          return segments.length === 0 && !segmentGroup.children[outlet];\n\t      };\n\t      /**\n\t       * @param {?} route\n\t       * @param {?} rawSegment\n\t       * @param {?} segments\n\t       * @param {?} outlet\n\t       * @return {?}\n\t       */\n\t      Recognizer.prototype.processSegmentAgainstRoute = function (route, rawSegment, segments, outlet) {\n\t          if (route.redirectTo)\n\t              throw new NoMatch$1();\n\t          if ((route.outlet ? route.outlet : PRIMARY_OUTLET) !== outlet)\n\t              throw new NoMatch$1();\n\t          if (route.path === '**') {\n\t              var /** @type {?} */ params = segments.length > 0 ? last(segments).parameters : {};\n\t              var /** @type {?} */ snapshot_1 = new ActivatedRouteSnapshot(segments, params, Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));\n\t              return [new TreeNode(snapshot_1, [])];\n\t          }\n\t          var _a = match$1(rawSegment, route, segments), consumedSegments = _a.consumedSegments, parameters = _a.parameters, lastChild = _a.lastChild;\n\t          var /** @type {?} */ rawSlicedSegments = segments.slice(lastChild);\n\t          var /** @type {?} */ childConfig = getChildConfig(route);\n\t          var _b = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _b.segmentGroup, slicedSegments = _b.slicedSegments;\n\t          var /** @type {?} */ snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));\n\t          if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n\t              var /** @type {?} */ children = this.processChildren(childConfig, segmentGroup);\n\t              return [new TreeNode(snapshot, children)];\n\t          }\n\t          else if (childConfig.length === 0 && slicedSegments.length === 0) {\n\t              return [new TreeNode(snapshot, [])];\n\t          }\n\t          else {\n\t              var /** @type {?} */ children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);\n\t              return [new TreeNode(snapshot, children)];\n\t          }\n\t      };\n\t      return Recognizer;\n\t  }());\n\t  /**\n\t   * @param {?} nodes\n\t   * @return {?}\n\t   */\n\t  function sortActivatedRouteSnapshots(nodes) {\n\t      nodes.sort(function (a, b) {\n\t          if (a.value.outlet === PRIMARY_OUTLET)\n\t              return -1;\n\t          if (b.value.outlet === PRIMARY_OUTLET)\n\t              return 1;\n\t          return a.value.outlet.localeCompare(b.value.outlet);\n\t      });\n\t  }\n\t  /**\n\t   * @param {?} route\n\t   * @return {?}\n\t   */\n\t  function getChildConfig(route) {\n\t      if (route.children) {\n\t          return route.children;\n\t      }\n\t      else if (route.loadChildren) {\n\t          return ((route))._loadedConfig.routes;\n\t      }\n\t      else {\n\t          return [];\n\t      }\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @param {?} route\n\t   * @param {?} segments\n\t   * @return {?}\n\t   */\n\t  function match$1(segmentGroup, route, segments) {\n\t      if (route.path === '') {\n\t          if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n\t              throw new NoMatch$1();\n\t          }\n\t          else {\n\t              return { consumedSegments: [], lastChild: 0, parameters: {} };\n\t          }\n\t      }\n\t      var /** @type {?} */ matcher = route.matcher || defaultUrlMatcher;\n\t      var /** @type {?} */ res = matcher(segments, segmentGroup, route);\n\t      if (!res)\n\t          throw new NoMatch$1();\n\t      var /** @type {?} */ posParams = {};\n\t      forEach(res.posParams, function (v, k) { posParams[k] = v.path; });\n\t      var /** @type {?} */ parameters = merge(posParams, res.consumed[res.consumed.length - 1].parameters);\n\t      return { consumedSegments: res.consumed, lastChild: res.consumed.length, parameters: parameters };\n\t  }\n\t  /**\n\t   * @param {?} nodes\n\t   * @return {?}\n\t   */\n\t  function checkOutletNameUniqueness(nodes) {\n\t      var /** @type {?} */ names = {};\n\t      nodes.forEach(function (n) {\n\t          var /** @type {?} */ routeWithSameOutletName = names[n.value.outlet];\n\t          if (routeWithSameOutletName) {\n\t              var /** @type {?} */ p = routeWithSameOutletName.url.map(function (s) { return s.toString(); }).join('/');\n\t              var /** @type {?} */ c = n.value.url.map(function (s) { return s.toString(); }).join('/');\n\t              throw new Error(\"Two segments cannot have the same outlet name: '\" + p + \"' and '\" + c + \"'.\");\n\t          }\n\t          names[n.value.outlet] = n.value;\n\t      });\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @return {?}\n\t   */\n\t  function getSourceSegmentGroup(segmentGroup) {\n\t      var /** @type {?} */ s = segmentGroup;\n\t      while (s._sourceSegment) {\n\t          s = s._sourceSegment;\n\t      }\n\t      return s;\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @return {?}\n\t   */\n\t  function getPathIndexShift(segmentGroup) {\n\t      var /** @type {?} */ s = segmentGroup;\n\t      var /** @type {?} */ res = (s._segmentIndexShift ? s._segmentIndexShift : 0);\n\t      while (s._sourceSegment) {\n\t          s = s._sourceSegment;\n\t          res += (s._segmentIndexShift ? s._segmentIndexShift : 0);\n\t      }\n\t      return res - 1;\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @param {?} consumedSegments\n\t   * @param {?} slicedSegments\n\t   * @param {?} config\n\t   * @return {?}\n\t   */\n\t  function split$1(segmentGroup, consumedSegments, slicedSegments, config) {\n\t      if (slicedSegments.length > 0 &&\n\t          containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n\t          var /** @type {?} */ s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n\t          s._sourceSegment = segmentGroup;\n\t          s._segmentIndexShift = consumedSegments.length;\n\t          return { segmentGroup: s, slicedSegments: [] };\n\t      }\n\t      else if (slicedSegments.length === 0 &&\n\t          containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n\t          var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n\t          s._sourceSegment = segmentGroup;\n\t          s._segmentIndexShift = consumedSegments.length;\n\t          return { segmentGroup: s, slicedSegments: slicedSegments };\n\t      }\n\t      else {\n\t          var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n\t          s._sourceSegment = segmentGroup;\n\t          s._segmentIndexShift = consumedSegments.length;\n\t          return { segmentGroup: s, slicedSegments: slicedSegments };\n\t      }\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @param {?} slicedSegments\n\t   * @param {?} routes\n\t   * @param {?} children\n\t   * @return {?}\n\t   */\n\t  function addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n\t      var /** @type {?} */ res = {};\n\t      for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n\t          var r = routes_1[_i];\n\t          if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$2(r)]) {\n\t              var /** @type {?} */ s = new UrlSegmentGroup([], {});\n\t              s._sourceSegment = segmentGroup;\n\t              s._segmentIndexShift = segmentGroup.segments.length;\n\t              res[getOutlet$2(r)] = s;\n\t          }\n\t      }\n\t      return merge(children, res);\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @param {?} consumedSegments\n\t   * @param {?} routes\n\t   * @param {?} primarySegment\n\t   * @return {?}\n\t   */\n\t  function createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {\n\t      var /** @type {?} */ res = {};\n\t      res[PRIMARY_OUTLET] = primarySegment;\n\t      primarySegment._sourceSegment = segmentGroup;\n\t      primarySegment._segmentIndexShift = consumedSegments.length;\n\t      for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {\n\t          var r = routes_2[_i];\n\t          if (r.path === '' && getOutlet$2(r) !== PRIMARY_OUTLET) {\n\t              var /** @type {?} */ s = new UrlSegmentGroup([], {});\n\t              s._sourceSegment = segmentGroup;\n\t              s._segmentIndexShift = consumedSegments.length;\n\t              res[getOutlet$2(r)] = s;\n\t          }\n\t      }\n\t      return res;\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @param {?} slicedSegments\n\t   * @param {?} routes\n\t   * @return {?}\n\t   */\n\t  function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n\t      return routes\n\t          .filter(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r) &&\n\t          getOutlet$2(r) !== PRIMARY_OUTLET; })\n\t          .length > 0;\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @param {?} slicedSegments\n\t   * @param {?} routes\n\t   * @return {?}\n\t   */\n\t  function containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\n\t      return routes.filter(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r); }).length > 0;\n\t  }\n\t  /**\n\t   * @param {?} segmentGroup\n\t   * @param {?} slicedSegments\n\t   * @param {?} r\n\t   * @return {?}\n\t   */\n\t  function emptyPathMatch(segmentGroup, slicedSegments, r) {\n\t      if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full')\n\t          return false;\n\t      return r.path === '' && r.redirectTo === undefined;\n\t  }\n\t  /**\n\t   * @param {?} route\n\t   * @return {?}\n\t   */\n\t  function getOutlet$2(route) {\n\t      return route.outlet ? route.outlet : PRIMARY_OUTLET;\n\t  }\n\t  /**\n\t   * @param {?} route\n\t   * @return {?}\n\t   */\n\t  function getData(route) {\n\t      return route.data ? route.data : {};\n\t  }\n\t  /**\n\t   * @param {?} route\n\t   * @return {?}\n\t   */\n\t  function getResolve(route) {\n\t      return route.resolve ? route.resolve : {};\n\t  }\n\t\n\t  /**\n\t   * @license\n\t   * Copyright Google Inc. All Rights Reserved.\n\t   *\n\t   * Use of this source code is governed by an MIT-style license that can be\n\t   * found in the LICENSE file at https://angular.io/license\n\t   */\n\t  /**\n\t   *  *\n\t   */\n\t  var RouterOutletMap = (function () {\n\t      function RouterOutletMap() {\n\t          /** @internal */\n\t          this._outlets = {};\n\t      }\n\t      /**\n\t       *  Adds an outlet to this map.\n\t       * @param {?} name\n\t       * @param {?} outlet\n\t       * @return {?}\n\t       */\n\t      RouterOutletMap.prototype.registerOutlet = function (name, outlet) { this._outlets[name] = outlet; };\n\t      /**\n\t       *  Removes an outlet from this map.\n\t       * @param {?} name\n\t       * @return {?}\n\t       */\n\t      RouterOutletMap.prototype.removeOutlet = function (name) { this._outlets[name] = undefined; };\n\t      return RouterOutletMap;\n\t  }());\n\t\n\t  /**\n\t   * @license\n\t   * Copyright Google Inc. All Rights Reserved.\n\t   *\n\t   * Use of this source code is governed by an MIT-style license that can be\n\t   * found in the LICENSE file at https://angular.io/license\n\t   */\n\t  /**\n\t   *  *\n\t   * @abstract\n\t   */\n\t  var UrlHandlingStrategy = (function () {\n\t      function UrlHandlingStrategy() {\n\t      }\n\t      /**\n\t       *  Tells the router if this URL should be processed.\n\t        * *\n\t        * When it returns true, the router will execute the regular navigation.\n\t        * When it returns false, the router will set the router state to an empty state.\n\t        * As a result, all the active components will be destroyed.\n\t        * *\n\t       * @abstract\n\t       * @param {?} url\n\t       * @return {?}\n\t       */\n\t      UrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { };\n\t      /**\n\t       *  Extracts the part of the URL that should be handled by the router.\n\t        * The rest of the URL will remain untouched.\n\t       * @abstract\n\t       * @param {?} url\n\t       * @return {?}\n\t       */\n\t      UrlHandlingStrategy.prototype.extract = function (url) { };\n\t      /**\n\t       *  Merges the URL fragment with the rest of the URL.\n\t       * @abstract\n\t       * @param {?} newUrlPart\n\t       * @param {?} rawUrl\n\t       * @return {?}\n\t       */\n\t      UrlHandlingStrategy.prototype.merge = function (newUrlPart, rawUrl) { };\n\t      return UrlHandlingStrategy;\n\t  }());\n\t  /**\n\t   * @experimental\n\t   */\n\t  var DefaultUrlHandlingStrategy = (function () {\n\t      function DefaultUrlHandlingStrategy() {\n\t      }\n\t      /**\n\t       * @param {?} url\n\t       * @return {?}\n\t       */\n\t      DefaultUrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { return true; };\n\t      /**\n\t       * @param {?} url\n\t       * @return {?}\n\t       */\n\t      DefaultUrlHandlingStrategy.prototype.extract = function (url) { return url; };\n\t      /**\n\t       * @param {?} newUrlPart\n\t       * @param {?} wholeUrl\n\t       * @return {?}\n\t       */\n\t      DefaultUrlHandlingStrategy.prototype.merge = function (newUrlPart, wholeUrl) { return newUrlPart; };\n\t      return DefaultUrlHandlingStrategy;\n\t  }());\n\t\n\t  /**\n\t   *  *\n\t   */\n\t  var NavigationStart = (function () {\n\t      /**\n\t       * @param {?} id\n\t       * @param {?} url\n\t       */\n\t      function NavigationStart(id, url) {\n\t          this.id = id;\n\t          this.url = url;\n\t      }\n\t      /**\n\t       * @return {?}\n\t       */\n\t      NavigationStart.prototype.toString = function () { return \"NavigationStart(id: \" + this.id + \", url: '\" + this.url + \"')\"; };\n\t      return NavigationStart;\n\t  }());\n\t  /**\n\t   *  *\n\t   */\n\t  var NavigationEnd = (function () {\n\t      /**\n\t       * @param {?} id\n\t       * @param {?} url\n\t       * @param {?} urlAfterRedirects\n\t       */\n\t      function NavigationEnd(id, url, urlAfterRedirects) {\n\t          this.id = id;\n\t          this.url = url;\n\t          this.urlAfterRedirects = urlAfterRedirects;\n\t      }\n\t      /**\n\t       * @return {?}\n\t       */\n\t      NavigationEnd.prototype.toString = function () {\n\t          return \"NavigationEnd(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"')\";\n\t      };\n\t      return NavigationEnd;\n\t  }());\n\t  /**\n\t   *  *\n\t   */\n\t  var NavigationCancel = (function () {\n\t      /**\n\t       * @param {?} id\n\t       * @param {?} url\n\t       * @param {?} reason\n\t       */\n\t      function NavigationCancel(id, url, reason) {\n\t          this.id = id;\n\t          this.url = url;\n\t          this.reason = reason;\n\t      }\n\t      /**\n\t       * @return {?}\n\t       */\n\t      NavigationCancel.prototype.toString = function () { return \"NavigationCancel(id: \" + this.id + \", url: '\" + this.url + \"')\"; };\n\t      return NavigationCancel;\n\t  }());\n\t  /**\n\t   *  *\n\t   */\n\t  var NavigationError = (function () {\n\t      /**\n\t       * @param {?} id\n\t       * @param {?} url\n\t       * @param {?} error\n\t       */\n\t      function NavigationError(id, url, error) {\n\t          this.id = id;\n\t          this.url = url;\n\t          this.error = error;\n\t      }\n\t      /**\n\t       * @return {?}\n\t       */\n\t      NavigationError.prototype.toString = function () {\n\t          return \"NavigationError(id: \" + this.id + \", url: '\" + this.url + \"', error: \" + this.error + \")\";\n\t      };\n\t      return NavigationError;\n\t  }());\n\t  /**\n\t   *  *\n\t   */\n\t  var RoutesRecognized = (function () {\n\t      /**\n\t       * @param {?} id\n\t       * @param {?} url\n\t       * @param {?} urlAfterRedirects\n\t       * @param {?} state\n\t       */\n\t      function RoutesRecognized(id, url, urlAfterRedirects, state) {\n\t          this.id = id;\n\t          this.url = url;\n\t          this.urlAfterRedirects = urlAfterRedirects;\n\t          this.state = state;\n\t      }\n\t      /**\n\t       * @return {?}\n\t       */\n\t      RoutesRecognized.prototype.toString = function () {\n\t          return \"RoutesRecognized(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \")\";\n\t      };\n\t      return RoutesRecognized;\n\t  }());\n\t  /**\n\t   * @param {?} error\n\t   * @return {?}\n\t   */\n\t  function defaultErrorHandler(error) {\n\t      throw error;\n\t  }\n\t  /**\n\t   *  Does not detach any subtrees. Reuses routes as long as their route config is the same.\n\t   */\n\t  var DefaultRouteReuseStrategy = (function () {\n\t      function DefaultRouteReuseStrategy() {\n\t      }\n\t      /**\n\t       * @param {?} route\n\t       * @return {?}\n\t       */\n\t      DefaultRouteReuseStrategy.prototype.shouldDetach = function (route) { return false; };\n\t      /**\n\t       * @param {?} route\n\t       * @param {?} detachedTree\n\t       * @return {?}\n\t       */\n\t      DefaultRouteReuseStrategy.prototype.store = function (route, detachedTree) { };\n\t      /**\n\t       * @param {?} route\n\t       * @return {?}\n\t       */\n\t      DefaultRouteReuseStrategy.prototype.shouldAttach = function (route) { return false; };\n\t      /**\n\t       * @param {?} route\n\t       * @return {?}\n\t       */\n\t      DefaultRouteReuseStrategy.prototype.retrieve = function (route) { return null; };\n\t      /**\n\t       * @param {?} future\n\t       * @param {?} curr\n\t       * @return {?}\n\t       */\n\t      DefaultRouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) {\n\t          return future.routeConfig === curr.routeConfig;\n\t      };\n\t      return DefaultRouteReuseStrategy;\n\t  }());\n\t  /**\n\t   *  *\n\t    * See {@link Routes} for more details and examples.\n\t    * *\n\t    * *\n\t   */\n\t  var Router = (function () {\n\t      /**\n\t       * @param {?} rootComponentType\n\t       * @param {?} urlSerializer\n\t       * @param {?} outletMap\n\t       * @param {?} location\n\t       * @param {?} injector\n\t       * @param {?} loader\n\t       * @param {?} compiler\n\t       * @param {?} config\n\t       */\n\t      function Router(rootComponentType, urlSerializer, outletMap, location, injector, loader, compiler, config) {\n\t          this.rootComponentType = rootComponentType;\n\t          this.urlSerializer = urlSerializer;\n\t          this.outletMap = outletMap;\n\t          this.location = location;\n\t          this.injector = injector;\n\t          this.config = config;\n\t          this.navigations = new rxjs_BehaviorSubject.BehaviorSubject(null);\n\t          this.routerEvents = new rxjs_Subject.Subject();\n\t          this.navigationId = 0;\n\t          /**\n\t           * Error handler that is invoked when a navigation errors.\n\t           *\n\t           * See {@link ErrorHandler} for more information.\n\t           */\n\t          this.errorHandler = defaultErrorHandler;\n\t          /**\n\t           * Indicates if at least one navigation happened.\n\t           */\n\t          this.navigated = false;\n\t          /**\n\t           * Extracts and merges URLs. Used for Angular 1 to Angular 2 migrations.\n\t           */\n\t          this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();\n\t          this.routeReuseStrategy = new DefaultRouteReuseStrategy();\n\t          this.resetConfig(config);\n\t          this.currentUrlTree = createEmptyUrlTree();\n\t          this.rawUrlTree = this.currentUrlTree;\n\t          this.configLoader = new RouterConfigLoader(loader, compiler);\n\t          this.currentRouterState = createEmptyState(this.currentUrlTree, this.rootComponentType);\n\t          this.processNavigations();\n\t      }\n\t      /**\n\t       *  TODO: this should be removed once the constructor of the router made internal\n\t       * @param {?} rootComponentType\n\t       * @return {?}\n\t       */\n\t      Router.prototype.resetRootComponentType = function (rootComponentType) {\n\t          this.rootComponentType = rootComponentType;\n\t          // TODO: vsavkin router 4.0 should make the root component set to null\n\t          // this will simplify the lifecycle of the router.\n\t          this.currentRouterState.root.component = this.rootComponentType;\n\t      };\n\t      /**\n\t       *  Sets up the location change listener and performs the initial navigation.\n\t       * @return {?}\n\t       */\n\t      Router.prototype.initialNavigation = function () {\n\t          this.setUpLocationChangeListener();\n\t          this.navigateByUrl(this.location.path(true), { replaceUrl: true });\n\t      };\n\t      /**\n\t       *  Sets up the location change listener.\n\t       * @return {?}\n\t       */\n\t      Router.prototype.setUpLocationChangeListener = function () {\n\t          var _this = this;\n\t          // Zone.current.wrap is needed because of the issue with RxJS scheduler,\n\t          // which does not work properly with zone.js in IE and Safari\n\t          if (!this.locationSubscription) {\n\t              this.locationSubscription = (this.location.subscribe(Zone.current.wrap(function (change) {\n\t                  var /** @type {?} */ rawUrlTree = _this.urlSerializer.parse(change['url']);\n\t                  var /** @type {?} */ source = change['type'] === 'popstate' ? 'popstate' : 'hashchange';\n\t                  setTimeout(function () { _this.scheduleNavigation(rawUrlTree, source, { replaceUrl: true }); }, 0);\n\t              })));\n\t          }\n\t      };\n\t      Object.defineProperty(Router.prototype, \"routerState\", {\n\t          /**\n\t           *  The current route state\n\t           * @return {?}\n\t           */\n\t          get: function () { return this.currentRouterState; },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      Object.defineProperty(Router.prototype, \"url\", {\n\t          /**\n\t           *  The current url\n\t           * @return {?}\n\t           */\n\t          get: function () { return this.serializeUrl(this.currentUrlTree); },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      Object.defineProperty(Router.prototype, \"events\", {\n\t          /**\n\t           *  An observable of router events\n\t           * @return {?}\n\t           */\n\t          get: function () { return this.routerEvents; },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      /**\n\t       *  Resets the configuration used for navigation and generating links.\n\t        * *\n\t        * ### Usage\n\t        * *\n\t        * ```\n\t        * router.resetConfig([\n\t        * { path: 'team/:id', component: TeamCmp, children: [\n\t        * { path: 'simple', component: SimpleCmp },\n\t        * { path: 'user/:name', component: UserCmp }\n\t        * ]}\n\t        * ]);\n\t        * ```\n\t       * @param {?} config\n\t       * @return {?}\n\t       */\n\t      Router.prototype.resetConfig = function (config) {\n\t          validateConfig(config);\n\t          this.config = config;\n\t      };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      Router.prototype.ngOnDestroy = function () { this.dispose(); };\n\t      /**\n\t       *  Disposes of the router\n\t       * @return {?}\n\t       */\n\t      Router.prototype.dispose = function () {\n\t          if (this.locationSubscription) {\n\t              this.locationSubscription.unsubscribe();\n\t              this.locationSubscription = null;\n\t          }\n\t      };\n\t      /**\n\t       *  Applies an array of commands to the current url tree and creates a new url tree.\n\t        * *\n\t        * When given an activate route, applies the given commands starting from the route.\n\t        * When not given a route, applies the given command starting from the root.\n\t        * *\n\t        * ### Usage\n\t        * *\n\t        * ```\n\t        * // create /team/33/user/11\n\t        * router.createUrlTree(['/team', 33, 'user', 11]);\n\t        * *\n\t        * // create /team/33;expand=true/user/11\n\t        * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n\t        * *\n\t        * // you can collapse static segments like this (this works only with the first passed-in value):\n\t        * router.createUrlTree(['/team/33/user', userId]);\n\t        * *\n\t        * // If the first segment can contain slashes, and you do not want the router to split it, you\n\t        * // can do the following:\n\t        * *\n\t        * router.createUrlTree([{segmentPath: '/one/two'}]);\n\t        * *\n\t        * // create /team/33/(user/11//right:chat)\n\t        * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n\t        * *\n\t        * // remove the right secondary node\n\t        * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n\t        * *\n\t        * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n\t        * *\n\t        * // navigate to /team/33/user/11/details\n\t        * router.createUrlTree(['details'], {relativeTo: route});\n\t        * *\n\t        * // navigate to /team/33/user/22\n\t        * router.createUrlTree(['../22'], {relativeTo: route});\n\t        * *\n\t        * // navigate to /team/44/user/22\n\t        * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n\t        * ```\n\t       * @param {?} commands\n\t       * @param {?=} __1\n\t       * @return {?}\n\t       */\n\t      Router.prototype.createUrlTree = function (commands, _a) {\n\t          var _b = _a === void 0 ? {} : _a, relativeTo = _b.relativeTo, queryParams = _b.queryParams, fragment = _b.fragment, preserveQueryParams = _b.preserveQueryParams, preserveFragment = _b.preserveFragment;\n\t          var /** @type {?} */ a = relativeTo || this.routerState.root;\n\t          var /** @type {?} */ q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams;\n\t          var /** @type {?} */ f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n\t          return createUrlTree(a, this.currentUrlTree, commands, q, f);\n\t      };\n\t      /**\n\t       *  Navigate based on the provided url. This navigation is always absolute.\n\t        * *\n\t        * Returns a promise that:\n\t        * - resolves to 'true' when navigation succeeds,\n\t        * - resolves to 'false' when navigation fails,\n\t        * - is rejected when an error happens.\n\t        * *\n\t        * ### Usage\n\t        * *\n\t        * ```\n\t        * router.navigateByUrl(\"/team/33/user/11\");\n\t        * *\n\t        * // Navigate without updating the URL\n\t        * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n\t        * ```\n\t        * *\n\t        * In opposite to `navigate`, `navigateByUrl` takes a whole URL\n\t        * and does not apply any delta to the current one.\n\t       * @param {?} url\n\t       * @param {?=} extras\n\t       * @return {?}\n\t       */\n\t      Router.prototype.navigateByUrl = function (url, extras) {\n\t          if (extras === void 0) { extras = { skipLocationChange: false }; }\n\t          if (url instanceof UrlTree) {\n\t              return this.scheduleNavigation(this.urlHandlingStrategy.merge(url, this.rawUrlTree), 'imperative', extras);\n\t          }\n\t          var /** @type {?} */ urlTree = this.urlSerializer.parse(url);\n\t          return this.scheduleNavigation(this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree), 'imperative', extras);\n\t      };\n\t      /**\n\t       *  Navigate based on the provided array of commands and a starting point.\n\t        * If no starting route is provided, the navigation is absolute.\n\t        * *\n\t        * Returns a promise that:\n\t        * - resolves to 'true' when navigation succeeds,\n\t        * - resolves to 'false' when navigation fails,\n\t        * - is rejected when an error happens.\n\t        * *\n\t        * ### Usage\n\t        * *\n\t        * ```\n\t        * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n\t        * *\n\t        * // Navigate without updating the URL\n\t        * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n\t        * ```\n\t        * *\n\t        * In opposite to `navigateByUrl`, `navigate` always takes a delta that is applied to the current\n\t        * URL.\n\t       * @param {?} commands\n\t       * @param {?=} extras\n\t       * @return {?}\n\t       */\n\t      Router.prototype.navigate = function (commands, extras) {\n\t          if (extras === void 0) { extras = { skipLocationChange: false }; }\n\t          if (typeof extras.queryParams === 'object' && extras.queryParams !== null) {\n\t              extras.queryParams = this.removeEmptyProps(extras.queryParams);\n\t          }\n\t          return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n\t      };\n\t      /**\n\t       *  Serializes a {@link UrlTree} into a string\n\t       * @param {?} url\n\t       * @return {?}\n\t       */\n\t      Router.prototype.serializeUrl = function (url) { return this.urlSerializer.serialize(url); };\n\t      /**\n\t       *  Parses a string into a {@link UrlTree}\n\t       * @param {?} url\n\t       * @return {?}\n\t       */\n\t      Router.prototype.parseUrl = function (url) { return this.urlSerializer.parse(url); };\n\t      /**\n\t       *  Returns whether the url is activated\n\t       * @param {?} url\n\t       * @param {?} exact\n\t       * @return {?}\n\t       */\n\t      Router.prototype.isActive = function (url, exact) {\n\t          if (url instanceof UrlTree) {\n\t              return containsTree(this.currentUrlTree, url, exact);\n\t          }\n\t          else {\n\t              var /** @type {?} */ urlTree = this.urlSerializer.parse(url);\n\t              return containsTree(this.currentUrlTree, urlTree, exact);\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} params\n\t       * @return {?}\n\t       */\n\t      Router.prototype.removeEmptyProps = function (params) {\n\t          return Object.keys(params).reduce(function (result, key) {\n\t              var /** @type {?} */ value = params[key];\n\t              if (value !== null && value !== undefined) {\n\t                  result[key] = value;\n\t              }\n\t              return result;\n\t          }, {});\n\t      };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      Router.prototype.processNavigations = function () {\n\t          var _this = this;\n\t          rxjs_operator_concatMap.concatMap\n\t              .call(this.navigations, function (nav) {\n\t              if (nav) {\n\t                  _this.executeScheduledNavigation(nav);\n\t                  // a failed navigation should not stop the router from processing\n\t                  // further navigations => the catch\n\t                  return nav.promise.catch(function () { });\n\t              }\n\t              else {\n\t                  return (rxjs_observable_of.of(null));\n\t              }\n\t          })\n\t              .subscribe(function () { });\n\t      };\n\t      /**\n\t       * @param {?} rawUrl\n\t       * @param {?} source\n\t       * @param {?} extras\n\t       * @return {?}\n\t       */\n\t      Router.prototype.scheduleNavigation = function (rawUrl, source, extras) {\n\t          var /** @type {?} */ lastNavigation = this.navigations.value;\n\t          // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),\n\t          // and that navigation results in 'replaceState' that leads to the same URL,\n\t          // we should skip those.\n\t          if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' &&\n\t              lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n\t              return null; // return value is not used\n\t          }\n\t          // Because of a bug in IE and Edge, the location class fires two events (popstate and\n\t          // hashchange)\n\t          // every single time. The second one should be ignored. Otherwise, the URL will flicker.\n\t          if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' &&\n\t              lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n\t              return null; // return value is not used\n\t          }\n\t          var /** @type {?} */ resolve = null;\n\t          var /** @type {?} */ reject = null;\n\t          var /** @type {?} */ promise = new Promise(function (res, rej) {\n\t              resolve = res;\n\t              reject = rej;\n\t          });\n\t          var /** @type {?} */ id = ++this.navigationId;\n\t          this.navigations.next({ id: id, source: source, rawUrl: rawUrl, extras: extras, resolve: resolve, reject: reject, promise: promise });\n\t          // Make sure that the error is propagated even though `processNavigations` catch\n\t          // handler does not rethrow\n\t          return promise.catch(function (e) { return Promise.reject(e); });\n\t      };\n\t      /**\n\t       * @param {?} __0\n\t       * @return {?}\n\t       */\n\t      Router.prototype.executeScheduledNavigation = function (_a) {\n\t          var _this = this;\n\t          var id = _a.id, rawUrl = _a.rawUrl, extras = _a.extras, resolve = _a.resolve, reject = _a.reject;\n\t          var /** @type {?} */ url = this.urlHandlingStrategy.extract(rawUrl);\n\t          var /** @type {?} */ urlTransition = !this.navigated || url.toString() !== this.currentUrlTree.toString();\n\t          if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(rawUrl)) {\n\t              this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));\n\t              Promise.resolve()\n\t                  .then(function (_) { return _this.runNavigate(url, rawUrl, extras.skipLocationChange, extras.replaceUrl, id, null); })\n\t                  .then(resolve, reject);\n\t          }\n\t          else if (urlTransition && this.rawUrlTree &&\n\t              this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) {\n\t              this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));\n\t              Promise.resolve()\n\t                  .then(function (_) { return _this.runNavigate(url, rawUrl, false, false, id, createEmptyState(url, _this.rootComponentType).snapshot); })\n\t                  .then(resolve, reject);\n\t          }\n\t          else {\n\t              this.rawUrlTree = rawUrl;\n\t              resolve(null);\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} url\n\t       * @param {?} rawUrl\n\t       * @param {?} shouldPreventPushState\n\t       * @param {?} shouldReplaceUrl\n\t       * @param {?} id\n\t       * @param {?} precreatedState\n\t       * @return {?}\n\t       */\n\t      Router.prototype.runNavigate = function (url, rawUrl, shouldPreventPushState, shouldReplaceUrl, id, precreatedState) {\n\t          var _this = this;\n\t          if (id !== this.navigationId) {\n\t              this.location.go(this.urlSerializer.serialize(this.currentUrlTree));\n\t              this.routerEvents.next(new NavigationCancel(id, this.serializeUrl(url), \"Navigation ID \" + id + \" is not equal to the current navigation id \" + this.navigationId));\n\t              return Promise.resolve(false);\n\t          }\n\t          return new Promise(function (resolvePromise, rejectPromise) {\n\t              // create an observable of the url and route state snapshot\n\t              // this operation do not result in any side effects\n\t              var /** @type {?} */ urlAndSnapshot$;\n\t              if (!precreatedState) {\n\t                  var /** @type {?} */ redirectsApplied$ = applyRedirects(_this.injector, _this.configLoader, _this.urlSerializer, url, _this.config);\n\t                  urlAndSnapshot$ = rxjs_operator_mergeMap.mergeMap.call(redirectsApplied$, function (appliedUrl) {\n\t                      return rxjs_operator_map.map.call(recognize(_this.rootComponentType, _this.config, appliedUrl, _this.serializeUrl(appliedUrl)), function (snapshot) {\n\t                          _this.routerEvents.next(new RoutesRecognized(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl), snapshot));\n\t                          return { appliedUrl: appliedUrl, snapshot: snapshot };\n\t                      });\n\t                  });\n\t              }\n\t              else {\n\t                  urlAndSnapshot$ = rxjs_observable_of.of({ appliedUrl: url, snapshot: precreatedState });\n\t              }\n\t              // run preactivation: guards and data resolvers\n\t              var /** @type {?} */ preActivation;\n\t              var /** @type {?} */ preactivationTraverse$ = rxjs_operator_map.map.call(urlAndSnapshot$, function (_a) {\n\t                  var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;\n\t                  preActivation =\n\t                      new PreActivation(snapshot, _this.currentRouterState.snapshot, _this.injector);\n\t                  preActivation.traverse(_this.outletMap);\n\t                  return { appliedUrl: appliedUrl, snapshot: snapshot };\n\t              });\n\t              var /** @type {?} */ preactivationCheckGuards = rxjs_operator_mergeMap.mergeMap.call(preactivationTraverse$, function (_a) {\n\t                  var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;\n\t                  if (_this.navigationId !== id)\n\t                      return rxjs_observable_of.of(false);\n\t                  return rxjs_operator_map.map.call(preActivation.checkGuards(), function (shouldActivate) {\n\t                      return { appliedUrl: appliedUrl, snapshot: snapshot, shouldActivate: shouldActivate };\n\t                  });\n\t              });\n\t              var /** @type {?} */ preactivationResolveData$ = rxjs_operator_mergeMap.mergeMap.call(preactivationCheckGuards, function (p) {\n\t                  if (_this.navigationId !== id)\n\t                      return rxjs_observable_of.of(false);\n\t                  if (p.shouldActivate) {\n\t                      return rxjs_operator_map.map.call(preActivation.resolveData(), function () { return p; });\n\t                  }\n\t                  else {\n\t                      return rxjs_observable_of.of(p);\n\t                  }\n\t              });\n\t              // create router state\n\t              // this operation has side effects => route state is being affected\n\t              var /** @type {?} */ routerState$ = rxjs_operator_map.map.call(preactivationResolveData$, function (_a) {\n\t                  var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot, shouldActivate = _a.shouldActivate;\n\t                  if (shouldActivate) {\n\t                      var /** @type {?} */ state = createRouterState(_this.routeReuseStrategy, snapshot, _this.currentRouterState);\n\t                      return { appliedUrl: appliedUrl, state: state, shouldActivate: shouldActivate };\n\t                  }\n\t                  else {\n\t                      return { appliedUrl: appliedUrl, state: null, shouldActivate: shouldActivate };\n\t                  }\n\t              });\n\t              // applied the new router state\n\t              // this operation has side effects\n\t              var /** @type {?} */ navigationIsSuccessful;\n\t              var /** @type {?} */ storedState = _this.currentRouterState;\n\t              var /** @type {?} */ storedUrl = _this.currentUrlTree;\n\t              routerState$\n\t                  .forEach(function (_a) {\n\t                  var appliedUrl = _a.appliedUrl, state = _a.state, shouldActivate = _a.shouldActivate;\n\t                  if (!shouldActivate || id !== _this.navigationId) {\n\t                      navigationIsSuccessful = false;\n\t                      return;\n\t                  }\n\t                  _this.currentUrlTree = appliedUrl;\n\t                  _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);\n\t                  _this.currentRouterState = state;\n\t                  if (!shouldPreventPushState) {\n\t                      var /** @type {?} */ path = _this.urlSerializer.serialize(_this.rawUrlTree);\n\t                      if (_this.location.isCurrentPathEqualTo(path) || shouldReplaceUrl) {\n\t                          _this.location.replaceState(path);\n\t                      }\n\t                      else {\n\t                          _this.location.go(path);\n\t                      }\n\t                  }\n\t                  new ActivateRoutes(_this.routeReuseStrategy, state, storedState)\n\t                      .activate(_this.outletMap);\n\t                  navigationIsSuccessful = true;\n\t              })\n\t                  .then(function () {\n\t                  _this.navigated = true;\n\t                  if (navigationIsSuccessful) {\n\t                      _this.routerEvents.next(new NavigationEnd(id, _this.serializeUrl(url), _this.serializeUrl(_this.currentUrlTree)));\n\t                      resolvePromise(true);\n\t                  }\n\t                  else {\n\t                      _this.resetUrlToCurrentUrlTree();\n\t                      _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), ''));\n\t                      resolvePromise(false);\n\t                  }\n\t              }, function (e) {\n\t                  if (e instanceof NavigationCancelingError) {\n\t                      _this.resetUrlToCurrentUrlTree();\n\t                      _this.navigated = true;\n\t                      _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), e.message));\n\t                      resolvePromise(false);\n\t                  }\n\t                  else {\n\t                      _this.routerEvents.next(new NavigationError(id, _this.serializeUrl(url), e));\n\t                      try {\n\t                          resolvePromise(_this.errorHandler(e));\n\t                      }\n\t                      catch (ee) {\n\t                          rejectPromise(ee);\n\t                      }\n\t                  }\n\t                  _this.currentRouterState = storedState;\n\t                  _this.currentUrlTree = storedUrl;\n\t                  _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);\n\t                  _this.location.replaceState(_this.serializeUrl(_this.rawUrlTree));\n\t              });\n\t          });\n\t      };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      Router.prototype.resetUrlToCurrentUrlTree = function () {\n\t          var /** @type {?} */ path = this.urlSerializer.serialize(this.rawUrlTree);\n\t          this.location.replaceState(path);\n\t      };\n\t      return Router;\n\t  }());\n\t  var CanActivate = (function () {\n\t      /**\n\t       * @param {?} path\n\t       */\n\t      function CanActivate(path) {\n\t          this.path = path;\n\t      }\n\t      Object.defineProperty(CanActivate.prototype, \"route\", {\n\t          /**\n\t           * @return {?}\n\t           */\n\t          get: function () { return this.path[this.path.length - 1]; },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      return CanActivate;\n\t  }());\n\t  var CanDeactivate = (function () {\n\t      /**\n\t       * @param {?} component\n\t       * @param {?} route\n\t       */\n\t      function CanDeactivate(component, route) {\n\t          this.component = component;\n\t          this.route = route;\n\t      }\n\t      return CanDeactivate;\n\t  }());\n\t  var PreActivation = (function () {\n\t      /**\n\t       * @param {?} future\n\t       * @param {?} curr\n\t       * @param {?} injector\n\t       */\n\t      function PreActivation(future, curr, injector) {\n\t          this.future = future;\n\t          this.curr = curr;\n\t          this.injector = injector;\n\t          this.checks = [];\n\t      }\n\t      /**\n\t       * @param {?} parentOutletMap\n\t       * @return {?}\n\t       */\n\t      PreActivation.prototype.traverse = function (parentOutletMap) {\n\t          var /** @type {?} */ futureRoot = this.future._root;\n\t          var /** @type {?} */ currRoot = this.curr ? this.curr._root : null;\n\t          this.traverseChildRoutes(futureRoot, currRoot, parentOutletMap, [futureRoot.value]);\n\t      };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      PreActivation.prototype.checkGuards = function () {\n\t          var _this = this;\n\t          if (this.checks.length === 0)\n\t              return rxjs_observable_of.of(true);\n\t          var /** @type {?} */ checks$ = rxjs_observable_from.from(this.checks);\n\t          var /** @type {?} */ runningChecks$ = rxjs_operator_mergeMap.mergeMap.call(checks$, function (s) {\n\t              if (s instanceof CanActivate) {\n\t                  return andObservables(rxjs_observable_from.from([_this.runCanActivateChild(s.path), _this.runCanActivate(s.route)]));\n\t              }\n\t              else if (s instanceof CanDeactivate) {\n\t                  // workaround https://github.com/Microsoft/TypeScript/issues/7271\n\t                  var /** @type {?} */ s2 = (s);\n\t                  return _this.runCanDeactivate(s2.component, s2.route);\n\t              }\n\t              else {\n\t                  throw new Error('Cannot be reached');\n\t              }\n\t          });\n\t          return rxjs_operator_every.every.call(runningChecks$, function (result) { return result === true; });\n\t      };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      PreActivation.prototype.resolveData = function () {\n\t          var _this = this;\n\t          if (this.checks.length === 0)\n\t              return rxjs_observable_of.of(null);\n\t          var /** @type {?} */ checks$ = rxjs_observable_from.from(this.checks);\n\t          var /** @type {?} */ runningChecks$ = rxjs_operator_concatMap.concatMap.call(checks$, function (s) {\n\t              if (s instanceof CanActivate) {\n\t                  return _this.runResolve(s.route);\n\t              }\n\t              else {\n\t                  return rxjs_observable_of.of(null);\n\t              }\n\t          });\n\t          return rxjs_operator_reduce.reduce.call(runningChecks$, function (_, __) { return _; });\n\t      };\n\t      /**\n\t       * @param {?} futureNode\n\t       * @param {?} currNode\n\t       * @param {?} outletMap\n\t       * @param {?} futurePath\n\t       * @return {?}\n\t       */\n\t      PreActivation.prototype.traverseChildRoutes = function (futureNode, currNode, outletMap, futurePath) {\n\t          var _this = this;\n\t          var /** @type {?} */ prevChildren = nodeChildrenAsMap(currNode);\n\t          futureNode.children.forEach(function (c) {\n\t              _this.traverseRoutes(c, prevChildren[c.value.outlet], outletMap, futurePath.concat([c.value]));\n\t              delete prevChildren[c.value.outlet];\n\t          });\n\t          forEach(prevChildren, function (v, k) { return _this.deactiveRouteAndItsChildren(v, outletMap._outlets[k]); });\n\t      };\n\t      /**\n\t       * @param {?} futureNode\n\t       * @param {?} currNode\n\t       * @param {?} parentOutletMap\n\t       * @param {?} futurePath\n\t       * @return {?}\n\t       */\n\t      PreActivation.prototype.traverseRoutes = function (futureNode, currNode, parentOutletMap, futurePath) {\n\t          var /** @type {?} */ future = futureNode.value;\n\t          var /** @type {?} */ curr = currNode ? currNode.value : null;\n\t          var /** @type {?} */ outlet = parentOutletMap ? parentOutletMap._outlets[futureNode.value.outlet] : null;\n\t          // reusing the node\n\t          if (curr && future._routeConfig === curr._routeConfig) {\n\t              if (!equalParamsAndUrlSegments(future, curr)) {\n\t                  this.checks.push(new CanDeactivate(outlet.component, curr), new CanActivate(futurePath));\n\t              }\n\t              else {\n\t                  // we need to set the data\n\t                  future.data = curr.data;\n\t                  future._resolvedData = curr._resolvedData;\n\t              }\n\t              // If we have a component, we need to go through an outlet.\n\t              if (future.component) {\n\t                  this.traverseChildRoutes(futureNode, currNode, outlet ? outlet.outletMap : null, futurePath);\n\t              }\n\t              else {\n\t                  this.traverseChildRoutes(futureNode, currNode, parentOutletMap, futurePath);\n\t              }\n\t          }\n\t          else {\n\t              if (curr) {\n\t                  this.deactiveRouteAndItsChildren(currNode, outlet);\n\t              }\n\t              this.checks.push(new CanActivate(futurePath));\n\t              // If we have a component, we need to go through an outlet.\n\t              if (future.component) {\n\t                  this.traverseChildRoutes(futureNode, null, outlet ? outlet.outletMap : null, futurePath);\n\t              }\n\t              else {\n\t                  this.traverseChildRoutes(futureNode, null, parentOutletMap, futurePath);\n\t              }\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} route\n\t       * @param {?} outlet\n\t       * @return {?}\n\t       */\n\t      PreActivation.prototype.deactiveRouteAndItsChildren = function (route, outlet) {\n\t          var _this = this;\n\t          var /** @type {?} */ prevChildren = nodeChildrenAsMap(route);\n\t          var /** @type {?} */ r = route.value;\n\t          forEach(prevChildren, function (v, k) {\n\t              if (!r.component) {\n\t                  _this.deactiveRouteAndItsChildren(v, outlet);\n\t              }\n\t              else if (!!outlet) {\n\t                  _this.deactiveRouteAndItsChildren(v, outlet.outletMap._outlets[k]);\n\t              }\n\t              else {\n\t                  _this.deactiveRouteAndItsChildren(v, null);\n\t              }\n\t          });\n\t          if (!r.component) {\n\t              this.checks.push(new CanDeactivate(null, r));\n\t          }\n\t          else if (outlet && outlet.isActivated) {\n\t              this.checks.push(new CanDeactivate(outlet.component, r));\n\t          }\n\t          else {\n\t              this.checks.push(new CanDeactivate(null, r));\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} future\n\t       * @return {?}\n\t       */\n\t      PreActivation.prototype.runCanActivate = function (future) {\n\t          var _this = this;\n\t          var /** @type {?} */ canActivate = future._routeConfig ? future._routeConfig.canActivate : null;\n\t          if (!canActivate || canActivate.length === 0)\n\t              return rxjs_observable_of.of(true);\n\t          var /** @type {?} */ obs = rxjs_operator_map.map.call(rxjs_observable_from.from(canActivate), function (c) {\n\t              var /** @type {?} */ guard = _this.getToken(c, future);\n\t              var /** @type {?} */ observable;\n\t              if (guard.canActivate) {\n\t                  observable = wrapIntoObservable(guard.canActivate(future, _this.future));\n\t              }\n\t              else {\n\t                  observable = wrapIntoObservable(guard(future, _this.future));\n\t              }\n\t              return rxjs_operator_first.first.call(observable);\n\t          });\n\t          return andObservables(obs);\n\t      };\n\t      /**\n\t       * @param {?} path\n\t       * @return {?}\n\t       */\n\t      PreActivation.prototype.runCanActivateChild = function (path) {\n\t          var _this = this;\n\t          var /** @type {?} */ future = path[path.length - 1];\n\t          var /** @type {?} */ canActivateChildGuards = path.slice(0, path.length - 1)\n\t              .reverse()\n\t              .map(function (p) { return _this.extractCanActivateChild(p); })\n\t              .filter(function (_) { return _ !== null; });\n\t          return andObservables(rxjs_operator_map.map.call(rxjs_observable_from.from(canActivateChildGuards), function (d) {\n\t              var /** @type {?} */ obs = rxjs_operator_map.map.call(rxjs_observable_from.from(d.guards), function (c) {\n\t                  var /** @type {?} */ guard = _this.getToken(c, c.node);\n\t                  var /** @type {?} */ observable;\n\t                  if (guard.canActivateChild) {\n\t                      observable = wrapIntoObservable(guard.canActivateChild(future, _this.future));\n\t                  }\n\t                  else {\n\t                      observable = wrapIntoObservable(guard(future, _this.future));\n\t                  }\n\t                  return rxjs_operator_first.first.call(observable);\n\t              });\n\t              return andObservables(obs);\n\t          }));\n\t      };\n\t      /**\n\t       * @param {?} p\n\t       * @return {?}\n\t       */\n\t      PreActivation.prototype.extractCanActivateChild = function (p) {\n\t          var /** @type {?} */ canActivateChild = p._routeConfig ? p._routeConfig.canActivateChild : null;\n\t          if (!canActivateChild || canActivateChild.length === 0)\n\t              return null;\n\t          return { node: p, guards: canActivateChild };\n\t      };\n\t      /**\n\t       * @param {?} component\n\t       * @param {?} curr\n\t       * @return {?}\n\t       */\n\t      PreActivation.prototype.runCanDeactivate = function (component, curr) {\n\t          var _this = this;\n\t          var /** @type {?} */ canDeactivate = curr && curr._routeConfig ? curr._routeConfig.canDeactivate : null;\n\t          if (!canDeactivate || canDeactivate.length === 0)\n\t              return rxjs_observable_of.of(true);\n\t          var /** @type {?} */ canDeactivate$ = rxjs_operator_mergeMap.mergeMap.call(rxjs_observable_from.from(canDeactivate), function (c) {\n\t              var /** @type {?} */ guard = _this.getToken(c, curr);\n\t              var /** @type {?} */ observable;\n\t              if (guard.canDeactivate) {\n\t                  observable = wrapIntoObservable(guard.canDeactivate(component, curr, _this.curr));\n\t              }\n\t              else {\n\t                  observable = wrapIntoObservable(guard(component, curr, _this.curr));\n\t              }\n\t              return rxjs_operator_first.first.call(observable);\n\t          });\n\t          return rxjs_operator_every.every.call(canDeactivate$, function (result) { return result === true; });\n\t      };\n\t      /**\n\t       * @param {?} future\n\t       * @return {?}\n\t       */\n\t      PreActivation.prototype.runResolve = function (future) {\n\t          var /** @type {?} */ resolve = future._resolve;\n\t          return rxjs_operator_map.map.call(this.resolveNode(resolve, future), function (resolvedData) {\n\t              future._resolvedData = resolvedData;\n\t              future.data = merge(future.data, inheritedParamsDataResolve(future).resolve);\n\t              return null;\n\t          });\n\t      };\n\t      /**\n\t       * @param {?} resolve\n\t       * @param {?} future\n\t       * @return {?}\n\t       */\n\t      PreActivation.prototype.resolveNode = function (resolve, future) {\n\t          var _this = this;\n\t          return waitForMap(resolve, function (k, v) {\n\t              var /** @type {?} */ resolver = _this.getToken(v, future);\n\t              return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, _this.future)) :\n\t                  wrapIntoObservable(resolver(future, _this.future));\n\t          });\n\t      };\n\t      /**\n\t       * @param {?} token\n\t       * @param {?} snapshot\n\t       * @return {?}\n\t       */\n\t      PreActivation.prototype.getToken = function (token, snapshot) {\n\t          var /** @type {?} */ config = closestLoadedConfig(snapshot);\n\t          var /** @type {?} */ injector = config ? config.injector : this.injector;\n\t          return injector.get(token);\n\t      };\n\t      return PreActivation;\n\t  }());\n\t  var ActivateRoutes = (function () {\n\t      /**\n\t       * @param {?} routeReuseStrategy\n\t       * @param {?} futureState\n\t       * @param {?} currState\n\t       */\n\t      function ActivateRoutes(routeReuseStrategy, futureState, currState) {\n\t          this.routeReuseStrategy = routeReuseStrategy;\n\t          this.futureState = futureState;\n\t          this.currState = currState;\n\t      }\n\t      /**\n\t       * @param {?} parentOutletMap\n\t       * @return {?}\n\t       */\n\t      ActivateRoutes.prototype.activate = function (parentOutletMap) {\n\t          var /** @type {?} */ futureRoot = this.futureState._root;\n\t          var /** @type {?} */ currRoot = this.currState ? this.currState._root : null;\n\t          this.deactivateChildRoutes(futureRoot, currRoot, parentOutletMap);\n\t          advanceActivatedRoute(this.futureState.root);\n\t          this.activateChildRoutes(futureRoot, currRoot, parentOutletMap);\n\t      };\n\t      /**\n\t       * @param {?} futureNode\n\t       * @param {?} currNode\n\t       * @param {?} outletMap\n\t       * @return {?}\n\t       */\n\t      ActivateRoutes.prototype.deactivateChildRoutes = function (futureNode, currNode, outletMap) {\n\t          var _this = this;\n\t          var /** @type {?} */ prevChildren = nodeChildrenAsMap(currNode);\n\t          futureNode.children.forEach(function (c) {\n\t              _this.deactivateRoutes(c, prevChildren[c.value.outlet], outletMap);\n\t              delete prevChildren[c.value.outlet];\n\t          });\n\t          forEach(prevChildren, function (v, k) { return _this.deactiveRouteAndItsChildren(v, outletMap); });\n\t      };\n\t      /**\n\t       * @param {?} futureNode\n\t       * @param {?} currNode\n\t       * @param {?} outletMap\n\t       * @return {?}\n\t       */\n\t      ActivateRoutes.prototype.activateChildRoutes = function (futureNode, currNode, outletMap) {\n\t          var _this = this;\n\t          var /** @type {?} */ prevChildren = nodeChildrenAsMap(currNode);\n\t          futureNode.children.forEach(function (c) { _this.activateRoutes(c, prevChildren[c.value.outlet], outletMap); });\n\t      };\n\t      /**\n\t       * @param {?} futureNode\n\t       * @param {?} currNode\n\t       * @param {?} parentOutletMap\n\t       * @return {?}\n\t       */\n\t      ActivateRoutes.prototype.deactivateRoutes = function (futureNode, currNode, parentOutletMap) {\n\t          var /** @type {?} */ future = futureNode.value;\n\t          var /** @type {?} */ curr = currNode ? currNode.value : null;\n\t          // reusing the node\n\t          if (future === curr) {\n\t              // If we have a normal route, we need to go through an outlet.\n\t              if (future.component) {\n\t                  var /** @type {?} */ outlet = getOutlet(parentOutletMap, future);\n\t                  this.deactivateChildRoutes(futureNode, currNode, outlet.outletMap);\n\t              }\n\t              else {\n\t                  this.deactivateChildRoutes(futureNode, currNode, parentOutletMap);\n\t              }\n\t          }\n\t          else {\n\t              if (curr) {\n\t                  this.deactiveRouteAndItsChildren(currNode, parentOutletMap);\n\t              }\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} futureNode\n\t       * @param {?} currNode\n\t       * @param {?} parentOutletMap\n\t       * @return {?}\n\t       */\n\t      ActivateRoutes.prototype.activateRoutes = function (futureNode, currNode, parentOutletMap) {\n\t          var /** @type {?} */ future = futureNode.value;\n\t          var /** @type {?} */ curr = currNode ? currNode.value : null;\n\t          // reusing the node\n\t          if (future === curr) {\n\t              // advance the route to push the parameters\n\t              advanceActivatedRoute(future);\n\t              // If we have a normal route, we need to go through an outlet.\n\t              if (future.component) {\n\t                  var /** @type {?} */ outlet = getOutlet(parentOutletMap, future);\n\t                  this.activateChildRoutes(futureNode, currNode, outlet.outletMap);\n\t              }\n\t              else {\n\t                  this.activateChildRoutes(futureNode, currNode, parentOutletMap);\n\t              }\n\t          }\n\t          else {\n\t              // if we have a normal route, we need to advance the route\n\t              // and place the component into the outlet. After that recurse.\n\t              if (future.component) {\n\t                  advanceActivatedRoute(future);\n\t                  var /** @type {?} */ outlet = getOutlet(parentOutletMap, futureNode.value);\n\t                  if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n\t                      var /** @type {?} */ stored = ((this.routeReuseStrategy.retrieve(future.snapshot)));\n\t                      this.routeReuseStrategy.store(future.snapshot, null);\n\t                      outlet.attach(stored.componentRef, stored.route.value);\n\t                      advanceActivatedRouteNodeAndItsChildren(stored.route);\n\t                  }\n\t                  else {\n\t                      var /** @type {?} */ outletMap = new RouterOutletMap();\n\t                      this.placeComponentIntoOutlet(outletMap, future, outlet);\n\t                      this.activateChildRoutes(futureNode, null, outletMap);\n\t                  }\n\t              }\n\t              else {\n\t                  advanceActivatedRoute(future);\n\t                  this.activateChildRoutes(futureNode, null, parentOutletMap);\n\t              }\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} outletMap\n\t       * @param {?} future\n\t       * @param {?} outlet\n\t       * @return {?}\n\t       */\n\t      ActivateRoutes.prototype.placeComponentIntoOutlet = function (outletMap, future, outlet) {\n\t          var /** @type {?} */ resolved = ([{ provide: ActivatedRoute, useValue: future }, {\n\t                  provide: RouterOutletMap,\n\t                  useValue: outletMap\n\t              }]);\n\t          var /** @type {?} */ config = parentLoadedConfig(future.snapshot);\n\t          var /** @type {?} */ resolver = null;\n\t          var /** @type {?} */ injector = null;\n\t          if (config) {\n\t              injector = config.injectorFactory(outlet.locationInjector);\n\t              resolver = config.factoryResolver;\n\t              resolved.push({ provide: _angular_core.ComponentFactoryResolver, useValue: resolver });\n\t          }\n\t          else {\n\t              injector = outlet.locationInjector;\n\t              resolver = outlet.locationFactoryResolver;\n\t          }\n\t          outlet.activate(future, resolver, injector, _angular_core.ReflectiveInjector.resolve(resolved), outletMap);\n\t      };\n\t      /**\n\t       * @param {?} route\n\t       * @param {?} parentOutletMap\n\t       * @return {?}\n\t       */\n\t      ActivateRoutes.prototype.deactiveRouteAndItsChildren = function (route, parentOutletMap) {\n\t          if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n\t              this.detachAndStoreRouteSubtree(route, parentOutletMap);\n\t          }\n\t          else {\n\t              this.deactiveRouteAndOutlet(route, parentOutletMap);\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} route\n\t       * @param {?} parentOutletMap\n\t       * @return {?}\n\t       */\n\t      ActivateRoutes.prototype.detachAndStoreRouteSubtree = function (route, parentOutletMap) {\n\t          var /** @type {?} */ outlet = getOutlet(parentOutletMap, route.value);\n\t          var /** @type {?} */ componentRef = outlet.detach();\n\t          this.routeReuseStrategy.store(route.value.snapshot, { componentRef: componentRef, route: route });\n\t      };\n\t      /**\n\t       * @param {?} route\n\t       * @param {?} parentOutletMap\n\t       * @return {?}\n\t       */\n\t      ActivateRoutes.prototype.deactiveRouteAndOutlet = function (route, parentOutletMap) {\n\t          var _this = this;\n\t          var /** @type {?} */ prevChildren = nodeChildrenAsMap(route);\n\t          var /** @type {?} */ outlet = null;\n\t          // getOutlet throws when cannot find the right outlet,\n\t          // which can happen if an outlet was in an NgIf and was removed\n\t          try {\n\t              outlet = getOutlet(parentOutletMap, route.value);\n\t          }\n\t          catch (e) {\n\t              return;\n\t          }\n\t          var /** @type {?} */ childOutletMap = outlet.outletMap;\n\t          forEach(prevChildren, function (v, k) {\n\t              if (route.value.component) {\n\t                  _this.deactiveRouteAndItsChildren(v, childOutletMap);\n\t              }\n\t              else {\n\t                  _this.deactiveRouteAndItsChildren(v, parentOutletMap);\n\t              }\n\t          });\n\t          if (outlet && outlet.isActivated) {\n\t              outlet.deactivate();\n\t          }\n\t      };\n\t      return ActivateRoutes;\n\t  }());\n\t  /**\n\t   * @param {?} node\n\t   * @return {?}\n\t   */\n\t  function advanceActivatedRouteNodeAndItsChildren(node) {\n\t      advanceActivatedRoute(node.value);\n\t      node.children.forEach(advanceActivatedRouteNodeAndItsChildren);\n\t  }\n\t  /**\n\t   * @param {?} snapshot\n\t   * @return {?}\n\t   */\n\t  function parentLoadedConfig(snapshot) {\n\t      var /** @type {?} */ s = snapshot.parent;\n\t      while (s) {\n\t          var /** @type {?} */ c = s._routeConfig;\n\t          if (c && c._loadedConfig)\n\t              return c._loadedConfig;\n\t          if (c && c.component)\n\t              return null;\n\t          s = s.parent;\n\t      }\n\t      return null;\n\t  }\n\t  /**\n\t   * @param {?} snapshot\n\t   * @return {?}\n\t   */\n\t  function closestLoadedConfig(snapshot) {\n\t      if (!snapshot)\n\t          return null;\n\t      var /** @type {?} */ s = snapshot.parent;\n\t      while (s) {\n\t          var /** @type {?} */ c = s._routeConfig;\n\t          if (c && c._loadedConfig)\n\t              return c._loadedConfig;\n\t          s = s.parent;\n\t      }\n\t      return null;\n\t  }\n\t  /**\n\t   * @param {?} node\n\t   * @return {?}\n\t   */\n\t  function nodeChildrenAsMap(node) {\n\t      return node ? node.children.reduce(function (m, c) {\n\t          m[c.value.outlet] = c;\n\t          return m;\n\t      }, {}) : {};\n\t  }\n\t  /**\n\t   * @param {?} outletMap\n\t   * @param {?} route\n\t   * @return {?}\n\t   */\n\t  function getOutlet(outletMap, route) {\n\t      var /** @type {?} */ outlet = outletMap._outlets[route.outlet];\n\t      if (!outlet) {\n\t          var /** @type {?} */ componentName = ((route.component)).name;\n\t          if (route.outlet === PRIMARY_OUTLET) {\n\t              throw new Error(\"Cannot find primary outlet to load '\" + componentName + \"'\");\n\t          }\n\t          else {\n\t              throw new Error(\"Cannot find the outlet \" + route.outlet + \" to load '\" + componentName + \"'\");\n\t          }\n\t      }\n\t      return outlet;\n\t  }\n\t\n\t  /**\n\t   *  *\n\t    * *\n\t    * Consider the following route configuration:\n\t    * `[{ path: 'user/:name', component: UserCmp }]`\n\t    * *\n\t    * When linking to this `user/:name` route, you can write:\n\t    * `<a routerLink='/user/bob'>link to user component</a>`\n\t    * *\n\t    * *\n\t    * The RouterLink directives let you link to specific parts of your app.\n\t    * *\n\t    * When the link is static, you can use the directive as follows:\n\t    * `<a routerLink=\"/user/bob\">link to user component</a>`\n\t    * *\n\t    * If you use dynamic values to generate the link, you can pass an array of path\n\t    * segments, followed by the params for each segment.\n\t    * *\n\t    * For instance `['/team', teamId, 'user', userName, {details: true}]`\n\t    * means that we want to generate a link to `/team/11/user/bob;details=true`.\n\t    * *\n\t    * Multiple static segments can be merged into one\n\t    * (e.g., `['/team/11/user', userName, {details: true}]`).\n\t    * *\n\t    * The first segment name can be prepended with `/`, `./`, or `../`:\n\t    * * If the first segment begins with `/`, the router will look up the route from the root of the\n\t    * app.\n\t    * * If the first segment begins with `./`, or doesn't begin with a slash, the router will\n\t    * instead look in the children of the current activated route.\n\t    * * And if the first segment begins with `../`, the router will go up one level.\n\t    * *\n\t    * You can set query params and fragment as follows:\n\t    * *\n\t    * ```\n\t    * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\n\t    * link to user component\n\t    * </a>\n\t    * ```\n\t    * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.\n\t    * *\n\t    * You can also tell the directive to preserve the current query params and fragment:\n\t    * *\n\t    * ```\n\t    * <a [routerLink]=\"['/user/bob']\" preserveQueryParams preserveFragment>\n\t    * link to user component\n\t    * </a>\n\t    * ```\n\t    * *\n\t    * The router link directive always treats the provided input as a delta to the current url.\n\t    * *\n\t    * For instance, if the current url is `/user/(box//aux:team)`.\n\t    * *\n\t    * Then the following link `<a [routerLink]=\"['/user/jim']\">Jim</a>` will generate the link\n\t    * `/user/(jim//aux:team)`.\n\t    * *\n\t    * *\n\t    * See {@link Router.createUrlTree} for more information.\n\t    * *\n\t   */\n\t  var RouterLink = (function () {\n\t      /**\n\t       * @param {?} router\n\t       * @param {?} route\n\t       */\n\t      function RouterLink(router, route) {\n\t          this.router = router;\n\t          this.route = route;\n\t          this.commands = [];\n\t      }\n\t      Object.defineProperty(RouterLink.prototype, \"routerLink\", {\n\t          /**\n\t           * @param {?} data\n\t           * @return {?}\n\t           */\n\t          set: function (data) {\n\t              if (Array.isArray(data)) {\n\t                  this.commands = data;\n\t              }\n\t              else {\n\t                  this.commands = [data];\n\t              }\n\t          },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      /**\n\t       * @return {?}\n\t       */\n\t      RouterLink.prototype.onClick = function () {\n\t          var /** @type {?} */ extras = {\n\t              skipLocationChange: attrBoolValue(this.skipLocationChange),\n\t              replaceUrl: attrBoolValue(this.replaceUrl),\n\t          };\n\t          this.router.navigateByUrl(this.urlTree, extras);\n\t          return true;\n\t      };\n\t      Object.defineProperty(RouterLink.prototype, \"urlTree\", {\n\t          /**\n\t           * @return {?}\n\t           */\n\t          get: function () {\n\t              return this.router.createUrlTree(this.commands, {\n\t                  relativeTo: this.route,\n\t                  queryParams: this.queryParams,\n\t                  fragment: this.fragment,\n\t                  preserveQueryParams: attrBoolValue(this.preserveQueryParams),\n\t                  preserveFragment: attrBoolValue(this.preserveFragment),\n\t              });\n\t          },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      RouterLink.decorators = [\n\t          { type: _angular_core.Directive, args: [{ selector: ':not(a)[routerLink]' },] },\n\t      ];\n\t      /** @nocollapse */\n\t      RouterLink.ctorParameters = function () { return [\n\t          { type: Router, },\n\t          { type: ActivatedRoute, },\n\t      ]; };\n\t      RouterLink.propDecorators = {\n\t          'queryParams': [{ type: _angular_core.Input },],\n\t          'fragment': [{ type: _angular_core.Input },],\n\t          'preserveQueryParams': [{ type: _angular_core.Input },],\n\t          'preserveFragment': [{ type: _angular_core.Input },],\n\t          'skipLocationChange': [{ type: _angular_core.Input },],\n\t          'replaceUrl': [{ type: _angular_core.Input },],\n\t          'routerLink': [{ type: _angular_core.Input },],\n\t          'onClick': [{ type: _angular_core.HostListener, args: ['click', [],] },],\n\t      };\n\t      return RouterLink;\n\t  }());\n\t  /**\n\t   *  *\n\t    * See {@link RouterLink} for more information.\n\t    * *\n\t    * *\n\t   */\n\t  var RouterLinkWithHref = (function () {\n\t      /**\n\t       * @param {?} router\n\t       * @param {?} route\n\t       * @param {?} locationStrategy\n\t       */\n\t      function RouterLinkWithHref(router, route, locationStrategy) {\n\t          var _this = this;\n\t          this.router = router;\n\t          this.route = route;\n\t          this.locationStrategy = locationStrategy;\n\t          this.commands = [];\n\t          this.subscription = router.events.subscribe(function (s) {\n\t              if (s instanceof NavigationEnd) {\n\t                  _this.updateTargetUrlAndHref();\n\t              }\n\t          });\n\t      }\n\t      Object.defineProperty(RouterLinkWithHref.prototype, \"routerLink\", {\n\t          /**\n\t           * @param {?} data\n\t           * @return {?}\n\t           */\n\t          set: function (data) {\n\t              if (Array.isArray(data)) {\n\t                  this.commands = data;\n\t              }\n\t              else {\n\t                  this.commands = [data];\n\t              }\n\t          },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      /**\n\t       * @param {?} changes\n\t       * @return {?}\n\t       */\n\t      RouterLinkWithHref.prototype.ngOnChanges = function (changes) { this.updateTargetUrlAndHref(); };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      RouterLinkWithHref.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\n\t      /**\n\t       * @param {?} button\n\t       * @param {?} ctrlKey\n\t       * @param {?} metaKey\n\t       * @return {?}\n\t       */\n\t      RouterLinkWithHref.prototype.onClick = function (button, ctrlKey, metaKey) {\n\t          if (button !== 0 || ctrlKey || metaKey) {\n\t              return true;\n\t          }\n\t          if (typeof this.target === 'string' && this.target != '_self') {\n\t              return true;\n\t          }\n\t          var /** @type {?} */ extras = {\n\t              skipLocationChange: attrBoolValue(this.skipLocationChange),\n\t              replaceUrl: attrBoolValue(this.replaceUrl),\n\t          };\n\t          this.router.navigateByUrl(this.urlTree, extras);\n\t          return false;\n\t      };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      RouterLinkWithHref.prototype.updateTargetUrlAndHref = function () {\n\t          this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));\n\t      };\n\t      Object.defineProperty(RouterLinkWithHref.prototype, \"urlTree\", {\n\t          /**\n\t           * @return {?}\n\t           */\n\t          get: function () {\n\t              return this.router.createUrlTree(this.commands, {\n\t                  relativeTo: this.route,\n\t                  queryParams: this.queryParams,\n\t                  fragment: this.fragment,\n\t                  preserveQueryParams: attrBoolValue(this.preserveQueryParams),\n\t                  preserveFragment: attrBoolValue(this.preserveFragment),\n\t              });\n\t          },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      RouterLinkWithHref.decorators = [\n\t          { type: _angular_core.Directive, args: [{ selector: 'a[routerLink]' },] },\n\t      ];\n\t      /** @nocollapse */\n\t      RouterLinkWithHref.ctorParameters = function () { return [\n\t          { type: Router, },\n\t          { type: ActivatedRoute, },\n\t          { type: _angular_common.LocationStrategy, },\n\t      ]; };\n\t      RouterLinkWithHref.propDecorators = {\n\t          'target': [{ type: _angular_core.Input },],\n\t          'queryParams': [{ type: _angular_core.Input },],\n\t          'fragment': [{ type: _angular_core.Input },],\n\t          'preserveQueryParams': [{ type: _angular_core.Input },],\n\t          'preserveFragment': [{ type: _angular_core.Input },],\n\t          'skipLocationChange': [{ type: _angular_core.Input },],\n\t          'replaceUrl': [{ type: _angular_core.Input },],\n\t          'href': [{ type: _angular_core.HostBinding },],\n\t          'routerLink': [{ type: _angular_core.Input },],\n\t          'onClick': [{ type: _angular_core.HostListener, args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey'],] },],\n\t      };\n\t      return RouterLinkWithHref;\n\t  }());\n\t  /**\n\t   * @param {?} s\n\t   * @return {?}\n\t   */\n\t  function attrBoolValue(s) {\n\t      return s === '' || !!s;\n\t  }\n\t\n\t  /**\n\t   *  *\n\t    * *\n\t    * ```\n\t    * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n\t    * ```\n\t    * *\n\t    * *\n\t    * The RouterLinkActive directive lets you add a CSS class to an element when the link's route\n\t    * becomes active.\n\t    * *\n\t    * Consider the following example:\n\t    * *\n\t    * ```\n\t    * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n\t    * ```\n\t    * *\n\t    * When the url is either '/user' or '/user/bob', the active-link class will\n\t    * be added to the `a` tag. If the url changes, the class will be removed.\n\t    * *\n\t    * You can set more than one class, as follows:\n\t    * *\n\t    * ```\n\t    * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n\t    * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n\t    * ```\n\t    * *\n\t    * You can configure RouterLinkActive by passing `exact: true`. This will add the classes\n\t    * only when the url matches the link exactly.\n\t    * *\n\t    * ```\n\t    * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n\t    * true}\">Bob</a>\n\t    * ```\n\t    * *\n\t    * You can assign the RouterLinkActive instance to a template variable and directly check\n\t    * the `isActive` status.\n\t    * ```\n\t    * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n\t    * Bob {{ rla.isActive ? '(already open)' : ''}}\n\t    * </a>\n\t    * ```\n\t    * *\n\t    * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.\n\t    * *\n\t    * ```\n\t    * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n\t    * <a routerLink=\"/user/jim\">Jim</a>\n\t    * <a routerLink=\"/user/bob\">Bob</a>\n\t    * </div>\n\t    * ```\n\t    * *\n\t    * This will set the active-link class on the div tag if the url is either '/user/jim' or\n\t    * '/user/bob'.\n\t    * *\n\t    * *\n\t   */\n\t  var RouterLinkActive = (function () {\n\t      /**\n\t       * @param {?} router\n\t       * @param {?} element\n\t       * @param {?} renderer\n\t       */\n\t      function RouterLinkActive(router, element, renderer) {\n\t          var _this = this;\n\t          this.router = router;\n\t          this.element = element;\n\t          this.renderer = renderer;\n\t          this.classes = [];\n\t          this.routerLinkActiveOptions = { exact: false };\n\t          this.subscription = router.events.subscribe(function (s) {\n\t              if (s instanceof NavigationEnd) {\n\t                  _this.update();\n\t              }\n\t          });\n\t      }\n\t      Object.defineProperty(RouterLinkActive.prototype, \"isActive\", {\n\t          /**\n\t           * @return {?}\n\t           */\n\t          get: function () { return this.hasActiveLink(); },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      /**\n\t       * @return {?}\n\t       */\n\t      RouterLinkActive.prototype.ngAfterContentInit = function () {\n\t          var _this = this;\n\t          this.links.changes.subscribe(function (s) { return _this.update(); });\n\t          this.linksWithHrefs.changes.subscribe(function (s) { return _this.update(); });\n\t          this.update();\n\t      };\n\t      Object.defineProperty(RouterLinkActive.prototype, \"routerLinkActive\", {\n\t          /**\n\t           * @param {?} data\n\t           * @return {?}\n\t           */\n\t          set: function (data) {\n\t              if (Array.isArray(data)) {\n\t                  this.classes = (data);\n\t              }\n\t              else {\n\t                  this.classes = data.split(' ');\n\t              }\n\t          },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      /**\n\t       * @param {?} changes\n\t       * @return {?}\n\t       */\n\t      RouterLinkActive.prototype.ngOnChanges = function (changes) { this.update(); };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      RouterLinkActive.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      RouterLinkActive.prototype.update = function () {\n\t          var _this = this;\n\t          if (!this.links || !this.linksWithHrefs || !this.router.navigated)\n\t              return;\n\t          var /** @type {?} */ isActive = this.hasActiveLink();\n\t          this.classes.forEach(function (c) {\n\t              if (c) {\n\t                  _this.renderer.setElementClass(_this.element.nativeElement, c, isActive);\n\t              }\n\t          });\n\t      };\n\t      /**\n\t       * @param {?} router\n\t       * @return {?}\n\t       */\n\t      RouterLinkActive.prototype.isLinkActive = function (router) {\n\t          var _this = this;\n\t          return function (link) {\n\t              return router.isActive(link.urlTree, _this.routerLinkActiveOptions.exact);\n\t          };\n\t      };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      RouterLinkActive.prototype.hasActiveLink = function () {\n\t          return this.links.some(this.isLinkActive(this.router)) ||\n\t              this.linksWithHrefs.some(this.isLinkActive(this.router));\n\t      };\n\t      RouterLinkActive.decorators = [\n\t          { type: _angular_core.Directive, args: [{\n\t                      selector: '[routerLinkActive]',\n\t                      exportAs: 'routerLinkActive',\n\t                  },] },\n\t      ];\n\t      /** @nocollapse */\n\t      RouterLinkActive.ctorParameters = function () { return [\n\t          { type: Router, },\n\t          { type: _angular_core.ElementRef, },\n\t          { type: _angular_core.Renderer, },\n\t      ]; };\n\t      RouterLinkActive.propDecorators = {\n\t          'links': [{ type: _angular_core.ContentChildren, args: [RouterLink, { descendants: true },] },],\n\t          'linksWithHrefs': [{ type: _angular_core.ContentChildren, args: [RouterLinkWithHref, { descendants: true },] },],\n\t          'routerLinkActiveOptions': [{ type: _angular_core.Input },],\n\t          'routerLinkActive': [{ type: _angular_core.Input },],\n\t      };\n\t      return RouterLinkActive;\n\t  }());\n\t\n\t  /**\n\t   *  state.\n\t    * *\n\t    * *\n\t    * ```\n\t    * <router-outlet></router-outlet>\n\t    * <router-outlet name='left'></router-outlet>\n\t    * <router-outlet name='right'></router-outlet>\n\t    * ```\n\t    * *\n\t    * A router outlet will emit an activate event any time a new component is being instantiated,\n\t    * and a deactivate event when it is being destroyed.\n\t    * *\n\t    * ```\n\t    * <router-outlet\n\t    * (activate)='onActivate($event)'\n\t    * (deactivate)='onDeactivate($event)'></router-outlet>\n\t    * ```\n\t    * *\n\t   */\n\t  var RouterOutlet = (function () {\n\t      /**\n\t       * @param {?} parentOutletMap\n\t       * @param {?} location\n\t       * @param {?} resolver\n\t       * @param {?} name\n\t       */\n\t      function RouterOutlet(parentOutletMap, location, resolver, name) {\n\t          this.parentOutletMap = parentOutletMap;\n\t          this.location = location;\n\t          this.resolver = resolver;\n\t          this.name = name;\n\t          this.activateEvents = new _angular_core.EventEmitter();\n\t          this.deactivateEvents = new _angular_core.EventEmitter();\n\t          parentOutletMap.registerOutlet(name ? name : PRIMARY_OUTLET, this);\n\t      }\n\t      /**\n\t       * @return {?}\n\t       */\n\t      RouterOutlet.prototype.ngOnDestroy = function () { this.parentOutletMap.removeOutlet(this.name ? this.name : PRIMARY_OUTLET); };\n\t      Object.defineProperty(RouterOutlet.prototype, \"locationInjector\", {\n\t          /**\n\t           * @return {?}\n\t           */\n\t          get: function () { return this.location.injector; },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      Object.defineProperty(RouterOutlet.prototype, \"locationFactoryResolver\", {\n\t          /**\n\t           * @return {?}\n\t           */\n\t          get: function () { return this.resolver; },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      Object.defineProperty(RouterOutlet.prototype, \"isActivated\", {\n\t          /**\n\t           * @return {?}\n\t           */\n\t          get: function () { return !!this.activated; },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      Object.defineProperty(RouterOutlet.prototype, \"component\", {\n\t          /**\n\t           * @return {?}\n\t           */\n\t          get: function () {\n\t              if (!this.activated)\n\t                  throw new Error('Outlet is not activated');\n\t              return this.activated.instance;\n\t          },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      Object.defineProperty(RouterOutlet.prototype, \"activatedRoute\", {\n\t          /**\n\t           * @return {?}\n\t           */\n\t          get: function () {\n\t              if (!this.activated)\n\t                  throw new Error('Outlet is not activated');\n\t              return this._activatedRoute;\n\t          },\n\t          enumerable: true,\n\t          configurable: true\n\t      });\n\t      /**\n\t       * @return {?}\n\t       */\n\t      RouterOutlet.prototype.detach = function () {\n\t          if (!this.activated)\n\t              throw new Error('Outlet is not activated');\n\t          this.location.detach();\n\t          var /** @type {?} */ r = this.activated;\n\t          this.activated = null;\n\t          this._activatedRoute = null;\n\t          return r;\n\t      };\n\t      /**\n\t       * @param {?} ref\n\t       * @param {?} activatedRoute\n\t       * @return {?}\n\t       */\n\t      RouterOutlet.prototype.attach = function (ref, activatedRoute) {\n\t          this.activated = ref;\n\t          this._activatedRoute = activatedRoute;\n\t          this.location.insert(ref.hostView);\n\t      };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      RouterOutlet.prototype.deactivate = function () {\n\t          if (this.activated) {\n\t              var /** @type {?} */ c = this.component;\n\t              this.activated.destroy();\n\t              this.activated = null;\n\t              this._activatedRoute = null;\n\t              this.deactivateEvents.emit(c);\n\t          }\n\t      };\n\t      /**\n\t       * @param {?} activatedRoute\n\t       * @param {?} resolver\n\t       * @param {?} injector\n\t       * @param {?} providers\n\t       * @param {?} outletMap\n\t       * @return {?}\n\t       */\n\t      RouterOutlet.prototype.activate = function (activatedRoute, resolver, injector, providers, outletMap) {\n\t          if (this.isActivated) {\n\t              throw new Error('Cannot activate an already activated outlet');\n\t          }\n\t          this.outletMap = outletMap;\n\t          this._activatedRoute = activatedRoute;\n\t          var /** @type {?} */ snapshot = activatedRoute._futureSnapshot;\n\t          var /** @type {?} */ component = (snapshot._routeConfig.component);\n\t          var /** @type {?} */ factory = resolver.resolveComponentFactory(component);\n\t          var /** @type {?} */ inj = _angular_core.ReflectiveInjector.fromResolvedProviders(providers, injector);\n\t          this.activated = this.location.createComponent(factory, this.location.length, inj, []);\n\t          this.activated.changeDetectorRef.detectChanges();\n\t          this.activateEvents.emit(this.activated.instance);\n\t      };\n\t      RouterOutlet.decorators = [\n\t          { type: _angular_core.Directive, args: [{ selector: 'router-outlet' },] },\n\t      ];\n\t      /** @nocollapse */\n\t      RouterOutlet.ctorParameters = function () { return [\n\t          { type: RouterOutletMap, },\n\t          { type: _angular_core.ViewContainerRef, },\n\t          { type: _angular_core.ComponentFactoryResolver, },\n\t          { type: undefined, decorators: [{ type: _angular_core.Attribute, args: ['name',] },] },\n\t      ]; };\n\t      RouterOutlet.propDecorators = {\n\t          'activateEvents': [{ type: _angular_core.Output, args: ['activate',] },],\n\t          'deactivateEvents': [{ type: _angular_core.Output, args: ['deactivate',] },],\n\t      };\n\t      return RouterOutlet;\n\t  }());\n\t\n\t  /**\n\t   * @license\n\t   * Copyright Google Inc. All Rights Reserved.\n\t   *\n\t   * Use of this source code is governed by an MIT-style license that can be\n\t   * found in the LICENSE file at https://angular.io/license\n\t   */\n\t  /**\n\t   *  *\n\t   * @abstract\n\t   */\n\t  var RouteReuseStrategy = (function () {\n\t      function RouteReuseStrategy() {\n\t      }\n\t      /**\n\t       *  Determines if this route (and its subtree) should be detached to be reused later\n\t       * @abstract\n\t       * @param {?} route\n\t       * @return {?}\n\t       */\n\t      RouteReuseStrategy.prototype.shouldDetach = function (route) { };\n\t      /**\n\t       *  Stores the detached route\n\t       * @abstract\n\t       * @param {?} route\n\t       * @param {?} handle\n\t       * @return {?}\n\t       */\n\t      RouteReuseStrategy.prototype.store = function (route, handle) { };\n\t      /**\n\t       *  Determines if this route (and its subtree) should be reattached\n\t       * @abstract\n\t       * @param {?} route\n\t       * @return {?}\n\t       */\n\t      RouteReuseStrategy.prototype.shouldAttach = function (route) { };\n\t      /**\n\t       *  Retrieves the previously stored route\n\t       * @abstract\n\t       * @param {?} route\n\t       * @return {?}\n\t       */\n\t      RouteReuseStrategy.prototype.retrieve = function (route) { };\n\t      /**\n\t       *  Determines if a route should be reused\n\t       * @abstract\n\t       * @param {?} future\n\t       * @param {?} curr\n\t       * @return {?}\n\t       */\n\t      RouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) { };\n\t      return RouteReuseStrategy;\n\t  }());\n\t\n\t  var /** @type {?} */ getDOM = _angular_platformBrowser.__platform_browser_private__.getDOM;\n\t\n\t  /**\n\t   *  *\n\t   * @abstract\n\t   */\n\t  var PreloadingStrategy = (function () {\n\t      function PreloadingStrategy() {\n\t      }\n\t      /**\n\t       * @abstract\n\t       * @param {?} route\n\t       * @param {?} fn\n\t       * @return {?}\n\t       */\n\t      PreloadingStrategy.prototype.preload = function (route, fn) { };\n\t      return PreloadingStrategy;\n\t  }());\n\t  /**\n\t   *  *\n\t    * *\n\t    * ```\n\t    * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n\t    * ```\n\t    * *\n\t   */\n\t  var PreloadAllModules = (function () {\n\t      function PreloadAllModules() {\n\t      }\n\t      /**\n\t       * @param {?} route\n\t       * @param {?} fn\n\t       * @return {?}\n\t       */\n\t      PreloadAllModules.prototype.preload = function (route, fn) {\n\t          return rxjs_operator_catch._catch.call(fn(), function () { return rxjs_observable_of.of(null); });\n\t      };\n\t      return PreloadAllModules;\n\t  }());\n\t  /**\n\t   *  *\n\t    * *\n\t    * This strategy is enabled by default.\n\t    * *\n\t   */\n\t  var NoPreloading = (function () {\n\t      function NoPreloading() {\n\t      }\n\t      /**\n\t       * @param {?} route\n\t       * @param {?} fn\n\t       * @return {?}\n\t       */\n\t      NoPreloading.prototype.preload = function (route, fn) { return rxjs_observable_of.of(null); };\n\t      return NoPreloading;\n\t  }());\n\t  /**\n\t   *  The preloader optimistically loads all router configurations to\n\t    * make navigations into lazily-loaded sections of the application faster.\n\t    * *\n\t    * The preloader runs in the background. When the router bootstraps, the preloader\n\t    * starts listening to all navigation events. After every such event, the preloader\n\t    * will check if any configurations can be loaded lazily.\n\t    * *\n\t    * If a route is protected by `canLoad` guards, the preloaded will not load it.\n\t    * *\n\t   */\n\t  var RouterPreloader = (function () {\n\t      /**\n\t       * @param {?} router\n\t       * @param {?} moduleLoader\n\t       * @param {?} compiler\n\t       * @param {?} injector\n\t       * @param {?} preloadingStrategy\n\t       */\n\t      function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {\n\t          this.router = router;\n\t          this.injector = injector;\n\t          this.preloadingStrategy = preloadingStrategy;\n\t          this.loader = new RouterConfigLoader(moduleLoader, compiler);\n\t      }\n\t      ;\n\t      /**\n\t       * @return {?}\n\t       */\n\t      RouterPreloader.prototype.setUpPreloading = function () {\n\t          var _this = this;\n\t          var /** @type {?} */ navigations = rxjs_operator_filter.filter.call(this.router.events, function (e) { return e instanceof NavigationEnd; });\n\t          this.subscription = rxjs_operator_concatMap.concatMap.call(navigations, function () { return _this.preload(); }).subscribe(function (v) { });\n\t      };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      RouterPreloader.prototype.preload = function () { return this.processRoutes(this.injector, this.router.config); };\n\t      /**\n\t       * @return {?}\n\t       */\n\t      RouterPreloader.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\n\t      /**\n\t       * @param {?} injector\n\t       * @param {?} routes\n\t       * @return {?}\n\t       */\n\t      RouterPreloader.prototype.processRoutes = function (injector, routes) {\n\t          var /** @type {?} */ res = [];\n\t          for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n\t              var c = routes_1[_i];\n\t              // we already have the config loaded, just recurce\n\t              if (c.loadChildren && !c.canLoad && ((c))._loadedConfig) {\n\t                  var /** @type {?} */ childConfig = ((c))._loadedConfig;\n\t                  res.push(this.processRoutes(childConfig.injector, childConfig.routes));\n\t              }\n\t              else if (c.loadChildren && !c.canLoad) {\n\t                  res.push(this.preloadConfig(injector, c));\n\t              }\n\t              else if (c.children) {\n\t                  res.push(this.processRoutes(injector, c.children));\n\t              }\n\t          }\n\t          return rxjs_operator_mergeAll.mergeAll.call(rxjs_observable_from.from(res));\n\t      };\n\t      /**\n\t       * @param {?} injector\n\t       * @param {?} route\n\t       * @return {?}\n\t       */\n\t      RouterPreloader.prototype.preloadConfig = function (injector, route) {\n\t          var _this = this;\n\t          return this.preloadingStrategy.preload(route, function () {\n\t              var /** @type {?} */ loaded = _this.loader.load(injector, route.loadChildren);\n\t              return rxjs_operator_mergeMap.mergeMap.call(loaded, function (config) {\n\t                  var /** @type {?} */ c = route;\n\t                  c._loadedConfig = config;\n\t                  return _this.processRoutes(config.injector, config.routes);\n\t              });\n\t          });\n\t      };\n\t      RouterPreloader.decorators = [\n\t          { type: _angular_core.Injectable },\n\t      ];\n\t      /** @nocollapse */\n\t      RouterPreloader.ctorParameters = function () { return [\n\t          { type: Router, },\n\t          { type: _angular_core.NgModuleFactoryLoader, },\n\t          { type: _angular_core.Compiler, },\n\t          { type: _angular_core.Injector, },\n\t          { type: PreloadingStrategy, },\n\t      ]; };\n\t      return RouterPreloader;\n\t  }());\n\t\n\t  /**\n\t   * @whatItDoes Contains a list of directives\n\t   * @stable\n\t   */\n\t  var /** @type {?} */ ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive];\n\t  /**\n\t   * @whatItDoes Is used in DI to configure the router.\n\t   * @stable\n\t   */\n\t  var /** @type {?} */ ROUTER_CONFIGURATION = new _angular_core.OpaqueToken('ROUTER_CONFIGURATION');\n\t  /**\n\t   * @docsNotRequired\n\t   */\n\t  var /** @type {?} */ ROUTER_FORROOT_GUARD = new _angular_core.OpaqueToken('ROUTER_FORROOT_GUARD');\n\t  var /** @type {?} */ ROUTER_PROVIDERS = [\n\t      _angular_common.Location,\n\t      { provide: UrlSerializer, useClass: DefaultUrlSerializer },\n\t      {\n\t          provide: Router,\n\t          useFactory: setupRouter,\n\t          deps: [\n\t              _angular_core.ApplicationRef, UrlSerializer, RouterOutletMap, _angular_common.Location, _angular_core.Injector, _angular_core.NgModuleFactoryLoader,\n\t              _angular_core.Compiler, ROUTES, ROUTER_CONFIGURATION, [UrlHandlingStrategy, new _angular_core.Optional()],\n\t              [RouteReuseStrategy, new _angular_core.Optional()]\n\t          ]\n\t      },\n\t      RouterOutletMap,\n\t      { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },\n\t      { provide: _angular_core.NgModuleFactoryLoader, useClass: _angular_core.SystemJsNgModuleLoader },\n\t      RouterPreloader,\n\t      NoPreloading,\n\t      PreloadAllModules,\n\t      { provide: ROUTER_CONFIGURATION, useValue: { enableTracing: false } },\n\t  ];\n\t  /**\n\t   * @return {?}\n\t   */\n\t  function routerNgProbeToken() {\n\t      return new _angular_core.NgProbeToken('Router', Router);\n\t  }\n\t  /**\n\t   *  *\n\t    * *\n\t    * RouterModule can be imported multiple times: once per lazily-loaded bundle.\n\t    * Since the router deals with a global shared resource--location, we cannot have\n\t    * more than one router service active.\n\t    * *\n\t    * That is why there are two ways to create the module: `RouterModule.forRoot` and\n\t    * `RouterModule.forChild`.\n\t    * *\n\t    * * `forRoot` creates a module that contains all the directives, the given routes, and the router\n\t    * service itself.\n\t    * * `forChild` creates a module that contains all the directives and the given routes, but does not\n\t    * include the router service.\n\t    * *\n\t    * When registered at the root, the module should be used as follows\n\t    * *\n\t    * ```\n\t    * imports: [RouterModule.forRoot(ROUTES)]\n\t    * })\n\t    * class MyNgModule {}\n\t    * ```\n\t    * *\n\t    * For submodules and lazy loaded submodules the module should be used as follows:\n\t    * *\n\t    * ```\n\t    * imports: [RouterModule.forChild(ROUTES)]\n\t    * })\n\t    * class MyNgModule {}\n\t    * ```\n\t    * *\n\t    * *\n\t    * Managing state transitions is one of the hardest parts of building applications. This is\n\t    * especially true on the web, where you also need to ensure that the state is reflected in the URL.\n\t    * In addition, we often want to split applications into multiple bundles and load them on demand.\n\t    * Doing this transparently is not trivial.\n\t    * *\n\t    * The Angular 2 router solves these problems. Using the router, you can declaratively specify\n\t    * application states, manage state transitions while taking care of the URL, and load bundles on\n\t    * demand.\n\t    * *\n\t    * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an\n\t    * overview of how the router should be used.\n\t    * *\n\t   */\n\t  var RouterModule = (function () {\n\t      /**\n\t       * @param {?} guard\n\t       */\n\t      function RouterModule(guard) {\n\t      }\n\t      /**\n\t       *  Creates a module with all the router providers and directives. It also optionally sets up an\n\t        * application listener to perform an initial navigation.\n\t        * *\n\t        * Options:\n\t        * * `enableTracing` makes the router log all its internal events to the console.\n\t        * * `useHash` enables the location strategy that uses the URL fragment instead of the history\n\t        * API.\n\t        * * `initialNavigation` disables the initial navigation.\n\t        * * `errorHandler` provides a custom error handler.\n\t       * @param {?} routes\n\t       * @param {?=} config\n\t       * @return {?}\n\t       */\n\t      RouterModule.forRoot = function (routes, config) {\n\t          return {\n\t              ngModule: RouterModule,\n\t              providers: [\n\t                  ROUTER_PROVIDERS,\n\t                  provideRoutes(routes),\n\t                  {\n\t                      provide: ROUTER_FORROOT_GUARD,\n\t                      useFactory: provideForRootGuard,\n\t                      deps: [[Router, new _angular_core.Optional(), new _angular_core.SkipSelf()]]\n\t                  },\n\t                  { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} },\n\t                  {\n\t                      provide: _angular_common.LocationStrategy,\n\t                      useFactory: provideLocationStrategy,\n\t                      deps: [\n\t                          _angular_common.PlatformLocation, [new _angular_core.Inject(_angular_common.APP_BASE_HREF), new _angular_core.Optional()], ROUTER_CONFIGURATION\n\t                      ]\n\t                  },\n\t                  {\n\t                      provide: PreloadingStrategy,\n\t                      useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :\n\t                          NoPreloading\n\t                  },\n\t                  { provide: _angular_core.NgProbeToken, multi: true, useFactory: routerNgProbeToken },\n\t                  provideRouterInitializer(),\n\t              ],\n\t          };\n\t      };\n\t      /**\n\t       *  Creates a module with all the router directives and a provider registering routes.\n\t       * @param {?} routes\n\t       * @return {?}\n\t       */\n\t      RouterModule.forChild = function (routes) {\n\t          return { ngModule: RouterModule, providers: [provideRoutes(routes)] };\n\t      };\n\t      RouterModule.decorators = [\n\t          { type: _angular_core.NgModule, args: [{ declarations: ROUTER_DIRECTIVES, exports: ROUTER_DIRECTIVES },] },\n\t      ];\n\t      /** @nocollapse */\n\t      RouterModule.ctorParameters = function () { return [\n\t          { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [ROUTER_FORROOT_GUARD,] },] },\n\t      ]; };\n\t      return RouterModule;\n\t  }());\n\t  /**\n\t   * @param {?} platformLocationStrategy\n\t   * @param {?} baseHref\n\t   * @param {?=} options\n\t   * @return {?}\n\t   */\n\t  function provideLocationStrategy(platformLocationStrategy, baseHref, options) {\n\t      if (options === void 0) { options = {}; }\n\t      return options.useHash ? new _angular_common.HashLocationStrategy(platformLocationStrategy, baseHref) :\n\t          new _angular_common.PathLocationStrategy(platformLocationStrategy, baseHref);\n\t  }\n\t  /**\n\t   * @param {?} router\n\t   * @return {?}\n\t   */\n\t  function provideForRootGuard(router) {\n\t      if (router) {\n\t          throw new Error(\"RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.\");\n\t      }\n\t      return 'guarded';\n\t  }\n\t  /**\n\t   *  *\n\t    * *\n\t    * ```\n\t    * imports: [RouterModule.forChild(ROUTES)],\n\t    * providers: [provideRoutes(EXTRA_ROUTES)]\n\t    * })\n\t    * class MyNgModule {}\n\t    * ```\n\t    * *\n\t   * @param {?} routes\n\t   * @return {?}\n\t   */\n\t  function provideRoutes(routes) {\n\t      return [\n\t          { provide: _angular_core.ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes },\n\t          { provide: ROUTES, multi: true, useValue: routes },\n\t      ];\n\t  }\n\t  /**\n\t   * @param {?} ref\n\t   * @param {?} urlSerializer\n\t   * @param {?} outletMap\n\t   * @param {?} location\n\t   * @param {?} injector\n\t   * @param {?} loader\n\t   * @param {?} compiler\n\t   * @param {?} config\n\t   * @param {?=} opts\n\t   * @param {?=} urlHandlingStrategy\n\t   * @param {?=} routeReuseStrategy\n\t   * @return {?}\n\t   */\n\t  function setupRouter(ref, urlSerializer, outletMap, location, injector, loader, compiler, config, opts, urlHandlingStrategy, routeReuseStrategy) {\n\t      if (opts === void 0) { opts = {}; }\n\t      var /** @type {?} */ router = new Router(null, urlSerializer, outletMap, location, injector, loader, compiler, flatten(config));\n\t      if (urlHandlingStrategy) {\n\t          router.urlHandlingStrategy = urlHandlingStrategy;\n\t      }\n\t      if (routeReuseStrategy) {\n\t          router.routeReuseStrategy = routeReuseStrategy;\n\t      }\n\t      if (opts.errorHandler) {\n\t          router.errorHandler = opts.errorHandler;\n\t      }\n\t      if (opts.enableTracing) {\n\t          var /** @type {?} */ dom_1 = getDOM();\n\t          router.events.subscribe(function (e) {\n\t              dom_1.logGroup(\"Router Event: \" + ((e.constructor)).name);\n\t              dom_1.log(e.toString());\n\t              dom_1.log(e);\n\t              dom_1.logGroupEnd();\n\t          });\n\t      }\n\t      return router;\n\t  }\n\t  /**\n\t   * @param {?} router\n\t   * @return {?}\n\t   */\n\t  function rootRoute(router) {\n\t      return router.routerState.root;\n\t  }\n\t  /**\n\t   * @param {?} router\n\t   * @param {?} ref\n\t   * @param {?} preloader\n\t   * @param {?} opts\n\t   * @return {?}\n\t   */\n\t  function initialRouterNavigation(router, ref, preloader, opts) {\n\t      return function (bootstrappedComponentRef) {\n\t          if (bootstrappedComponentRef !== ref.components[0]) {\n\t              return;\n\t          }\n\t          router.resetRootComponentType(ref.componentTypes[0]);\n\t          preloader.setUpPreloading();\n\t          if (opts.initialNavigation === false) {\n\t              router.setUpLocationChangeListener();\n\t          }\n\t          else {\n\t              router.initialNavigation();\n\t          }\n\t      };\n\t  }\n\t  /**\n\t   * A token for the router initializer that will be called after the app is bootstrapped.\n\t   *\n\t   * @experimental\n\t   */\n\t  var /** @type {?} */ ROUTER_INITIALIZER = new _angular_core.OpaqueToken('Router Initializer');\n\t  /**\n\t   * @return {?}\n\t   */\n\t  function provideRouterInitializer() {\n\t      return [\n\t          {\n\t              provide: ROUTER_INITIALIZER,\n\t              useFactory: initialRouterNavigation,\n\t              deps: [Router, _angular_core.ApplicationRef, RouterPreloader, ROUTER_CONFIGURATION]\n\t          },\n\t          { provide: _angular_core.APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER },\n\t      ];\n\t  }\n\t\n\t  /**\n\t   * @stable\n\t   */\n\t  var /** @type {?} */ VERSION = new _angular_core.Version('3.4.1');\n\t\n\t  var /** @type {?} */ __router_private__ = {\n\t      ROUTER_PROVIDERS: ROUTER_PROVIDERS,\n\t      ROUTES: ROUTES,\n\t      flatten: flatten,\n\t  };\n\t\n\t  exports.RouterLink = RouterLink;\n\t  exports.RouterLinkWithHref = RouterLinkWithHref;\n\t  exports.RouterLinkActive = RouterLinkActive;\n\t  exports.RouterOutlet = RouterOutlet;\n\t  exports.RouteReuseStrategy = RouteReuseStrategy;\n\t  exports.NavigationCancel = NavigationCancel;\n\t  exports.NavigationEnd = NavigationEnd;\n\t  exports.NavigationError = NavigationError;\n\t  exports.NavigationStart = NavigationStart;\n\t  exports.Router = Router;\n\t  exports.RoutesRecognized = RoutesRecognized;\n\t  exports.ROUTER_CONFIGURATION = ROUTER_CONFIGURATION;\n\t  exports.ROUTER_INITIALIZER = ROUTER_INITIALIZER;\n\t  exports.RouterModule = RouterModule;\n\t  exports.provideRoutes = provideRoutes;\n\t  exports.RouterOutletMap = RouterOutletMap;\n\t  exports.NoPreloading = NoPreloading;\n\t  exports.PreloadAllModules = PreloadAllModules;\n\t  exports.PreloadingStrategy = PreloadingStrategy;\n\t  exports.RouterPreloader = RouterPreloader;\n\t  exports.ActivatedRoute = ActivatedRoute;\n\t  exports.ActivatedRouteSnapshot = ActivatedRouteSnapshot;\n\t  exports.RouterState = RouterState;\n\t  exports.RouterStateSnapshot = RouterStateSnapshot;\n\t  exports.PRIMARY_OUTLET = PRIMARY_OUTLET;\n\t  exports.UrlHandlingStrategy = UrlHandlingStrategy;\n\t  exports.DefaultUrlSerializer = DefaultUrlSerializer;\n\t  exports.UrlSegment = UrlSegment;\n\t  exports.UrlSegmentGroup = UrlSegmentGroup;\n\t  exports.UrlSerializer = UrlSerializer;\n\t  exports.UrlTree = UrlTree;\n\t  exports.VERSION = VERSION;\n\t  exports.__router_private__ = __router_private__;\n\t\n\t}));\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n\t};\r\n\tvar __metadata = (this && this.__metadata) || function (k, v) {\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n\t};\r\n\tvar core_1 = __webpack_require__(2);\r\n\tvar AppComponent = (function () {\r\n\t    function AppComponent() {\r\n\t    }\r\n\t    AppComponent = __decorate([\r\n\t        core_1.Component({\r\n\t            selector: 'my-app',\r\n\t            styles: [\"\\n        .menu {\\n            display: flex;\\n            width: 50%;\\n            justify-content: space-between;\\n            margin: 20px auto;\\n        }\\n\\n        a {\\n          text-decoration: none;\\n          font-size: 16px;\\n          padding: 10px;\\n          transition: all .2s ease-out;\\n        }\\n\\n        a.active, a:hover {\\n          background-color: #3498db;\\n          color: #fff !important;\\n        }\\n    \"],\r\n\t            template: \"\\n        <div class=\\\"menu\\\">\\n            <a routerLink=\\\"/fade-in-image\\\" routerLinkActive=\\\"active\\\">Fade in image</a>\\n            <a routerLink=\\\"/default-image\\\" routerLinkActive=\\\"active\\\">Default image</a>\\n            <a routerLink=\\\"/pixelated-image\\\" routerLinkActive=\\\"active\\\">Pixelated transform</a>\\n            <a routerLink=\\\"/bg-image\\\" routerLinkActive=\\\"active\\\">Background image</a>\\n            <a routerLink=\\\"/scroll-container\\\" routerLinkActive=\\\"active\\\">Scroll Container</a>\\n        </div>\\n\\n        <router-outlet></router-outlet>\\n    \",\r\n\t            changeDetection: core_1.ChangeDetectionStrategy.OnPush\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], AppComponent);\r\n\t    return AppComponent;\r\n\t}());\r\n\texports.AppComponent = AppComponent;\r\n\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n\t};\r\n\tvar __metadata = (this && this.__metadata) || function (k, v) {\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n\t};\r\n\tvar core_1 = __webpack_require__(2);\r\n\tvar platform_browser_1 = __webpack_require__(20);\r\n\tvar router_1 = __webpack_require__(83);\r\n\tvar lazyload_image_module_1 = __webpack_require__(92);\r\n\tvar app_component_1 = __webpack_require__(84);\r\n\tvar fade_in_image_component_1 = __webpack_require__(88);\r\n\tvar bg_image_component_1 = __webpack_require__(86);\r\n\tvar default_image_component_1 = __webpack_require__(87);\r\n\tvar pixelated_image_component_1 = __webpack_require__(89);\r\n\tvar scroll_container_component_1 = __webpack_require__(90);\r\n\tvar AppModule = (function () {\r\n\t    function AppModule() {\r\n\t    }\r\n\t    AppModule = __decorate([\r\n\t        core_1.NgModule({\r\n\t            declarations: [\r\n\t                app_component_1.AppComponent,\r\n\t                fade_in_image_component_1.FadeInImageComponent,\r\n\t                bg_image_component_1.BgImageComponent,\r\n\t                default_image_component_1.DefaultImageComponent,\r\n\t                pixelated_image_component_1.PixelatedImageComponent,\r\n\t                scroll_container_component_1.ScrollContainerComponent\r\n\t            ],\r\n\t            imports: [\r\n\t                platform_browser_1.BrowserModule,\r\n\t                router_1.RouterModule.forRoot([\r\n\t                    {\r\n\t                        path: '',\r\n\t                        redirectTo: '/fade-in-image',\r\n\t                        pathMatch: 'full'\r\n\t                    },\r\n\t                    { path: 'fade-in-image', component: fade_in_image_component_1.FadeInImageComponent },\r\n\t                    { path: 'bg-image', component: bg_image_component_1.BgImageComponent },\r\n\t                    { path: 'default-image', component: default_image_component_1.DefaultImageComponent },\r\n\t                    { path: 'pixelated-image', component: pixelated_image_component_1.PixelatedImageComponent },\r\n\t                    { path: 'scroll-container', component: scroll_container_component_1.ScrollContainerComponent },\r\n\t                ]),\r\n\t                lazyload_image_module_1.LazyLoadImageModule\r\n\t            ],\r\n\t            bootstrap: [app_component_1.AppComponent]\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], AppModule);\r\n\t    return AppModule;\r\n\t}());\r\n\texports.AppModule = AppModule;\r\n\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n\t};\r\n\tvar __metadata = (this && this.__metadata) || function (k, v) {\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n\t};\r\n\tvar core_1 = __webpack_require__(2);\r\n\tvar BgImageComponent = (function () {\r\n\t    function BgImageComponent() {\r\n\t        this.errorImage = 'https://i.imgur.com/XkU4Ajf.png';\r\n\t        this.images = [\r\n\t            'https://hd.unsplash.com/photo-1470165525439-3cf9e6dccbad',\r\n\t            'https://hd.unsplash.com/photo-1471109880861-75a04f9b7833',\r\n\t            'https://hd.unsplash.com/photo-1431400445088-1750c997c6b5'\r\n\t        ];\r\n\t    }\r\n\t    BgImageComponent = __decorate([\r\n\t        core_1.Component({\r\n\t            selector: 'bg-image',\r\n\t            styles: [\"\\n        div {\\n            min-width: 1497px;\\n            width: 100%;\\n            min-height: 1127px;\\n            background-position: center;\\n            background-size: cover;\\n            transition: opacity 1s;\\n            opacity: 0;\\n        }\\n        .ng2-lazyloaded {\\n            opacity: 1;\\n        }\\n    \"],\r\n\t            template: \"\\n      <div\\n        *ngFor=\\\"let image of images\\\"\\n        src=\\\"https://www.placecage.com/1000/1000\\\"\\n        [lazyLoad]=\\\"image\\\"\\n        [errorImage]=\\\"errorImage\\\">\\n      </div>\\n    \",\r\n\t            changeDetection: core_1.ChangeDetectionStrategy.OnPush\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], BgImageComponent);\r\n\t    return BgImageComponent;\r\n\t}());\r\n\texports.BgImageComponent = BgImageComponent;\r\n\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n\t};\r\n\tvar __metadata = (this && this.__metadata) || function (k, v) {\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n\t};\r\n\tvar core_1 = __webpack_require__(2);\r\n\tvar DefaultImageComponent = (function () {\r\n\t    function DefaultImageComponent() {\r\n\t        this.errorImage = 'https://i.imgur.com/XkU4Ajf.png';\r\n\t        this.defaultImage = 'https://www.placecage.com/1000/1000';\r\n\t        this.images = [\r\n\t            'https://images.unsplash.com/photo-1467932760935-519284fc87fa?dpr=2&auto=compress,format&fit=crop&w=1199&h=800&q=80',\r\n\t            'https://images.unsplash.com/photo-1468103933896-2c34a78104c2?dpr=2&auto=compress,format&fit=crop&w=1199&h=799&q=80',\r\n\t            'https://images.unsplash.com/photo-1471201187657-6406da15e43b?dpr=2&auto=compress,format&fit=crop&w=1199&h=1199&q=80'\r\n\t        ];\r\n\t    }\r\n\t    DefaultImageComponent = __decorate([\r\n\t        core_1.Component({\r\n\t            selector: 'default-image',\r\n\t            styles: [\"\\n        img {\\n            min-width: 1497px;\\n            width: 100%;\\n            min-height: 1127px;\\n        }\\n\\n        img.ng2-lazyloaded {\\n            animation: fadein .5s;\\n        }\\n\\n        @keyframes fadein {\\n            from { opacity: 0; }\\n            to   { opacity: 1; }\\n        }\\n    \"],\r\n\t            template: \"\\n        <img\\n            *ngFor=\\\"let image of images\\\"\\n            [src]=\\\"defaultImage\\\"\\n            [errorImage]=\\\"errorImage\\\"\\n            [lazyLoad]=\\\"image\\\">\\n    \",\r\n\t            changeDetection: core_1.ChangeDetectionStrategy.OnPush\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], DefaultImageComponent);\r\n\t    return DefaultImageComponent;\r\n\t}());\r\n\texports.DefaultImageComponent = DefaultImageComponent;\r\n\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n\t};\r\n\tvar __metadata = (this && this.__metadata) || function (k, v) {\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n\t};\r\n\tvar core_1 = __webpack_require__(2);\r\n\tvar FadeInImageComponent = (function () {\r\n\t    function FadeInImageComponent() {\r\n\t        this.errorImage = 'https://i.imgur.com/XkU4Ajf.png';\r\n\t        this.images = [\r\n\t            'https://hd.unsplash.com/photo-1441765425173-8fd330fb4a02',\r\n\t            'https://hd.unsplash.com/photo-1451481454041-104482d8e284',\r\n\t            'https://hd.unsplash.com/photo-1471070855862-324d571a1857',\r\n\t            'https://hd.unsplash.com/photo-1415045550139-59b6fafc832f'\r\n\t        ];\r\n\t    }\r\n\t    FadeInImageComponent = __decorate([\r\n\t        core_1.Component({\r\n\t            selector: 'fade-in-image',\r\n\t            styles: [\"\\n        img {\\n            min-width: 1497px;\\n            width: 100%;\\n            min-height: 1127px;\\n            transition: opacity 1s;\\n            opacity: 0;\\n        }\\n\\n        img.ng2-lazyloaded {\\n            opacity: 1;\\n        }\\n    \"],\r\n\t            template: \"\\n        <img\\n          *ngFor=\\\"let image of images\\\"\\n          src=\\\"https://www.placecage.com/1000/1000\\\"\\n          [errorImage]=\\\"errorImage\\\"\\n          [lazyLoad]=\\\"image\\\">\\n    \",\r\n\t            changeDetection: core_1.ChangeDetectionStrategy.OnPush\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], FadeInImageComponent);\r\n\t    return FadeInImageComponent;\r\n\t}());\r\n\texports.FadeInImageComponent = FadeInImageComponent;\r\n\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n\t};\r\n\tvar __metadata = (this && this.__metadata) || function (k, v) {\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n\t};\r\n\tvar core_1 = __webpack_require__(2);\r\n\tvar PixelatedImageComponent = (function () {\r\n\t    function PixelatedImageComponent() {\r\n\t    }\r\n\t    PixelatedImageComponent = __decorate([\r\n\t        core_1.Component({\r\n\t            selector: 'pixelated-image',\r\n\t            styles: [\"\\n        .wrapper {\\n            position: relative;\\n            width: 100%;\\n            height: 1000px;\\n            min-width: 960px;\\n        }\\n        img {\\n            position: absolute;\\n            left: 0;\\n            top: 0;\\n            width: 100%;\\n            height: 100%;\\n        }\\n        .fanart {\\n            position: absolute;\\n            left: 0;\\n            top: 0;\\n            width: 100%;\\n            height: 100%;\\n            background-repeat: no-repeat;\\n            background-position: 0 0;\\n            background-size: cover;\\n            transition: opacity 1s;\\n            opacity: 0;\\n        }\\n        .ng2-lazyloaded {\\n            opacity: 1;\\n        }\\n    \"],\r\n\t            template: \"\\n        <div class=\\\"wrapper\\\">\\n            <img src=\\\"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAUFBQUFBQYGBgYICQgJCAwLCgoLDBINDg0ODRIbERQRERQRGxgdGBYYHRgrIh4eIisyKigqMjw2NjxMSExkZIYBCgoKCgoKCwwMCw8RDxEPFxUTExUXIhkaGRoZIjQhJiEhJiE0LjguKy44LlNBOjpBU2BRTFFgdGhodJOLk8DA///AABEIAAUABQMBEQACEQEDEQH/xABcAAEAAAAAAAAAAAAAAAAAAAAHEAEAAgEFAAAAAAAAAAAAAAACAQMRAAQFB0EBAQEAAAAAAAAAAAAAAAAAAAMEEQAABQUAAAAAAAAAAAAAAAAAAQIDQRITISKR/9oADAMBAAIRAxEAPwAZjt2+oGm3hNumMwmLmIUx7ic6mtPQ/iNSC1plsuj/2Q==\\\">\\n            <div class=\\\"fanart\\\" lazyLoad=\\\"https://images.unsplash.com/photo-1450101215322-bf5cd27642fc?ixlib=rb-0.3.5&q=80&fm=jpg\\\"></div>\\n        </div>\\n    \",\r\n\t            changeDetection: core_1.ChangeDetectionStrategy.OnPush\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], PixelatedImageComponent);\r\n\t    return PixelatedImageComponent;\r\n\t}());\r\n\texports.PixelatedImageComponent = PixelatedImageComponent;\r\n\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n\t};\r\n\tvar __metadata = (this && this.__metadata) || function (k, v) {\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n\t};\r\n\tvar core_1 = __webpack_require__(2);\r\n\tvar ScrollContainerComponent = (function () {\r\n\t    function ScrollContainerComponent(elmRef) {\r\n\t        this.elmRef = elmRef;\r\n\t        this.images = [\r\n\t            'https://images.unsplash.com/photo-1467932760935-519284fc87fa?dpr=2&auto=compress,format&fit=crop&w=1199&h=800&q=80',\r\n\t            'https://images.unsplash.com/photo-1468103933896-2c34a78104c2?dpr=2&auto=compress,format&fit=crop&w=1199&h=799&q=80',\r\n\t            'https://images.unsplash.com/photo-1471201187657-6406da15e43b?dpr=2&auto=compress,format&fit=crop&w=1199&h=1199&q=80'\r\n\t        ];\r\n\t        this.errorImage = 'https://i.imgur.com/XkU4Ajf.png';\r\n\t    }\r\n\t    ScrollContainerComponent.prototype.ngOnInit = function () {\r\n\t        this.myScrollCOntainer = this.elmRef.nativeElement.querySelector('#my-scroll-container');\r\n\t    };\r\n\t    ScrollContainerComponent = __decorate([\r\n\t        core_1.Component({\r\n\t            selector: 'scroll-container',\r\n\t            styles: [\"\\n        img {\\n            min-width: 1497px;\\n            width: 100%;\\n            min-height: 1127px;\\n        }\\n\\n        img.ng2-lazyloaded {\\n            animation: fadein .5s;\\n        }\\n\\n        .scroll-container {\\n            height: 500px;\\n            overflow: scroll;\\n            border: 2px solid red;\\n            margin-bottom: 100px;\\n        }\\n\\n        @keyframes fadein {\\n            from { opacity: 0; }\\n            to   { opacity: 1; }\\n        }\\n    \"],\r\n\t            template: \"\\n    <div class=\\\"scroll-container\\\" id=\\\"my-scroll-container\\\">\\n        <img\\n            *ngFor=\\\"let image of images\\\"\\n            src=\\\"https://www.placecage.com/1000/1000\\\"\\n            [errorImage]=\\\"errorImage\\\"\\n            [scrollTarget]=\\\"myScrollCOntainer\\\"\\n            [lazyLoad]=\\\"image\\\">\\n    </div>\\n\\n    <div class=\\\"scroll-container\\\" #scrollableDiv>\\n        <img\\n            *ngFor=\\\"let image of images\\\"\\n            src=\\\"https://www.placecage.com/1000/1000\\\"\\n            [errorImage]=\\\"errorImage\\\"\\n            [scrollTarget]=\\\"scrollableDiv\\\"\\n            [lazyLoad]=\\\"image\\\">\\n    </div>\\n    \",\r\n\t            changeDetection: core_1.ChangeDetectionStrategy.OnPush\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [core_1.ElementRef])\r\n\t    ], ScrollContainerComponent);\r\n\t    return ScrollContainerComponent;\r\n\t}());\r\n\texports.ScrollContainerComponent = ScrollContainerComponent;\r\n\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n\t};\r\n\tvar __metadata = (this && this.__metadata) || function (k, v) {\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n\t};\r\n\t__webpack_require__(106);\r\n\tvar core_1 = __webpack_require__(2);\r\n\tvar scroll_listener_1 = __webpack_require__(94);\r\n\tvar lazyload_image_1 = __webpack_require__(93);\r\n\tvar LazyLoadImageDirective = (function () {\r\n\t    function LazyLoadImageDirective(el, ngZone) {\r\n\t        this.scrollTarget = window;\r\n\t        this.elementRef = el;\r\n\t        this.ngZone = ngZone;\r\n\t    }\r\n\t    LazyLoadImageDirective.prototype.ngAfterContentInit = function () {\r\n\t        var _this = this;\r\n\t        this.ngZone.runOutsideAngular(function () {\r\n\t            if (_this.scrollObservable) {\r\n\t                _this.scrollSubscription = _this.scrollObservable\r\n\t                    .startWith('')\r\n\t                    .let(lazyload_image_1.lazyLoadImage(_this.elementRef.nativeElement, _this.lazyImage, _this.errorImage, _this.offset))\r\n\t                    .subscribe(function () { });\r\n\t            }\r\n\t            else {\r\n\t                _this.scrollSubscription = scroll_listener_1.getScrollListener(_this.scrollTarget)\r\n\t                    .let(lazyload_image_1.lazyLoadImage(_this.elementRef.nativeElement, _this.lazyImage, _this.errorImage, _this.offset))\r\n\t                    .subscribe(function () { });\r\n\t            }\r\n\t        });\r\n\t    };\r\n\t    LazyLoadImageDirective.prototype.ngOnDestroy = function () {\r\n\t        [this.scrollSubscription]\r\n\t            .filter(function (subscription) { return subscription && !subscription.isUnsubscribed; })\r\n\t            .forEach(function (subscription) { return subscription.unsubscribe(); });\r\n\t    };\r\n\t    __decorate([\r\n\t        core_1.Input('lazyLoad'), \r\n\t        __metadata('design:type', Object)\r\n\t    ], LazyLoadImageDirective.prototype, \"lazyImage\", void 0);\r\n\t    __decorate([\r\n\t        core_1.Input(), \r\n\t        __metadata('design:type', String)\r\n\t    ], LazyLoadImageDirective.prototype, \"errorImage\", void 0);\r\n\t    __decorate([\r\n\t        core_1.Input(), \r\n\t        __metadata('design:type', Object)\r\n\t    ], LazyLoadImageDirective.prototype, \"scrollTarget\", void 0);\r\n\t    __decorate([\r\n\t        core_1.Input(), \r\n\t        __metadata('design:type', Object)\r\n\t    ], LazyLoadImageDirective.prototype, \"scrollObservable\", void 0);\r\n\t    __decorate([\r\n\t        core_1.Input(), \r\n\t        __metadata('design:type', Number)\r\n\t    ], LazyLoadImageDirective.prototype, \"offset\", void 0);\r\n\t    LazyLoadImageDirective = __decorate([\r\n\t        core_1.Directive({\r\n\t            selector: '[lazyLoad]'\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [core_1.ElementRef, core_1.NgZone])\r\n\t    ], LazyLoadImageDirective);\r\n\t    return LazyLoadImageDirective;\r\n\t}());\r\n\texports.LazyLoadImageDirective = LazyLoadImageDirective;\r\n\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n\t};\r\n\tvar __metadata = (this && this.__metadata) || function (k, v) {\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n\t};\r\n\tvar core_1 = __webpack_require__(2);\r\n\tvar lazyload_image_directive_1 = __webpack_require__(91);\r\n\tvar LazyLoadImageModule = (function () {\r\n\t    function LazyLoadImageModule() {\r\n\t    }\r\n\t    LazyLoadImageModule = __decorate([\r\n\t        core_1.NgModule({\r\n\t            declarations: [lazyload_image_directive_1.LazyLoadImageDirective],\r\n\t            exports: [lazyload_image_directive_1.LazyLoadImageDirective]\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], LazyLoadImageModule);\r\n\t    return LazyLoadImageModule;\r\n\t}());\r\n\texports.LazyLoadImageModule = LazyLoadImageModule;\r\n\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t__webpack_require__(59);\r\n\t__webpack_require__(104);\r\n\t__webpack_require__(61);\r\n\t__webpack_require__(108);\r\n\t__webpack_require__(103);\r\n\t__webpack_require__(58);\r\n\tvar Observable_1 = __webpack_require__(1);\r\n\tfunction isVisible(element, threshold, _window) {\r\n\t    if (threshold === void 0) { threshold = 0; }\r\n\t    if (_window === void 0) { _window = window; }\r\n\t    var rect = element.getBoundingClientRect();\r\n\t    var elementLargerThenViewport = rect.top <= threshold && rect.bottom >= -threshold;\r\n\t    var topInsideViewport = rect.top >= 0 && rect.top <= _window.innerHeight;\r\n\t    var belowInsideViewport = rect.bottom >= 0 && rect.bottom <= _window.innerHeight;\r\n\t    var rightsideInViewport = rect.right >= -threshold && (rect.right - threshold) <= _window.innerWidth;\r\n\t    var leftsideInViewport = rect.left >= -threshold && (rect.left - threshold) <= _window.innerWidth;\r\n\t    return (elementLargerThenViewport ||\r\n\t        ((topInsideViewport || belowInsideViewport) &&\r\n\t            (rightsideInViewport || leftsideInViewport)));\r\n\t}\r\n\tfunction loadImage(imagePath) {\r\n\t    return Observable_1.Observable\r\n\t        .create(function (observer) {\r\n\t        var img = new Image();\r\n\t        img.src = imagePath;\r\n\t        img.onload = function () {\r\n\t            observer.next(imagePath);\r\n\t            observer.complete();\r\n\t        };\r\n\t        img.onerror = function (err) {\r\n\t            observer.error(null);\r\n\t        };\r\n\t    });\r\n\t}\r\n\tfunction setImage(element, imagePath) {\r\n\t    var isImgNode = element.nodeName.toLowerCase() === 'img';\r\n\t    if (isImgNode) {\r\n\t        element.src = imagePath;\r\n\t    }\r\n\t    else {\r\n\t        element.style.backgroundImage = \"url('\" + imagePath + \"')\";\r\n\t    }\r\n\t    return element;\r\n\t}\r\n\tfunction setLoadedStyle(element) {\r\n\t    var styles = element.className\r\n\t        .split(' ')\r\n\t        .filter(function (s) { return !!s; })\r\n\t        .filter(function (s) { return s !== 'ng2-lazyloading'; });\r\n\t    styles.push('ng2-lazyloaded');\r\n\t    element.className = styles.join(' ');\r\n\t    return element;\r\n\t}\r\n\tfunction lazyLoadImage(image, imagePath, errorImgPath, offset) {\r\n\t    return function (scrollObservable) {\r\n\t        return scrollObservable\r\n\t            .filter(function () { return isVisible(image, offset); })\r\n\t            .take(1)\r\n\t            .mergeMap(function () { return loadImage(imagePath); })\r\n\t            .do(function () { return setImage(image, imagePath); })\r\n\t            .catch(function () {\r\n\t            if (errorImgPath) {\r\n\t                setImage(image, errorImgPath);\r\n\t            }\r\n\t            return Observable_1.Observable.of(1);\r\n\t        })\r\n\t            .do(function () { return setLoadedStyle(image); });\r\n\t    };\r\n\t}\r\n\texports.lazyLoadImage = lazyLoadImage;\r\n\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t__webpack_require__(110);\r\n\t__webpack_require__(60);\r\n\t__webpack_require__(109);\r\n\t__webpack_require__(100);\r\n\tvar Observable_1 = __webpack_require__(1);\r\n\tvar scrollListeners = new WeakMap();\r\n\tfunction sampleObservable(obs, scheduler) {\r\n\t    return obs\r\n\t        .sampleTime(100, scheduler)\r\n\t        .share()\r\n\t        .startWith('');\r\n\t}\r\n\texports.sampleObservable = sampleObservable;\r\n\texports.getScrollListener = function (scrollTarget) {\r\n\t    if (!scrollTarget || typeof scrollTarget.addEventListener !== 'function') {\r\n\t        console.warn('`addEventListener` on ' + scrollTarget + ' (scrollTarget) is not a function. Skipping this target');\r\n\t        return Observable_1.Observable.empty();\r\n\t    }\r\n\t    if (scrollListeners.has(scrollTarget)) {\r\n\t        return scrollListeners.get(scrollTarget);\r\n\t    }\r\n\t    var srollEvent = Observable_1.Observable.create(function (observer) {\r\n\t        var eventName = 'scroll';\r\n\t        var handler = function (event) { return observer.next(event); };\r\n\t        var options = { passive: true, capture: false };\r\n\t        scrollTarget.addEventListener(eventName, handler, options);\r\n\t        return function () { return scrollTarget.removeEventListener(eventName, handler, options); };\r\n\t    });\r\n\t    var listener = sampleObservable(srollEvent);\r\n\t    scrollListeners.set(scrollTarget, listener);\r\n\t    return listener;\r\n\t};\r\n\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subject_1 = __webpack_require__(14);\n\tvar ObjectUnsubscribedError_1 = __webpack_require__(67);\n\t/**\n\t * @class BehaviorSubject<T>\n\t */\n\tvar BehaviorSubject = (function (_super) {\n\t    __extends(BehaviorSubject, _super);\n\t    function BehaviorSubject(_value) {\n\t        _super.call(this);\n\t        this._value = _value;\n\t    }\n\t    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n\t        get: function () {\n\t            return this.getValue();\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    BehaviorSubject.prototype._subscribe = function (subscriber) {\n\t        var subscription = _super.prototype._subscribe.call(this, subscriber);\n\t        if (subscription && !subscription.closed) {\n\t            subscriber.next(this._value);\n\t        }\n\t        return subscription;\n\t    };\n\t    BehaviorSubject.prototype.getValue = function () {\n\t        if (this.hasError) {\n\t            throw this.thrownError;\n\t        }\n\t        else if (this.closed) {\n\t            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n\t        }\n\t        else {\n\t            return this._value;\n\t        }\n\t    };\n\t    BehaviorSubject.prototype.next = function (value) {\n\t        _super.prototype.next.call(this, this._value = value);\n\t    };\n\t    return BehaviorSubject;\n\t}(Subject_1.Subject));\n\texports.BehaviorSubject = BehaviorSubject;\n\t//# sourceMappingURL=BehaviorSubject.js.map\n\n/***/ },\n/* 96 */,\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(1);\n\t/**\n\t * Represents a push-based event or value that an {@link Observable} can emit.\n\t * This class is particularly useful for operators that manage notifications,\n\t * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n\t * others. Besides wrapping the actual delivered value, it also annotates it\n\t * with metadata of, for instance, what type of push message it is (`next`,\n\t * `error`, or `complete`).\n\t *\n\t * @see {@link materialize}\n\t * @see {@link dematerialize}\n\t * @see {@link observeOn}\n\t *\n\t * @class Notification<T>\n\t */\n\tvar Notification = (function () {\n\t    function Notification(kind, value, error) {\n\t        this.kind = kind;\n\t        this.value = value;\n\t        this.error = error;\n\t        this.hasValue = kind === 'N';\n\t    }\n\t    /**\n\t     * Delivers to the given `observer` the value wrapped by this Notification.\n\t     * @param {Observer} observer\n\t     * @return\n\t     */\n\t    Notification.prototype.observe = function (observer) {\n\t        switch (this.kind) {\n\t            case 'N':\n\t                return observer.next && observer.next(this.value);\n\t            case 'E':\n\t                return observer.error && observer.error(this.error);\n\t            case 'C':\n\t                return observer.complete && observer.complete();\n\t        }\n\t    };\n\t    /**\n\t     * Given some {@link Observer} callbacks, deliver the value represented by the\n\t     * current Notification to the correctly corresponding callback.\n\t     * @param {function(value: T): void} next An Observer `next` callback.\n\t     * @param {function(err: any): void} [error] An Observer `error` callback.\n\t     * @param {function(): void} [complete] An Observer `complete` callback.\n\t     * @return {any}\n\t     */\n\t    Notification.prototype.do = function (next, error, complete) {\n\t        var kind = this.kind;\n\t        switch (kind) {\n\t            case 'N':\n\t                return next && next(this.value);\n\t            case 'E':\n\t                return error && error(this.error);\n\t            case 'C':\n\t                return complete && complete();\n\t        }\n\t    };\n\t    /**\n\t     * Takes an Observer or its individual callback functions, and calls `observe`\n\t     * or `do` methods accordingly.\n\t     * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n\t     * the `next` callback.\n\t     * @param {function(err: any): void} [error] An Observer `error` callback.\n\t     * @param {function(): void} [complete] An Observer `complete` callback.\n\t     * @return {any}\n\t     */\n\t    Notification.prototype.accept = function (nextOrObserver, error, complete) {\n\t        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n\t            return this.observe(nextOrObserver);\n\t        }\n\t        else {\n\t            return this.do(nextOrObserver, error, complete);\n\t        }\n\t    };\n\t    /**\n\t     * Returns a simple Observable that just delivers the notification represented\n\t     * by this Notification instance.\n\t     * @return {any}\n\t     */\n\t    Notification.prototype.toObservable = function () {\n\t        var kind = this.kind;\n\t        switch (kind) {\n\t            case 'N':\n\t                return Observable_1.Observable.of(this.value);\n\t            case 'E':\n\t                return Observable_1.Observable.throw(this.error);\n\t            case 'C':\n\t                return Observable_1.Observable.empty();\n\t        }\n\t        throw new Error('unexpected notification kind value');\n\t    };\n\t    /**\n\t     * A shortcut to create a Notification instance of the type `next` from a\n\t     * given value.\n\t     * @param {T} value The `next` value.\n\t     * @return {Notification<T>} The \"next\" Notification representing the\n\t     * argument.\n\t     */\n\t    Notification.createNext = function (value) {\n\t        if (typeof value !== 'undefined') {\n\t            return new Notification('N', value);\n\t        }\n\t        return this.undefinedValueNotification;\n\t    };\n\t    /**\n\t     * A shortcut to create a Notification instance of the type `error` from a\n\t     * given error.\n\t     * @param {any} [err] The `error` error.\n\t     * @return {Notification<T>} The \"error\" Notification representing the\n\t     * argument.\n\t     */\n\t    Notification.createError = function (err) {\n\t        return new Notification('E', undefined, err);\n\t    };\n\t    /**\n\t     * A shortcut to create a Notification instance of the type `complete`.\n\t     * @return {Notification<any>} The valueless \"complete\" Notification.\n\t     */\n\t    Notification.createComplete = function () {\n\t        return this.completeNotification;\n\t    };\n\t    Notification.completeNotification = new Notification('C');\n\t    Notification.undefinedValueNotification = new Notification('N', undefined);\n\t    return Notification;\n\t}());\n\texports.Notification = Notification;\n\t//# sourceMappingURL=Notification.js.map\n\n/***/ },\n/* 98 */,\n/* 99 */,\n/* 100 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(1);\n\tvar empty_1 = __webpack_require__(117);\n\tObservable_1.Observable.empty = empty_1.empty;\n\t//# sourceMappingURL=empty.js.map\n\n/***/ },\n/* 101 */,\n/* 102 */,\n/* 103 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(1);\n\tvar catch_1 = __webpack_require__(64);\n\tObservable_1.Observable.prototype.catch = catch_1._catch;\n\tObservable_1.Observable.prototype._catch = catch_1._catch;\n\t//# sourceMappingURL=catch.js.map\n\n/***/ },\n/* 104 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(1);\n\tvar do_1 = __webpack_require__(125);\n\tObservable_1.Observable.prototype.do = do_1._do;\n\tObservable_1.Observable.prototype._do = do_1._do;\n\t//# sourceMappingURL=do.js.map\n\n/***/ },\n/* 105 */,\n/* 106 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(1);\n\tvar let_1 = __webpack_require__(130);\n\tObservable_1.Observable.prototype.let = let_1.letProto;\n\tObservable_1.Observable.prototype.letBind = let_1.letProto;\n\t//# sourceMappingURL=let.js.map\n\n/***/ },\n/* 107 */,\n/* 108 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(1);\n\tvar mergeMap_1 = __webpack_require__(32);\n\tObservable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\n\tObservable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n\t//# sourceMappingURL=mergeMap.js.map\n\n/***/ },\n/* 109 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(1);\n\tvar share_1 = __webpack_require__(136);\n\tObservable_1.Observable.prototype.share = share_1.share;\n\t//# sourceMappingURL=share.js.map\n\n/***/ },\n/* 110 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(1);\n\tvar startWith_1 = __webpack_require__(137);\n\tObservable_1.Observable.prototype.startWith = startWith_1.startWith;\n\t//# sourceMappingURL=startWith.js.map\n\n/***/ },\n/* 111 */,\n/* 112 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = __webpack_require__(1);\n\tvar ScalarObservable_1 = __webpack_require__(31);\n\tvar EmptyObservable_1 = __webpack_require__(16);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar ArrayLikeObservable = (function (_super) {\n\t    __extends(ArrayLikeObservable, _super);\n\t    function ArrayLikeObservable(arrayLike, scheduler) {\n\t        _super.call(this);\n\t        this.arrayLike = arrayLike;\n\t        this.scheduler = scheduler;\n\t        if (!scheduler && arrayLike.length === 1) {\n\t            this._isScalar = true;\n\t            this.value = arrayLike[0];\n\t        }\n\t    }\n\t    ArrayLikeObservable.create = function (arrayLike, scheduler) {\n\t        var length = arrayLike.length;\n\t        if (length === 0) {\n\t            return new EmptyObservable_1.EmptyObservable();\n\t        }\n\t        else if (length === 1) {\n\t            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);\n\t        }\n\t        else {\n\t            return new ArrayLikeObservable(arrayLike, scheduler);\n\t        }\n\t    };\n\t    ArrayLikeObservable.dispatch = function (state) {\n\t        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;\n\t        if (subscriber.closed) {\n\t            return;\n\t        }\n\t        if (index >= length) {\n\t            subscriber.complete();\n\t            return;\n\t        }\n\t        subscriber.next(arrayLike[index]);\n\t        state.index = index + 1;\n\t        this.schedule(state);\n\t    };\n\t    ArrayLikeObservable.prototype._subscribe = function (subscriber) {\n\t        var index = 0;\n\t        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;\n\t        var length = arrayLike.length;\n\t        if (scheduler) {\n\t            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n\t                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            for (var i = 0; i < length && !subscriber.closed; i++) {\n\t                subscriber.next(arrayLike[i]);\n\t            }\n\t            subscriber.complete();\n\t        }\n\t    };\n\t    return ArrayLikeObservable;\n\t}(Observable_1.Observable));\n\texports.ArrayLikeObservable = ArrayLikeObservable;\n\t//# sourceMappingURL=ArrayLikeObservable.js.map\n\n/***/ },\n/* 113 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subject_1 = __webpack_require__(14);\n\tvar Observable_1 = __webpack_require__(1);\n\tvar Subscriber_1 = __webpack_require__(3);\n\tvar Subscription_1 = __webpack_require__(11);\n\t/**\n\t * @class ConnectableObservable<T>\n\t */\n\tvar ConnectableObservable = (function (_super) {\n\t    __extends(ConnectableObservable, _super);\n\t    function ConnectableObservable(source, subjectFactory) {\n\t        _super.call(this);\n\t        this.source = source;\n\t        this.subjectFactory = subjectFactory;\n\t        this._refCount = 0;\n\t    }\n\t    ConnectableObservable.prototype._subscribe = function (subscriber) {\n\t        return this.getSubject().subscribe(subscriber);\n\t    };\n\t    ConnectableObservable.prototype.getSubject = function () {\n\t        var subject = this._subject;\n\t        if (!subject || subject.isStopped) {\n\t            this._subject = this.subjectFactory();\n\t        }\n\t        return this._subject;\n\t    };\n\t    ConnectableObservable.prototype.connect = function () {\n\t        var connection = this._connection;\n\t        if (!connection) {\n\t            connection = this._connection = new Subscription_1.Subscription();\n\t            connection.add(this.source\n\t                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n\t            if (connection.closed) {\n\t                this._connection = null;\n\t                connection = Subscription_1.Subscription.EMPTY;\n\t            }\n\t            else {\n\t                this._connection = connection;\n\t            }\n\t        }\n\t        return connection;\n\t    };\n\t    ConnectableObservable.prototype.refCount = function () {\n\t        return this.lift(new RefCountOperator(this));\n\t    };\n\t    return ConnectableObservable;\n\t}(Observable_1.Observable));\n\texports.ConnectableObservable = ConnectableObservable;\n\texports.connectableObservableDescriptor = {\n\t    operator: { value: null },\n\t    _refCount: { value: 0, writable: true },\n\t    _subscribe: { value: ConnectableObservable.prototype._subscribe },\n\t    getSubject: { value: ConnectableObservable.prototype.getSubject },\n\t    connect: { value: ConnectableObservable.prototype.connect },\n\t    refCount: { value: ConnectableObservable.prototype.refCount }\n\t};\n\tvar ConnectableSubscriber = (function (_super) {\n\t    __extends(ConnectableSubscriber, _super);\n\t    function ConnectableSubscriber(destination, connectable) {\n\t        _super.call(this, destination);\n\t        this.connectable = connectable;\n\t    }\n\t    ConnectableSubscriber.prototype._error = function (err) {\n\t        this._unsubscribe();\n\t        _super.prototype._error.call(this, err);\n\t    };\n\t    ConnectableSubscriber.prototype._complete = function () {\n\t        this._unsubscribe();\n\t        _super.prototype._complete.call(this);\n\t    };\n\t    ConnectableSubscriber.prototype._unsubscribe = function () {\n\t        var connectable = this.connectable;\n\t        if (connectable) {\n\t            this.connectable = null;\n\t            var connection = connectable._connection;\n\t            connectable._refCount = 0;\n\t            connectable._subject = null;\n\t            connectable._connection = null;\n\t            if (connection) {\n\t                connection.unsubscribe();\n\t            }\n\t        }\n\t    };\n\t    return ConnectableSubscriber;\n\t}(Subject_1.SubjectSubscriber));\n\tvar RefCountOperator = (function () {\n\t    function RefCountOperator(connectable) {\n\t        this.connectable = connectable;\n\t    }\n\t    RefCountOperator.prototype.call = function (subscriber, source) {\n\t        var connectable = this.connectable;\n\t        connectable._refCount++;\n\t        var refCounter = new RefCountSubscriber(subscriber, connectable);\n\t        var subscription = source.subscribe(refCounter);\n\t        if (!refCounter.closed) {\n\t            refCounter.connection = connectable.connect();\n\t        }\n\t        return subscription;\n\t    };\n\t    return RefCountOperator;\n\t}());\n\tvar RefCountSubscriber = (function (_super) {\n\t    __extends(RefCountSubscriber, _super);\n\t    function RefCountSubscriber(destination, connectable) {\n\t        _super.call(this, destination);\n\t        this.connectable = connectable;\n\t    }\n\t    RefCountSubscriber.prototype._unsubscribe = function () {\n\t        var connectable = this.connectable;\n\t        if (!connectable) {\n\t            this.connection = null;\n\t            return;\n\t        }\n\t        this.connectable = null;\n\t        var refCount = connectable._refCount;\n\t        if (refCount <= 0) {\n\t            this.connection = null;\n\t            return;\n\t        }\n\t        connectable._refCount = refCount - 1;\n\t        if (refCount > 1) {\n\t            this.connection = null;\n\t            return;\n\t        }\n\t        ///\n\t        // Compare the local RefCountSubscriber's connection Subscription to the\n\t        // connection Subscription on the shared ConnectableObservable. In cases\n\t        // where the ConnectableObservable source synchronously emits values, and\n\t        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n\t        // execution continues to here before the RefCountOperator has a chance to\n\t        // supply the RefCountSubscriber with the shared connection Subscription.\n\t        // For example:\n\t        // ```\n\t        // Observable.range(0, 10)\n\t        //   .publish()\n\t        //   .refCount()\n\t        //   .take(5)\n\t        //   .subscribe();\n\t        // ```\n\t        // In order to account for this case, RefCountSubscriber should only dispose\n\t        // the ConnectableObservable's shared connection Subscription if the\n\t        // connection Subscription exists, *and* either:\n\t        //   a. RefCountSubscriber doesn't have a reference to the shared connection\n\t        //      Subscription yet, or,\n\t        //   b. RefCountSubscriber's connection Subscription reference is identical\n\t        //      to the shared connection Subscription\n\t        ///\n\t        var connection = this.connection;\n\t        var sharedConnection = connectable._connection;\n\t        this.connection = null;\n\t        if (sharedConnection && (!connection || sharedConnection === connection)) {\n\t            sharedConnection.unsubscribe();\n\t        }\n\t    };\n\t    return RefCountSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t//# sourceMappingURL=ConnectableObservable.js.map\n\n/***/ },\n/* 114 */,\n/* 115 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar isArray_1 = __webpack_require__(38);\n\tvar isPromise_1 = __webpack_require__(69);\n\tvar PromiseObservable_1 = __webpack_require__(62);\n\tvar IteratorObservable_1 = __webpack_require__(116);\n\tvar ArrayObservable_1 = __webpack_require__(15);\n\tvar ArrayLikeObservable_1 = __webpack_require__(112);\n\tvar iterator_1 = __webpack_require__(33);\n\tvar Observable_1 = __webpack_require__(1);\n\tvar observeOn_1 = __webpack_require__(133);\n\tvar observable_1 = __webpack_require__(34);\n\tvar isArrayLike = (function (x) { return x && typeof x.length === 'number'; });\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar FromObservable = (function (_super) {\n\t    __extends(FromObservable, _super);\n\t    function FromObservable(ish, scheduler) {\n\t        _super.call(this, null);\n\t        this.ish = ish;\n\t        this.scheduler = scheduler;\n\t    }\n\t    /**\n\t     * Creates an Observable from an Array, an array-like object, a Promise, an\n\t     * iterable object, or an Observable-like object.\n\t     *\n\t     * <span class=\"informal\">Converts almost anything to an Observable.</span>\n\t     *\n\t     * <img src=\"./img/from.png\" width=\"100%\">\n\t     *\n\t     * Convert various other objects and data types into Observables. `from`\n\t     * converts a Promise or an array-like or an\n\t     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n\t     * object into an Observable that emits the items in that promise or array or\n\t     * iterable. A String, in this context, is treated as an array of characters.\n\t     * Observable-like objects (contains a function named with the ES2015 Symbol\n\t     * for Observable) can also be converted through this operator.\n\t     *\n\t     * @example <caption>Converts an array to an Observable</caption>\n\t     * var array = [10, 20, 30];\n\t     * var result = Rx.Observable.from(array);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * // Results in the following:\n\t     * // 10 20 30\n\t     *\n\t     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n\t     * function* generateDoubles(seed) {\n\t     *   var i = seed;\n\t     *   while (true) {\n\t     *     yield i;\n\t     *     i = 2 * i; // double it\n\t     *   }\n\t     * }\n\t     *\n\t     * var iterator = generateDoubles(3);\n\t     * var result = Rx.Observable.from(iterator).take(10);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * // Results in the following:\n\t     * // 3 6 12 24 48 96 192 384 768 1536\n\t     *\n\t     * @see {@link create}\n\t     * @see {@link fromEvent}\n\t     * @see {@link fromEventPattern}\n\t     * @see {@link fromPromise}\n\t     *\n\t     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n\t     * Observable-like, an Array, an iterable or an array-like object to be\n\t     * converted.\n\t     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n\t     * emissions of values.\n\t     * @return {Observable<T>} The Observable whose values are originally from the\n\t     * input object that was converted.\n\t     * @static true\n\t     * @name from\n\t     * @owner Observable\n\t     */\n\t    FromObservable.create = function (ish, scheduler) {\n\t        if (ish != null) {\n\t            if (typeof ish[observable_1.$$observable] === 'function') {\n\t                if (ish instanceof Observable_1.Observable && !scheduler) {\n\t                    return ish;\n\t                }\n\t                return new FromObservable(ish, scheduler);\n\t            }\n\t            else if (isArray_1.isArray(ish)) {\n\t                return new ArrayObservable_1.ArrayObservable(ish, scheduler);\n\t            }\n\t            else if (isPromise_1.isPromise(ish)) {\n\t                return new PromiseObservable_1.PromiseObservable(ish, scheduler);\n\t            }\n\t            else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {\n\t                return new IteratorObservable_1.IteratorObservable(ish, scheduler);\n\t            }\n\t            else if (isArrayLike(ish)) {\n\t                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);\n\t            }\n\t        }\n\t        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n\t    };\n\t    FromObservable.prototype._subscribe = function (subscriber) {\n\t        var ish = this.ish;\n\t        var scheduler = this.scheduler;\n\t        if (scheduler == null) {\n\t            return ish[observable_1.$$observable]().subscribe(subscriber);\n\t        }\n\t        else {\n\t            return ish[observable_1.$$observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));\n\t        }\n\t    };\n\t    return FromObservable;\n\t}(Observable_1.Observable));\n\texports.FromObservable = FromObservable;\n\t//# sourceMappingURL=FromObservable.js.map\n\n/***/ },\n/* 116 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar root_1 = __webpack_require__(8);\n\tvar Observable_1 = __webpack_require__(1);\n\tvar iterator_1 = __webpack_require__(33);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar IteratorObservable = (function (_super) {\n\t    __extends(IteratorObservable, _super);\n\t    function IteratorObservable(iterator, scheduler) {\n\t        _super.call(this);\n\t        this.scheduler = scheduler;\n\t        if (iterator == null) {\n\t            throw new Error('iterator cannot be null.');\n\t        }\n\t        this.iterator = getIterator(iterator);\n\t    }\n\t    IteratorObservable.create = function (iterator, scheduler) {\n\t        return new IteratorObservable(iterator, scheduler);\n\t    };\n\t    IteratorObservable.dispatch = function (state) {\n\t        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;\n\t        if (hasError) {\n\t            subscriber.error(state.error);\n\t            return;\n\t        }\n\t        var result = iterator.next();\n\t        if (result.done) {\n\t            subscriber.complete();\n\t            return;\n\t        }\n\t        subscriber.next(result.value);\n\t        state.index = index + 1;\n\t        if (subscriber.closed) {\n\t            if (typeof iterator.return === 'function') {\n\t                iterator.return();\n\t            }\n\t            return;\n\t        }\n\t        this.schedule(state);\n\t    };\n\t    IteratorObservable.prototype._subscribe = function (subscriber) {\n\t        var index = 0;\n\t        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(IteratorObservable.dispatch, 0, {\n\t                index: index, iterator: iterator, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            do {\n\t                var result = iterator.next();\n\t                if (result.done) {\n\t                    subscriber.complete();\n\t                    break;\n\t                }\n\t                else {\n\t                    subscriber.next(result.value);\n\t                }\n\t                if (subscriber.closed) {\n\t                    if (typeof iterator.return === 'function') {\n\t                        iterator.return();\n\t                    }\n\t                    break;\n\t                }\n\t            } while (true);\n\t        }\n\t    };\n\t    return IteratorObservable;\n\t}(Observable_1.Observable));\n\texports.IteratorObservable = IteratorObservable;\n\tvar StringIterator = (function () {\n\t    function StringIterator(str, idx, len) {\n\t        if (idx === void 0) { idx = 0; }\n\t        if (len === void 0) { len = str.length; }\n\t        this.str = str;\n\t        this.idx = idx;\n\t        this.len = len;\n\t    }\n\t    StringIterator.prototype[iterator_1.$$iterator] = function () { return (this); };\n\t    StringIterator.prototype.next = function () {\n\t        return this.idx < this.len ? {\n\t            done: false,\n\t            value: this.str.charAt(this.idx++)\n\t        } : {\n\t            done: true,\n\t            value: undefined\n\t        };\n\t    };\n\t    return StringIterator;\n\t}());\n\tvar ArrayIterator = (function () {\n\t    function ArrayIterator(arr, idx, len) {\n\t        if (idx === void 0) { idx = 0; }\n\t        if (len === void 0) { len = toLength(arr); }\n\t        this.arr = arr;\n\t        this.idx = idx;\n\t        this.len = len;\n\t    }\n\t    ArrayIterator.prototype[iterator_1.$$iterator] = function () { return this; };\n\t    ArrayIterator.prototype.next = function () {\n\t        return this.idx < this.len ? {\n\t            done: false,\n\t            value: this.arr[this.idx++]\n\t        } : {\n\t            done: true,\n\t            value: undefined\n\t        };\n\t    };\n\t    return ArrayIterator;\n\t}());\n\tfunction getIterator(obj) {\n\t    var i = obj[iterator_1.$$iterator];\n\t    if (!i && typeof obj === 'string') {\n\t        return new StringIterator(obj);\n\t    }\n\t    if (!i && obj.length !== undefined) {\n\t        return new ArrayIterator(obj);\n\t    }\n\t    if (!i) {\n\t        throw new TypeError('object is not iterable');\n\t    }\n\t    return obj[iterator_1.$$iterator]();\n\t}\n\tvar maxSafeInteger = Math.pow(2, 53) - 1;\n\tfunction toLength(o) {\n\t    var len = +o.length;\n\t    if (isNaN(len)) {\n\t        return 0;\n\t    }\n\t    if (len === 0 || !numberIsFinite(len)) {\n\t        return len;\n\t    }\n\t    len = sign(len) * Math.floor(Math.abs(len));\n\t    if (len <= 0) {\n\t        return 0;\n\t    }\n\t    if (len > maxSafeInteger) {\n\t        return maxSafeInteger;\n\t    }\n\t    return len;\n\t}\n\tfunction numberIsFinite(value) {\n\t    return typeof value === 'number' && root_1.root.isFinite(value);\n\t}\n\tfunction sign(value) {\n\t    var valueAsNumber = +value;\n\t    if (valueAsNumber === 0) {\n\t        return valueAsNumber;\n\t    }\n\t    if (isNaN(valueAsNumber)) {\n\t        return valueAsNumber;\n\t    }\n\t    return valueAsNumber < 0 ? -1 : 1;\n\t}\n\t//# sourceMappingURL=IteratorObservable.js.map\n\n/***/ },\n/* 117 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar EmptyObservable_1 = __webpack_require__(16);\n\texports.empty = EmptyObservable_1.EmptyObservable.create;\n\t//# sourceMappingURL=empty.js.map\n\n/***/ },\n/* 118 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar FromObservable_1 = __webpack_require__(115);\n\texports.from = FromObservable_1.FromObservable.create;\n\t//# sourceMappingURL=from.js.map\n\n/***/ },\n/* 119 */,\n/* 120 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar PromiseObservable_1 = __webpack_require__(62);\n\texports.fromPromise = PromiseObservable_1.PromiseObservable.create;\n\t//# sourceMappingURL=fromPromise.js.map\n\n/***/ },\n/* 121 */,\n/* 122 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar isScheduler_1 = __webpack_require__(23);\n\tvar ArrayObservable_1 = __webpack_require__(15);\n\tvar mergeAll_1 = __webpack_require__(22);\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Creates an output Observable which sequentially emits all values from every\n\t * given input Observable after the current Observable.\n\t *\n\t * <span class=\"informal\">Concatenates multiple Observables together by\n\t * sequentially emitting their values, one Observable after the other.</span>\n\t *\n\t * <img src=\"./img/concat.png\" width=\"100%\">\n\t *\n\t * Joins this Observable with multiple other Observables by subscribing to them\n\t * one at a time, starting with the source, and merging their results into the\n\t * output Observable. Will wait for each Observable to complete before moving\n\t * on to the next.\n\t *\n\t * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n\t * var timer = Rx.Observable.interval(1000).take(4);\n\t * var sequence = Rx.Observable.range(1, 10);\n\t * var result = timer.concat(sequence);\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * // results in:\n\t * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n\t *\n\t * @example <caption>Concatenate 3 Observables</caption>\n\t * var timer1 = Rx.Observable.interval(1000).take(10);\n\t * var timer2 = Rx.Observable.interval(2000).take(6);\n\t * var timer3 = Rx.Observable.interval(500).take(10);\n\t * var result = timer1.concat(timer2, timer3);\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * // results in the following:\n\t * // (Prints to console sequentially)\n\t * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n\t * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n\t * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n\t *\n\t * @see {@link concatAll}\n\t * @see {@link concatMap}\n\t * @see {@link concatMapTo}\n\t *\n\t * @param {Observable} other An input Observable to concatenate after the source\n\t * Observable. More than one input Observables may be given as argument.\n\t * @param {Scheduler} [scheduler=null] An optional Scheduler to schedule each\n\t * Observable subscription on.\n\t * @return {Observable} All values of each passed Observable merged into a\n\t * single Observable, in order, in serial fashion.\n\t * @method concat\n\t * @owner Observable\n\t */\n\tfunction concat() {\n\t    var observables = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        observables[_i - 0] = arguments[_i];\n\t    }\n\t    return this.lift.call(concatStatic.apply(void 0, [this].concat(observables)));\n\t}\n\texports.concat = concat;\n\t/* tslint:enable:max-line-length */\n\t/**\n\t * Creates an output Observable which sequentially emits all values from every\n\t * given input Observable after the current Observable.\n\t *\n\t * <span class=\"informal\">Concatenates multiple Observables together by\n\t * sequentially emitting their values, one Observable after the other.</span>\n\t *\n\t * <img src=\"./img/concat.png\" width=\"100%\">\n\t *\n\t * Joins multiple Observables together by subscribing to them one at a time and\n\t * merging their results into the output Observable. Will wait for each\n\t * Observable to complete before moving on to the next.\n\t *\n\t * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n\t * var timer = Rx.Observable.interval(1000).take(4);\n\t * var sequence = Rx.Observable.range(1, 10);\n\t * var result = Rx.Observable.concat(timer, sequence);\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * // results in:\n\t * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n\t *\n\t * @example <caption>Concatenate 3 Observables</caption>\n\t * var timer1 = Rx.Observable.interval(1000).take(10);\n\t * var timer2 = Rx.Observable.interval(2000).take(6);\n\t * var timer3 = Rx.Observable.interval(500).take(10);\n\t * var result = Rx.Observable.concat(timer1, timer2, timer3);\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * // results in the following:\n\t * // (Prints to console sequentially)\n\t * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n\t * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n\t * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n\t *\n\t * @see {@link concatAll}\n\t * @see {@link concatMap}\n\t * @see {@link concatMapTo}\n\t *\n\t * @param {Observable} input1 An input Observable to concatenate with others.\n\t * @param {Observable} input2 An input Observable to concatenate with others.\n\t * More than one input Observables may be given as argument.\n\t * @param {Scheduler} [scheduler=null] An optional Scheduler to schedule each\n\t * Observable subscription on.\n\t * @return {Observable} All values of each passed Observable merged into a\n\t * single Observable, in order, in serial fashion.\n\t * @static true\n\t * @name concat\n\t * @owner Observable\n\t */\n\tfunction concatStatic() {\n\t    var observables = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        observables[_i - 0] = arguments[_i];\n\t    }\n\t    var scheduler = null;\n\t    var args = observables;\n\t    if (isScheduler_1.isScheduler(args[observables.length - 1])) {\n\t        scheduler = args.pop();\n\t    }\n\t    if (scheduler === null && observables.length === 1) {\n\t        return observables[0];\n\t    }\n\t    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));\n\t}\n\texports.concatStatic = concatStatic;\n\t//# sourceMappingURL=concat.js.map\n\n/***/ },\n/* 123 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar mergeAll_1 = __webpack_require__(22);\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Converts a higher-order Observable into a first-order Observable by\n\t * concatenating the inner Observables in order.\n\t *\n\t * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n\t * inner Observable after the other.</span>\n\t *\n\t * <img src=\"./img/concatAll.png\" width=\"100%\">\n\t *\n\t * Joins every Observable emitted by the source (a higher-order Observable), in\n\t * a serial fashion. It subscribes to each inner Observable only after the\n\t * previous inner Observable has completed, and merges all of their values into\n\t * the returned observable.\n\t *\n\t * __Warning:__ If the source Observable emits Observables quickly and\n\t * endlessly, and the inner Observables it emits generally complete slower than\n\t * the source emits, you can run into memory issues as the incoming Observables\n\t * collect in an unbounded buffer.\n\t *\n\t * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n\t * to `1`.\n\t *\n\t * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n\t * var firstOrder = higherOrder.concatAll();\n\t * firstOrder.subscribe(x => console.log(x));\n\t *\n\t * // Results in the following:\n\t * // (results are not concurrent)\n\t * // For every click on the \"document\" it will emit values 0 to 3 spaced\n\t * // on a 1000ms interval\n\t * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n\t *\n\t * @see {@link combineAll}\n\t * @see {@link concat}\n\t * @see {@link concatMap}\n\t * @see {@link concatMapTo}\n\t * @see {@link exhaust}\n\t * @see {@link mergeAll}\n\t * @see {@link switch}\n\t * @see {@link zipAll}\n\t *\n\t * @return {Observable} An Observable emitting values from all the inner\n\t * Observables concatenated.\n\t * @method concatAll\n\t * @owner Observable\n\t */\n\tfunction concatAll() {\n\t    return this.lift(new mergeAll_1.MergeAllOperator(1));\n\t}\n\texports.concatAll = concatAll;\n\t//# sourceMappingURL=concatAll.js.map\n\n/***/ },\n/* 124 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar mergeMap_1 = __webpack_require__(32);\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Projects each source value to an Observable which is merged in the output\n\t * Observable, in a serialized fashion waiting for each one to complete before\n\t * merging the next.\n\t *\n\t * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n\t * these inner Observables using {@link concatAll}.</span>\n\t *\n\t * <img src=\"./img/concatMap.png\" width=\"100%\">\n\t *\n\t * Returns an Observable that emits items based on applying a function that you\n\t * supply to each item emitted by the source Observable, where that function\n\t * returns an (so-called \"inner\") Observable. Each new inner Observable is\n\t * concatenated with the previous inner Observable.\n\t *\n\t * __Warning:__ if source values arrive endlessly and faster than their\n\t * corresponding inner Observables can complete, it will result in memory issues\n\t * as inner Observables amass in an unbounded buffer waiting for their turn to\n\t * be subscribed to.\n\t *\n\t * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n\t * to `1`.\n\t *\n\t * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * // Results in the following:\n\t * // (results are not concurrent)\n\t * // For every click on the \"document\" it will emit values 0 to 3 spaced\n\t * // on a 1000ms interval\n\t * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n\t *\n\t * @see {@link concat}\n\t * @see {@link concatAll}\n\t * @see {@link concatMapTo}\n\t * @see {@link exhaustMap}\n\t * @see {@link mergeMap}\n\t * @see {@link switchMap}\n\t *\n\t * @param {function(value: T, ?index: number): Observable} project A function\n\t * that, when applied to an item emitted by the source Observable, returns an\n\t * Observable.\n\t * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n\t * A function to produce the value on the output Observable based on the values\n\t * and the indices of the source (outer) emission and the inner Observable\n\t * emission. The arguments passed to this function are:\n\t * - `outerValue`: the value that came from the source\n\t * - `innerValue`: the value that came from the projected Observable\n\t * - `outerIndex`: the \"index\" of the value that came from the source\n\t * - `innerIndex`: the \"index\" of the value from the projected Observable\n\t * @return {Observable} an observable of values merged from the projected\n\t * Observables as they were subscribed to, one at a time. Optionally, these\n\t * values may have been projected from a passed `projectResult` argument.\n\t * @return {Observable} An Observable that emits the result of applying the\n\t * projection function (and the optional `resultSelector`) to each item emitted\n\t * by the source Observable and taking values from each projected inner\n\t * Observable sequentially.\n\t * @method concatMap\n\t * @owner Observable\n\t */\n\tfunction concatMap(project, resultSelector) {\n\t    return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));\n\t}\n\texports.concatMap = concatMap;\n\t//# sourceMappingURL=concatMap.js.map\n\n/***/ },\n/* 125 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(3);\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Perform a side effect for every emission on the source Observable, but return\n\t * an Observable that is identical to the source.\n\t *\n\t * <span class=\"informal\">Intercepts each emission on the source and runs a\n\t * function, but returns an output which is identical to the source.</span>\n\t *\n\t * <img src=\"./img/do.png\" width=\"100%\">\n\t *\n\t * Returns a mirrored Observable of the source Observable, but modified so that\n\t * the provided Observer is called to perform a side effect for every value,\n\t * error, and completion emitted by the source. Any errors that are thrown in\n\t * the aforementioned Observer or handlers are safely sent down the error path\n\t * of the output Observable.\n\t *\n\t * This operator is useful for debugging your Observables for the correct values\n\t * or performing other side effects.\n\t *\n\t * Note: this is different to a `subscribe` on the Observable. If the Observable\n\t * returned by `do` is not subscribed, the side effects specified by the\n\t * Observer will never happen. `do` therefore simply spies on existing\n\t * execution, it does not trigger an execution to happen like `subscribe` does.\n\t *\n\t * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var positions = clicks\n\t *   .do(ev => console.log(ev))\n\t *   .map(ev => ev.clientX);\n\t * positions.subscribe(x => console.log(x));\n\t *\n\t * @see {@link map}\n\t * @see {@link subscribe}\n\t *\n\t * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n\t * callback for `next`.\n\t * @param {function} [error] Callback for errors in the source.\n\t * @param {function} [complete] Callback for the completion of the source.\n\t * @return {Observable} An Observable identical to the source, but runs the\n\t * specified Observer or callback(s) for each item.\n\t * @method do\n\t * @name do\n\t * @owner Observable\n\t */\n\tfunction _do(nextOrObserver, error, complete) {\n\t    return this.lift(new DoOperator(nextOrObserver, error, complete));\n\t}\n\texports._do = _do;\n\tvar DoOperator = (function () {\n\t    function DoOperator(nextOrObserver, error, complete) {\n\t        this.nextOrObserver = nextOrObserver;\n\t        this.error = error;\n\t        this.complete = complete;\n\t    }\n\t    DoOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n\t    };\n\t    return DoOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar DoSubscriber = (function (_super) {\n\t    __extends(DoSubscriber, _super);\n\t    function DoSubscriber(destination, nextOrObserver, error, complete) {\n\t        _super.call(this, destination);\n\t        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n\t        safeSubscriber.syncErrorThrowable = true;\n\t        this.add(safeSubscriber);\n\t        this.safeSubscriber = safeSubscriber;\n\t    }\n\t    DoSubscriber.prototype._next = function (value) {\n\t        var safeSubscriber = this.safeSubscriber;\n\t        safeSubscriber.next(value);\n\t        if (safeSubscriber.syncErrorThrown) {\n\t            this.destination.error(safeSubscriber.syncErrorValue);\n\t        }\n\t        else {\n\t            this.destination.next(value);\n\t        }\n\t    };\n\t    DoSubscriber.prototype._error = function (err) {\n\t        var safeSubscriber = this.safeSubscriber;\n\t        safeSubscriber.error(err);\n\t        if (safeSubscriber.syncErrorThrown) {\n\t            this.destination.error(safeSubscriber.syncErrorValue);\n\t        }\n\t        else {\n\t            this.destination.error(err);\n\t        }\n\t    };\n\t    DoSubscriber.prototype._complete = function () {\n\t        var safeSubscriber = this.safeSubscriber;\n\t        safeSubscriber.complete();\n\t        if (safeSubscriber.syncErrorThrown) {\n\t            this.destination.error(safeSubscriber.syncErrorValue);\n\t        }\n\t        else {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    return DoSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t//# sourceMappingURL=do.js.map\n\n/***/ },\n/* 126 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(3);\n\t/**\n\t * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n\t * @param {function} predicate a function for determining if an item meets a specified condition.\n\t * @param {any} [thisArg] optional object to use for `this` in the callback\n\t * @return {Observable} an Observable of booleans that determines if all items of the source Observable meet the condition specified.\n\t * @method every\n\t * @owner Observable\n\t */\n\tfunction every(predicate, thisArg) {\n\t    return this.lift(new EveryOperator(predicate, thisArg, this));\n\t}\n\texports.every = every;\n\tvar EveryOperator = (function () {\n\t    function EveryOperator(predicate, thisArg, source) {\n\t        this.predicate = predicate;\n\t        this.thisArg = thisArg;\n\t        this.source = source;\n\t    }\n\t    EveryOperator.prototype.call = function (observer, source) {\n\t        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n\t    };\n\t    return EveryOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar EverySubscriber = (function (_super) {\n\t    __extends(EverySubscriber, _super);\n\t    function EverySubscriber(destination, predicate, thisArg, source) {\n\t        _super.call(this, destination);\n\t        this.predicate = predicate;\n\t        this.thisArg = thisArg;\n\t        this.source = source;\n\t        this.index = 0;\n\t        this.thisArg = thisArg || this;\n\t    }\n\t    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {\n\t        this.destination.next(everyValueMatch);\n\t        this.destination.complete();\n\t    };\n\t    EverySubscriber.prototype._next = function (value) {\n\t        var result = false;\n\t        try {\n\t            result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        if (!result) {\n\t            this.notifyComplete(false);\n\t        }\n\t    };\n\t    EverySubscriber.prototype._complete = function () {\n\t        this.notifyComplete(true);\n\t    };\n\t    return EverySubscriber;\n\t}(Subscriber_1.Subscriber));\n\t//# sourceMappingURL=every.js.map\n\n/***/ },\n/* 127 */,\n/* 128 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(3);\n\tvar EmptyError_1 = __webpack_require__(36);\n\t/**\n\t * Emits only the first value (or the first value that meets some condition)\n\t * emitted by the source Observable.\n\t *\n\t * <span class=\"informal\">Emits only the first value. Or emits only the first\n\t * value that passes some test.</span>\n\t *\n\t * <img src=\"./img/first.png\" width=\"100%\">\n\t *\n\t * If called with no arguments, `first` emits the first value of the source\n\t * Observable, then completes. If called with a `predicate` function, `first`\n\t * emits the first value of the source that matches the specified condition. It\n\t * may also take a `resultSelector` function to produce the output value from\n\t * the input value, and a `defaultValue` to emit in case the source completes\n\t * before it is able to emit a valid value. Throws an error if `defaultValue`\n\t * was not provided and a matching element is not found.\n\t *\n\t * @example <caption>Emit only the first click that happens on the DOM</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var result = clicks.first();\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * @example <caption>Emits the first click that happens on a DIV</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * @see {@link filter}\n\t * @see {@link find}\n\t * @see {@link take}\n\t *\n\t * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n\t * callback if the Observable completes before any `next` notification was sent.\n\t *\n\t * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n\t * An optional function called with each item to test for condition matching.\n\t * @param {function(value: T, index: number): R} [resultSelector] A function to\n\t * produce the value on the output Observable based on the values\n\t * and the indices of the source Observable. The arguments passed to this\n\t * function are:\n\t * - `value`: the value that was emitted on the source.\n\t * - `index`: the \"index\" of the value from the source.\n\t * @param {R} [defaultValue] The default value emitted in case no valid value\n\t * was found on the source.\n\t * @return {Observable<T|R>} an Observable of the first item that matches the\n\t * condition.\n\t * @method first\n\t * @owner Observable\n\t */\n\tfunction first(predicate, resultSelector, defaultValue) {\n\t    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));\n\t}\n\texports.first = first;\n\tvar FirstOperator = (function () {\n\t    function FirstOperator(predicate, resultSelector, defaultValue, source) {\n\t        this.predicate = predicate;\n\t        this.resultSelector = resultSelector;\n\t        this.defaultValue = defaultValue;\n\t        this.source = source;\n\t    }\n\t    FirstOperator.prototype.call = function (observer, source) {\n\t        return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n\t    };\n\t    return FirstOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar FirstSubscriber = (function (_super) {\n\t    __extends(FirstSubscriber, _super);\n\t    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n\t        _super.call(this, destination);\n\t        this.predicate = predicate;\n\t        this.resultSelector = resultSelector;\n\t        this.defaultValue = defaultValue;\n\t        this.source = source;\n\t        this.index = 0;\n\t        this.hasCompleted = false;\n\t        this._emitted = false;\n\t    }\n\t    FirstSubscriber.prototype._next = function (value) {\n\t        var index = this.index++;\n\t        if (this.predicate) {\n\t            this._tryPredicate(value, index);\n\t        }\n\t        else {\n\t            this._emit(value, index);\n\t        }\n\t    };\n\t    FirstSubscriber.prototype._tryPredicate = function (value, index) {\n\t        var result;\n\t        try {\n\t            result = this.predicate(value, index, this.source);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        if (result) {\n\t            this._emit(value, index);\n\t        }\n\t    };\n\t    FirstSubscriber.prototype._emit = function (value, index) {\n\t        if (this.resultSelector) {\n\t            this._tryResultSelector(value, index);\n\t            return;\n\t        }\n\t        this._emitFinal(value);\n\t    };\n\t    FirstSubscriber.prototype._tryResultSelector = function (value, index) {\n\t        var result;\n\t        try {\n\t            result = this.resultSelector(value, index);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this._emitFinal(result);\n\t    };\n\t    FirstSubscriber.prototype._emitFinal = function (value) {\n\t        var destination = this.destination;\n\t        if (!this._emitted) {\n\t            this._emitted = true;\n\t            destination.next(value);\n\t            destination.complete();\n\t            this.hasCompleted = true;\n\t        }\n\t    };\n\t    FirstSubscriber.prototype._complete = function () {\n\t        var destination = this.destination;\n\t        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {\n\t            destination.next(this.defaultValue);\n\t            destination.complete();\n\t        }\n\t        else if (!this.hasCompleted) {\n\t            destination.error(new EmptyError_1.EmptyError);\n\t        }\n\t    };\n\t    return FirstSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t//# sourceMappingURL=first.js.map\n\n/***/ },\n/* 129 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(3);\n\tvar EmptyError_1 = __webpack_require__(36);\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Returns an Observable that emits only the last item emitted by the source Observable.\n\t * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n\t * the last item from the source Observable, the resulting Observable will emit the last item\n\t * from the source Observable that satisfies the predicate.\n\t *\n\t * <img src=\"./img/last.png\" width=\"100%\">\n\t *\n\t * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n\t * callback if the Observable completes before any `next` notification was sent.\n\t * @param {function} predicate - the condition any source emitted item has to satisfy.\n\t * @return {Observable} an Observable that emits only the last item satisfying the given condition\n\t * from the source, or an NoSuchElementException if no such items are emitted.\n\t * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n\t * @method last\n\t * @owner Observable\n\t */\n\tfunction last(predicate, resultSelector, defaultValue) {\n\t    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));\n\t}\n\texports.last = last;\n\tvar LastOperator = (function () {\n\t    function LastOperator(predicate, resultSelector, defaultValue, source) {\n\t        this.predicate = predicate;\n\t        this.resultSelector = resultSelector;\n\t        this.defaultValue = defaultValue;\n\t        this.source = source;\n\t    }\n\t    LastOperator.prototype.call = function (observer, source) {\n\t        return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n\t    };\n\t    return LastOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar LastSubscriber = (function (_super) {\n\t    __extends(LastSubscriber, _super);\n\t    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n\t        _super.call(this, destination);\n\t        this.predicate = predicate;\n\t        this.resultSelector = resultSelector;\n\t        this.defaultValue = defaultValue;\n\t        this.source = source;\n\t        this.hasValue = false;\n\t        this.index = 0;\n\t        if (typeof defaultValue !== 'undefined') {\n\t            this.lastValue = defaultValue;\n\t            this.hasValue = true;\n\t        }\n\t    }\n\t    LastSubscriber.prototype._next = function (value) {\n\t        var index = this.index++;\n\t        if (this.predicate) {\n\t            this._tryPredicate(value, index);\n\t        }\n\t        else {\n\t            if (this.resultSelector) {\n\t                this._tryResultSelector(value, index);\n\t                return;\n\t            }\n\t            this.lastValue = value;\n\t            this.hasValue = true;\n\t        }\n\t    };\n\t    LastSubscriber.prototype._tryPredicate = function (value, index) {\n\t        var result;\n\t        try {\n\t            result = this.predicate(value, index, this.source);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        if (result) {\n\t            if (this.resultSelector) {\n\t                this._tryResultSelector(value, index);\n\t                return;\n\t            }\n\t            this.lastValue = value;\n\t            this.hasValue = true;\n\t        }\n\t    };\n\t    LastSubscriber.prototype._tryResultSelector = function (value, index) {\n\t        var result;\n\t        try {\n\t            result = this.resultSelector(value, index);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.lastValue = result;\n\t        this.hasValue = true;\n\t    };\n\t    LastSubscriber.prototype._complete = function () {\n\t        var destination = this.destination;\n\t        if (this.hasValue) {\n\t            destination.next(this.lastValue);\n\t            destination.complete();\n\t        }\n\t        else {\n\t            destination.error(new EmptyError_1.EmptyError);\n\t        }\n\t    };\n\t    return LastSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t//# sourceMappingURL=last.js.map\n\n/***/ },\n/* 130 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @param func\n\t * @return {Observable<R>}\n\t * @method let\n\t * @owner Observable\n\t */\n\tfunction letProto(func) {\n\t    return func(this);\n\t}\n\texports.letProto = letProto;\n\t//# sourceMappingURL=let.js.map\n\n/***/ },\n/* 131 */,\n/* 132 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar ConnectableObservable_1 = __webpack_require__(113);\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Returns an Observable that emits the results of invoking a specified selector on items\n\t * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n\t *\n\t * <img src=\"./img/multicast.png\" width=\"100%\">\n\t *\n\t * @param {Function|Subject} Factory function to create an intermediate subject through\n\t * which the source sequence's elements will be multicast to the selector function\n\t * or Subject to push source elements into.\n\t * @param {Function} Optional selector function that can use the multicasted source stream\n\t * as many times as needed, without causing multiple subscriptions to the source stream.\n\t * Subscribers to the given source will receive all notifications of the source from the\n\t * time of the subscription forward.\n\t * @return {Observable} an Observable that emits the results of invoking the selector\n\t * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n\t * the underlying stream.\n\t * @method multicast\n\t * @owner Observable\n\t */\n\tfunction multicast(subjectOrSubjectFactory, selector) {\n\t    var subjectFactory;\n\t    if (typeof subjectOrSubjectFactory === 'function') {\n\t        subjectFactory = subjectOrSubjectFactory;\n\t    }\n\t    else {\n\t        subjectFactory = function subjectFactory() {\n\t            return subjectOrSubjectFactory;\n\t        };\n\t    }\n\t    if (typeof selector === 'function') {\n\t        return this.lift(new MulticastOperator(subjectFactory, selector));\n\t    }\n\t    var connectable = Object.create(this, ConnectableObservable_1.connectableObservableDescriptor);\n\t    connectable.source = this;\n\t    connectable.subjectFactory = subjectFactory;\n\t    return connectable;\n\t}\n\texports.multicast = multicast;\n\tvar MulticastOperator = (function () {\n\t    function MulticastOperator(subjectFactory, selector) {\n\t        this.subjectFactory = subjectFactory;\n\t        this.selector = selector;\n\t    }\n\t    MulticastOperator.prototype.call = function (subscriber, source) {\n\t        var selector = this.selector;\n\t        var subject = this.subjectFactory();\n\t        var subscription = selector(subject).subscribe(subscriber);\n\t        subscription.add(source.subscribe(subject));\n\t        return subscription;\n\t    };\n\t    return MulticastOperator;\n\t}());\n\texports.MulticastOperator = MulticastOperator;\n\t//# sourceMappingURL=multicast.js.map\n\n/***/ },\n/* 133 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(3);\n\tvar Notification_1 = __webpack_require__(97);\n\t/**\n\t * @see {@link Notification}\n\t *\n\t * @param scheduler\n\t * @param delay\n\t * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n\t * @method observeOn\n\t * @owner Observable\n\t */\n\tfunction observeOn(scheduler, delay) {\n\t    if (delay === void 0) { delay = 0; }\n\t    return this.lift(new ObserveOnOperator(scheduler, delay));\n\t}\n\texports.observeOn = observeOn;\n\tvar ObserveOnOperator = (function () {\n\t    function ObserveOnOperator(scheduler, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        this.scheduler = scheduler;\n\t        this.delay = delay;\n\t    }\n\t    ObserveOnOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n\t    };\n\t    return ObserveOnOperator;\n\t}());\n\texports.ObserveOnOperator = ObserveOnOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar ObserveOnSubscriber = (function (_super) {\n\t    __extends(ObserveOnSubscriber, _super);\n\t    function ObserveOnSubscriber(destination, scheduler, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        _super.call(this, destination);\n\t        this.scheduler = scheduler;\n\t        this.delay = delay;\n\t    }\n\t    ObserveOnSubscriber.dispatch = function (arg) {\n\t        var notification = arg.notification, destination = arg.destination;\n\t        notification.observe(destination);\n\t    };\n\t    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n\t        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n\t    };\n\t    ObserveOnSubscriber.prototype._next = function (value) {\n\t        this.scheduleMessage(Notification_1.Notification.createNext(value));\n\t    };\n\t    ObserveOnSubscriber.prototype._error = function (err) {\n\t        this.scheduleMessage(Notification_1.Notification.createError(err));\n\t    };\n\t    ObserveOnSubscriber.prototype._complete = function () {\n\t        this.scheduleMessage(Notification_1.Notification.createComplete());\n\t    };\n\t    return ObserveOnSubscriber;\n\t}(Subscriber_1.Subscriber));\n\texports.ObserveOnSubscriber = ObserveOnSubscriber;\n\tvar ObserveOnMessage = (function () {\n\t    function ObserveOnMessage(notification, destination) {\n\t        this.notification = notification;\n\t        this.destination = destination;\n\t    }\n\t    return ObserveOnMessage;\n\t}());\n\texports.ObserveOnMessage = ObserveOnMessage;\n\t//# sourceMappingURL=observeOn.js.map\n\n/***/ },\n/* 134 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(3);\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Applies an accumulator function over the source Observable, and returns the\n\t * accumulated result when the source completes, given an optional seed value.\n\t *\n\t * <span class=\"informal\">Combines together all values emitted on the source,\n\t * using an accumulator function that knows how to join a new source value into\n\t * the accumulation from the past.</span>\n\t *\n\t * <img src=\"./img/reduce.png\" width=\"100%\">\n\t *\n\t * Like\n\t * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n\t * `reduce` applies an `accumulator` function against an accumulation and each\n\t * value of the source Observable (from the past) to reduce it to a single\n\t * value, emitted on the output Observable. Note that `reduce` will only emit\n\t * one value, only when the source Observable completes. It is equivalent to\n\t * applying operator {@link scan} followed by operator {@link last}.\n\t *\n\t * Returns an Observable that applies a specified `accumulator` function to each\n\t * item emitted by the source Observable. If a `seed` value is specified, then\n\t * that value will be used as the initial value for the accumulator. If no seed\n\t * value is specified, the first item of the source is used as the seed.\n\t *\n\t * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n\t * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n\t *   .takeUntil(Rx.Observable.interval(5000));\n\t * var ones = clicksInFiveSeconds.mapTo(1);\n\t * var seed = 0;\n\t * var count = ones.reduce((acc, one) => acc + one, seed);\n\t * count.subscribe(x => console.log(x));\n\t *\n\t * @see {@link count}\n\t * @see {@link expand}\n\t * @see {@link mergeScan}\n\t * @see {@link scan}\n\t *\n\t * @param {function(acc: R, value: T): R} accumulator The accumulator function\n\t * called on each source value.\n\t * @param {R} [seed] The initial accumulation value.\n\t * @return {Observable<R>} An observable of the accumulated values.\n\t * @return {Observable<R>} An Observable that emits a single value that is the\n\t * result of accumulating the values emitted by the source Observable.\n\t * @method reduce\n\t * @owner Observable\n\t */\n\tfunction reduce(accumulator, seed) {\n\t    var hasSeed = false;\n\t    // providing a seed of `undefined` *should* be valid and trigger\n\t    // hasSeed! so don't use `seed !== undefined` checks!\n\t    // For this reason, we have to check it here at the original call site\n\t    // otherwise inside Operator/Subscriber we won't know if `undefined`\n\t    // means they didn't provide anything or if they literally provided `undefined`\n\t    if (arguments.length >= 2) {\n\t        hasSeed = true;\n\t    }\n\t    return this.lift(new ReduceOperator(accumulator, seed, hasSeed));\n\t}\n\texports.reduce = reduce;\n\tvar ReduceOperator = (function () {\n\t    function ReduceOperator(accumulator, seed, hasSeed) {\n\t        if (hasSeed === void 0) { hasSeed = false; }\n\t        this.accumulator = accumulator;\n\t        this.seed = seed;\n\t        this.hasSeed = hasSeed;\n\t    }\n\t    ReduceOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new ReduceSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n\t    };\n\t    return ReduceOperator;\n\t}());\n\texports.ReduceOperator = ReduceOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar ReduceSubscriber = (function (_super) {\n\t    __extends(ReduceSubscriber, _super);\n\t    function ReduceSubscriber(destination, accumulator, seed, hasSeed) {\n\t        _super.call(this, destination);\n\t        this.accumulator = accumulator;\n\t        this.hasSeed = hasSeed;\n\t        this.hasValue = false;\n\t        this.acc = seed;\n\t    }\n\t    ReduceSubscriber.prototype._next = function (value) {\n\t        if (this.hasValue || (this.hasValue = this.hasSeed)) {\n\t            this._tryReduce(value);\n\t        }\n\t        else {\n\t            this.acc = value;\n\t            this.hasValue = true;\n\t        }\n\t    };\n\t    ReduceSubscriber.prototype._tryReduce = function (value) {\n\t        var result;\n\t        try {\n\t            result = this.accumulator(this.acc, value);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.acc = result;\n\t    };\n\t    ReduceSubscriber.prototype._complete = function () {\n\t        if (this.hasValue || this.hasSeed) {\n\t            this.destination.next(this.acc);\n\t        }\n\t        this.destination.complete();\n\t    };\n\t    return ReduceSubscriber;\n\t}(Subscriber_1.Subscriber));\n\texports.ReduceSubscriber = ReduceSubscriber;\n\t//# sourceMappingURL=reduce.js.map\n\n/***/ },\n/* 135 */,\n/* 136 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar multicast_1 = __webpack_require__(132);\n\tvar Subject_1 = __webpack_require__(14);\n\tfunction shareSubjectFactory() {\n\t    return new Subject_1.Subject();\n\t}\n\t/**\n\t * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n\t * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n\t * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n\t * This is an alias for .publish().refCount().\n\t *\n\t * <img src=\"./img/share.png\" width=\"100%\">\n\t *\n\t * @return {Observable<T>} an Observable that upon connection causes the source Observable to emit items to its Observers\n\t * @method share\n\t * @owner Observable\n\t */\n\tfunction share() {\n\t    return multicast_1.multicast.call(this, shareSubjectFactory).refCount();\n\t}\n\texports.share = share;\n\t;\n\t//# sourceMappingURL=share.js.map\n\n/***/ },\n/* 137 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar ArrayObservable_1 = __webpack_require__(15);\n\tvar ScalarObservable_1 = __webpack_require__(31);\n\tvar EmptyObservable_1 = __webpack_require__(16);\n\tvar concat_1 = __webpack_require__(122);\n\tvar isScheduler_1 = __webpack_require__(23);\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Returns an Observable that emits the items in a specified Iterable before it begins to emit items emitted by the\n\t * source Observable.\n\t *\n\t * <img src=\"./img/startWith.png\" width=\"100%\">\n\t *\n\t * @param {Values} an Iterable that contains the items you want the modified Observable to emit first.\n\t * @return {Observable} an Observable that emits the items in the specified Iterable and then emits the items\n\t * emitted by the source Observable.\n\t * @method startWith\n\t * @owner Observable\n\t */\n\tfunction startWith() {\n\t    var array = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        array[_i - 0] = arguments[_i];\n\t    }\n\t    var scheduler = array[array.length - 1];\n\t    if (isScheduler_1.isScheduler(scheduler)) {\n\t        array.pop();\n\t    }\n\t    else {\n\t        scheduler = null;\n\t    }\n\t    var len = array.length;\n\t    if (len === 1) {\n\t        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);\n\t    }\n\t    else if (len > 1) {\n\t        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);\n\t    }\n\t    else {\n\t        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);\n\t    }\n\t}\n\texports.startWith = startWith;\n\t//# sourceMappingURL=startWith.js.map\n\n/***/ }\n]);\n\n\n// WEBPACK FOOTER //\n// main.bundle.js","\"use strict\";\r\nvar core_1 = require('@angular/core');\r\nvar platform_browser_dynamic_1 = require('@angular/platform-browser-dynamic');\r\nvar app_module_1 = require('./app.module');\r\nfunction main() {\r\n    platform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(app_module_1.AppModule);\r\n}\r\nif (ENV === 'development' && HMR === true) {\r\n    if (document.readyState === 'complete') {\r\n        console.clear();\r\n        main();\r\n    }\r\n    else {\r\n        document.addEventListener('DOMContentLoaded', main);\r\n    }\r\n    module.hot.accept();\r\n}\r\nelse {\r\n    core_1.enableProdMode();\r\n    main();\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./example/boot.ts\n// module id = 0\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/* tslint:disable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): Observable} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nfunction mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n        resultSelector = null;\n    }\n    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));\n}\nexports.mergeMap = mergeMap;\nvar MergeMapOperator = (function () {\n    function MergeMapOperator(project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n    }\n    MergeMapOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));\n    };\n    return MergeMapOperator;\n}());\nexports.MergeMapOperator = MergeMapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeMapSubscriber = (function (_super) {\n    __extends(MergeMapSubscriber, _super);\n    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeMapSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            this._tryNext(value);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeMapSubscriber.prototype._tryNext = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.active++;\n        this._innerSub(result, value, index);\n    };\n    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeMapSubscriber = MergeMapSubscriber;\n//# sourceMappingURL=mergeMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/mergeMap.js\n// module id = 32\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nvar EmptyError = (function (_super) {\n    __extends(EmptyError, _super);\n    function EmptyError() {\n        var err = _super.call(this, 'no elements in sequence');\n        this.name = err.name = 'EmptyError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return EmptyError;\n}(Error));\nexports.EmptyError = EmptyError;\n//# sourceMappingURL=EmptyError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/EmptyError.js\n// module id = 36\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../util/root');\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar PromiseObservable = (function (_super) {\n    __extends(PromiseObservable, _super);\n    function PromiseObservable(promise, scheduler) {\n        _super.call(this);\n        this.promise = promise;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Converts a Promise to an Observable.\n     *\n     * <span class=\"informal\">Returns an Observable that just emits the Promise's\n     * resolved value, then completes.</span>\n     *\n     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n     * Observable. If the Promise resolves with a value, the output Observable\n     * emits that resolved value as a `next`, and then completes. If the Promise\n     * is rejected, then the output Observable emits the corresponding Error.\n     *\n     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @see {@link bindCallback}\n     * @see {@link from}\n     *\n     * @param {Promise<T>} promise The promise to be converted.\n     * @param {Scheduler} [scheduler] An optional Scheduler to use for scheduling\n     * the delivery of the resolved value (or the rejection).\n     * @return {Observable<T>} An Observable which wraps the Promise.\n     * @static true\n     * @name fromPromise\n     * @owner Observable\n     */\n    PromiseObservable.create = function (promise, scheduler) {\n        return new PromiseObservable(promise, scheduler);\n    };\n    PromiseObservable.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var promise = this.promise;\n        var scheduler = this.scheduler;\n        if (scheduler == null) {\n            if (this._isScalar) {\n                if (!subscriber.closed) {\n                    subscriber.next(this.value);\n                    subscriber.complete();\n                }\n            }\n            else {\n                promise.then(function (value) {\n                    _this.value = value;\n                    _this._isScalar = true;\n                    if (!subscriber.closed) {\n                        subscriber.next(value);\n                        subscriber.complete();\n                    }\n                }, function (err) {\n                    if (!subscriber.closed) {\n                        subscriber.error(err);\n                    }\n                })\n                    .then(null, function (err) {\n                    // escape the promise trap, throw unhandled errors\n                    root_1.root.setTimeout(function () { throw err; });\n                });\n            }\n        }\n        else {\n            if (this._isScalar) {\n                if (!subscriber.closed) {\n                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });\n                }\n            }\n            else {\n                promise.then(function (value) {\n                    _this.value = value;\n                    _this._isScalar = true;\n                    if (!subscriber.closed) {\n                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));\n                    }\n                }, function (err) {\n                    if (!subscriber.closed) {\n                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));\n                    }\n                })\n                    .then(null, function (err) {\n                    // escape the promise trap, throw unhandled errors\n                    root_1.root.setTimeout(function () { throw err; });\n                });\n            }\n        }\n    };\n    return PromiseObservable;\n}(Observable_1.Observable));\nexports.PromiseObservable = PromiseObservable;\nfunction dispatchNext(arg) {\n    var value = arg.value, subscriber = arg.subscriber;\n    if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n    }\n}\nfunction dispatchError(arg) {\n    var err = arg.err, subscriber = arg.subscriber;\n    if (!subscriber.closed) {\n        subscriber.error(err);\n    }\n}\n//# sourceMappingURL=PromiseObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/PromiseObservable.js\n// module id = 62\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} an observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @method catch\n * @name catch\n * @owner Observable\n */\nfunction _catch(selector) {\n    var operator = new CatchOperator(selector);\n    var caught = this.lift(operator);\n    return (operator.caught = caught);\n}\nexports._catch = _catch;\nvar CatchOperator = (function () {\n    function CatchOperator(selector) {\n        this.selector = selector;\n    }\n    CatchOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n    };\n    return CatchOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CatchSubscriber = (function (_super) {\n    __extends(CatchSubscriber, _super);\n    function CatchSubscriber(destination, selector, caught) {\n        _super.call(this, destination);\n        this.selector = selector;\n        this.caught = caught;\n    }\n    // NOTE: overriding `error` instead of `_error` because we don't want\n    // to have this flag this subscriber as `isStopped`.\n    CatchSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var result = void 0;\n            try {\n                result = this.selector(err, this.caught);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.unsubscribe();\n            this.destination.remove(this);\n            subscribeToResult_1.subscribeToResult(this, result);\n        }\n    };\n    return CatchSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=catch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/catch.js\n// module id = 64\n// module chunks = 2","/**\n * @license Angular v3.4.1\n * (c) 2010-2016 Google, Inc. https://angular.io/\n * License: MIT\n */(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('rxjs/BehaviorSubject'), require('rxjs/Subject'), require('rxjs/observable/from'), require('rxjs/observable/of'), require('rxjs/operator/concatMap'), require('rxjs/operator/every'), require('rxjs/operator/first'), require('rxjs/operator/map'), require('rxjs/operator/mergeMap'), require('rxjs/operator/reduce'), require('rxjs/Observable'), require('rxjs/operator/catch'), require('rxjs/operator/concatAll'), require('rxjs/util/EmptyError'), require('rxjs/observable/fromPromise'), require('rxjs/operator/last'), require('rxjs/operator/mergeAll'), require('@angular/platform-browser'), require('rxjs/operator/filter')) :\n  typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/core', 'rxjs/BehaviorSubject', 'rxjs/Subject', 'rxjs/observable/from', 'rxjs/observable/of', 'rxjs/operator/concatMap', 'rxjs/operator/every', 'rxjs/operator/first', 'rxjs/operator/map', 'rxjs/operator/mergeMap', 'rxjs/operator/reduce', 'rxjs/Observable', 'rxjs/operator/catch', 'rxjs/operator/concatAll', 'rxjs/util/EmptyError', 'rxjs/observable/fromPromise', 'rxjs/operator/last', 'rxjs/operator/mergeAll', '@angular/platform-browser', 'rxjs/operator/filter'], factory) :\n  (factory((global.ng = global.ng || {}, global.ng.router = global.ng.router || {}),global.ng.common,global.ng.core,global.Rx,global.Rx,global.Rx.Observable,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.ng.platformBrowser,global.Rx.Observable.prototype));\n}(this, function (exports,_angular_common,_angular_core,rxjs_BehaviorSubject,rxjs_Subject,rxjs_observable_from,rxjs_observable_of,rxjs_operator_concatMap,rxjs_operator_every,rxjs_operator_first,rxjs_operator_map,rxjs_operator_mergeMap,rxjs_operator_reduce,rxjs_Observable,rxjs_operator_catch,rxjs_operator_concatAll,rxjs_util_EmptyError,rxjs_observable_fromPromise,l,rxjs_operator_mergeAll,_angular_platformBrowser,rxjs_operator_filter) { 'use strict';\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  /**\n   * @whatItDoes Name of the primary outlet.\n   *\n   * @stable\n   */\n  var /** @type {?} */ PRIMARY_OUTLET = 'primary';\n  var NavigationCancelingError = (function (_super) {\n      __extends(NavigationCancelingError, _super);\n      /**\n       * @param {?} message\n       */\n      function NavigationCancelingError(message) {\n          _super.call(this, message);\n          this.message = message;\n          this.stack = (new Error(message)).stack;\n      }\n      /**\n       * @return {?}\n       */\n      NavigationCancelingError.prototype.toString = function () { return this.message; };\n      return NavigationCancelingError;\n  }(Error));\n  /**\n   * @param {?} segments\n   * @param {?} segmentGroup\n   * @param {?} route\n   * @return {?}\n   */\n  function defaultUrlMatcher(segments, segmentGroup, route) {\n      var /** @type {?} */ path = route.path;\n      var /** @type {?} */ parts = path.split('/');\n      var /** @type {?} */ posParams = {};\n      var /** @type {?} */ consumed = [];\n      var /** @type {?} */ currentIndex = 0;\n      for (var /** @type {?} */ i = 0; i < parts.length; ++i) {\n          if (currentIndex >= segments.length)\n              return null;\n          var /** @type {?} */ current = segments[currentIndex];\n          var /** @type {?} */ p = parts[i];\n          var /** @type {?} */ isPosParam = p.startsWith(':');\n          if (!isPosParam && p !== current.path)\n              return null;\n          if (isPosParam) {\n              posParams[p.substring(1)] = current;\n          }\n          consumed.push(current);\n          currentIndex++;\n      }\n      if (route.pathMatch === 'full' &&\n          (segmentGroup.hasChildren() || currentIndex < segments.length)) {\n          return null;\n      }\n      else {\n          return { consumed: consumed, posParams: posParams };\n      }\n  }\n\n  /**\n   * @param {?} a\n   * @param {?} b\n   * @return {?}\n   */\n  function shallowEqualArrays(a, b) {\n      if (a.length !== b.length)\n          return false;\n      for (var /** @type {?} */ i = 0; i < a.length; ++i) {\n          if (!shallowEqual(a[i], b[i]))\n              return false;\n      }\n      return true;\n  }\n  /**\n   * @param {?} a\n   * @param {?} b\n   * @return {?}\n   */\n  function shallowEqual(a, b) {\n      var /** @type {?} */ k1 = Object.keys(a);\n      var /** @type {?} */ k2 = Object.keys(b);\n      if (k1.length != k2.length) {\n          return false;\n      }\n      var /** @type {?} */ key;\n      for (var /** @type {?} */ i = 0; i < k1.length; i++) {\n          key = k1[i];\n          if (a[key] !== b[key]) {\n              return false;\n          }\n      }\n      return true;\n  }\n  /**\n   * @param {?} a\n   * @return {?}\n   */\n  function flatten(a) {\n      var /** @type {?} */ target = [];\n      for (var /** @type {?} */ i = 0; i < a.length; ++i) {\n          for (var /** @type {?} */ j = 0; j < a[i].length; ++j) {\n              target.push(a[i][j]);\n          }\n      }\n      return target;\n  }\n  /**\n   * @param {?} a\n   * @return {?}\n   */\n  function last(a) {\n      return a.length > 0 ? a[a.length - 1] : null;\n  }\n  /**\n   * @param {?} m1\n   * @param {?} m2\n   * @return {?}\n   */\n  function merge(m1, m2) {\n      var /** @type {?} */ m = {};\n      for (var attr in m1) {\n          if (m1.hasOwnProperty(attr)) {\n              m[attr] = m1[attr];\n          }\n      }\n      for (var attr in m2) {\n          if (m2.hasOwnProperty(attr)) {\n              m[attr] = m2[attr];\n          }\n      }\n      return m;\n  }\n  /**\n   * @param {?} map\n   * @param {?} callback\n   * @return {?}\n   */\n  function forEach(map, callback) {\n      for (var prop in map) {\n          if (map.hasOwnProperty(prop)) {\n              callback(map[prop], prop);\n          }\n      }\n  }\n  /**\n   * @param {?} obj\n   * @param {?} fn\n   * @return {?}\n   */\n  function waitForMap(obj, fn) {\n      var /** @type {?} */ waitFor = [];\n      var /** @type {?} */ res = {};\n      forEach(obj, function (a, k) {\n          if (k === PRIMARY_OUTLET) {\n              waitFor.push(rxjs_operator_map.map.call(fn(k, a), function (_) {\n                  res[k] = _;\n                  return _;\n              }));\n          }\n      });\n      forEach(obj, function (a, k) {\n          if (k !== PRIMARY_OUTLET) {\n              waitFor.push(rxjs_operator_map.map.call(fn(k, a), function (_) {\n                  res[k] = _;\n                  return _;\n              }));\n          }\n      });\n      if (waitFor.length > 0) {\n          var /** @type {?} */ concatted$ = rxjs_operator_concatAll.concatAll.call(rxjs_observable_of.of.apply(void 0, waitFor));\n          var /** @type {?} */ last$ = l.last.call(concatted$);\n          return rxjs_operator_map.map.call(last$, function () { return res; });\n      }\n      return rxjs_observable_of.of(res);\n  }\n  /**\n   * @param {?} observables\n   * @return {?}\n   */\n  function andObservables(observables) {\n      var /** @type {?} */ merged$ = rxjs_operator_mergeAll.mergeAll.call(observables);\n      return rxjs_operator_every.every.call(merged$, function (result) { return result === true; });\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  function wrapIntoObservable(value) {\n      if (value instanceof rxjs_Observable.Observable) {\n          return value;\n      }\n      if (value instanceof Promise) {\n          return rxjs_observable_fromPromise.fromPromise(value);\n      }\n      return rxjs_observable_of.of(value);\n  }\n\n  /**\n   * @experimental\n   */\n  var /** @type {?} */ ROUTES = new _angular_core.OpaqueToken('ROUTES');\n  var LoadedRouterConfig = (function () {\n      /**\n       * @param {?} routes\n       * @param {?} injector\n       * @param {?} factoryResolver\n       * @param {?} injectorFactory\n       */\n      function LoadedRouterConfig(routes, injector, factoryResolver, injectorFactory) {\n          this.routes = routes;\n          this.injector = injector;\n          this.factoryResolver = factoryResolver;\n          this.injectorFactory = injectorFactory;\n      }\n      return LoadedRouterConfig;\n  }());\n  var RouterConfigLoader = (function () {\n      /**\n       * @param {?} loader\n       * @param {?} compiler\n       */\n      function RouterConfigLoader(loader, compiler) {\n          this.loader = loader;\n          this.compiler = compiler;\n      }\n      /**\n       * @param {?} parentInjector\n       * @param {?} loadChildren\n       * @return {?}\n       */\n      RouterConfigLoader.prototype.load = function (parentInjector, loadChildren) {\n          return rxjs_operator_map.map.call(this.loadModuleFactory(loadChildren), function (r) {\n              var /** @type {?} */ ref = r.create(parentInjector);\n              var /** @type {?} */ injectorFactory = function (parent) { return r.create(parent).injector; };\n              return new LoadedRouterConfig(flatten(ref.injector.get(ROUTES)), ref.injector, ref.componentFactoryResolver, injectorFactory);\n          });\n      };\n      /**\n       * @param {?} loadChildren\n       * @return {?}\n       */\n      RouterConfigLoader.prototype.loadModuleFactory = function (loadChildren) {\n          var _this = this;\n          if (typeof loadChildren === 'string') {\n              return rxjs_observable_fromPromise.fromPromise(this.loader.load(loadChildren));\n          }\n          else {\n              var /** @type {?} */ offlineMode_1 = this.compiler instanceof _angular_core.Compiler;\n              return rxjs_operator_mergeMap.mergeMap.call(wrapIntoObservable(loadChildren()), function (t) { return offlineMode_1 ? rxjs_observable_of.of(/** @type {?} */ (t)) : rxjs_observable_fromPromise.fromPromise(_this.compiler.compileModuleAsync(t)); });\n          }\n      };\n      return RouterConfigLoader;\n  }());\n\n  /**\n   * @return {?}\n   */\n  function createEmptyUrlTree() {\n      return new UrlTree(new UrlSegmentGroup([], {}), {}, null);\n  }\n  /**\n   * @param {?} container\n   * @param {?} containee\n   * @param {?} exact\n   * @return {?}\n   */\n  function containsTree(container, containee, exact) {\n      if (exact) {\n          return equalQueryParams(container.queryParams, containee.queryParams) &&\n              equalSegmentGroups(container.root, containee.root);\n      }\n      return containsQueryParams(container.queryParams, containee.queryParams) &&\n          containsSegmentGroup(container.root, containee.root);\n  }\n  /**\n   * @param {?} container\n   * @param {?} containee\n   * @return {?}\n   */\n  function equalQueryParams(container, containee) {\n      return shallowEqual(container, containee);\n  }\n  /**\n   * @param {?} container\n   * @param {?} containee\n   * @return {?}\n   */\n  function equalSegmentGroups(container, containee) {\n      if (!equalPath(container.segments, containee.segments))\n          return false;\n      if (container.numberOfChildren !== containee.numberOfChildren)\n          return false;\n      for (var c in containee.children) {\n          if (!container.children[c])\n              return false;\n          if (!equalSegmentGroups(container.children[c], containee.children[c]))\n              return false;\n      }\n      return true;\n  }\n  /**\n   * @param {?} container\n   * @param {?} containee\n   * @return {?}\n   */\n  function containsQueryParams(container, containee) {\n      return Object.keys(containee) <= Object.keys(container) &&\n          Object.keys(containee).every(function (key) { return containee[key] === container[key]; });\n  }\n  /**\n   * @param {?} container\n   * @param {?} containee\n   * @return {?}\n   */\n  function containsSegmentGroup(container, containee) {\n      return containsSegmentGroupHelper(container, containee, containee.segments);\n  }\n  /**\n   * @param {?} container\n   * @param {?} containee\n   * @param {?} containeePaths\n   * @return {?}\n   */\n  function containsSegmentGroupHelper(container, containee, containeePaths) {\n      if (container.segments.length > containeePaths.length) {\n          var /** @type {?} */ current = container.segments.slice(0, containeePaths.length);\n          if (!equalPath(current, containeePaths))\n              return false;\n          if (containee.hasChildren())\n              return false;\n          return true;\n      }\n      else if (container.segments.length === containeePaths.length) {\n          if (!equalPath(container.segments, containeePaths))\n              return false;\n          for (var c in containee.children) {\n              if (!container.children[c])\n                  return false;\n              if (!containsSegmentGroup(container.children[c], containee.children[c]))\n                  return false;\n          }\n          return true;\n      }\n      else {\n          var /** @type {?} */ current = containeePaths.slice(0, container.segments.length);\n          var /** @type {?} */ next = containeePaths.slice(container.segments.length);\n          if (!equalPath(container.segments, current))\n              return false;\n          if (!container.children[PRIMARY_OUTLET])\n              return false;\n          return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);\n      }\n  }\n  /**\n   *  *\n    * *\n    * ```\n    * class MyComponent {\n    * constructor(router: Router) {\n    * const tree: UrlTree =\n    * router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n    * const f = tree.fragment; // return 'fragment'\n    * const q = tree.queryParams; // returns {debug: 'true'}\n    * const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n    * const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n    * g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n    * g.children['support'].segments; // return 1 segment 'help'\n    * }\n    * }\n    * ```\n    * *\n    * *\n    * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n    * serialized tree.\n    * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n    * *\n   */\n  var UrlTree = (function () {\n      /**\n       * @param {?} root\n       * @param {?} queryParams\n       * @param {?} fragment\n       */\n      function UrlTree(root, queryParams, fragment) {\n          this.root = root;\n          this.queryParams = queryParams;\n          this.fragment = fragment;\n      }\n      /**\n       * @return {?}\n       */\n      UrlTree.prototype.toString = function () { return new DefaultUrlSerializer().serialize(this); };\n      return UrlTree;\n  }());\n  /**\n   *  *\n    * See {@link UrlTree} for more information.\n    * *\n   */\n  var UrlSegmentGroup = (function () {\n      /**\n       * @param {?} segments\n       * @param {?} children\n       */\n      function UrlSegmentGroup(segments, children) {\n          var _this = this;\n          this.segments = segments;\n          this.children = children;\n          /** The parent node in the url tree */\n          this.parent = null;\n          forEach(children, function (v, k) { return v.parent = _this; });\n      }\n      /**\n       *  Wether the segment has child segments\n       * @return {?}\n       */\n      UrlSegmentGroup.prototype.hasChildren = function () { return this.numberOfChildren > 0; };\n      Object.defineProperty(UrlSegmentGroup.prototype, \"numberOfChildren\", {\n          /**\n           *  Number of child segments\n           * @return {?}\n           */\n          get: function () { return Object.keys(this.children).length; },\n          enumerable: true,\n          configurable: true\n      });\n      /**\n       * @return {?}\n       */\n      UrlSegmentGroup.prototype.toString = function () { return serializePaths(this); };\n      return UrlSegmentGroup;\n  }());\n  /**\n   *  *\n    * *\n    * ```\n    * class MyComponent {\n    * constructor(router: Router) {\n    * const tree: UrlTree = router.parseUrl('/team;id=33');\n    * const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n    * const s: UrlSegment[] = g.segments;\n    * s[0].path; // returns 'team'\n    * s[0].parameters; // returns {id: 33}\n    * }\n    * }\n    * ```\n    * *\n    * *\n    * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n    * parameters associated with the segment.\n    * *\n   */\n  var UrlSegment = (function () {\n      /**\n       * @param {?} path\n       * @param {?} parameters\n       */\n      function UrlSegment(path, parameters) {\n          this.path = path;\n          this.parameters = parameters;\n      }\n      /**\n       * @return {?}\n       */\n      UrlSegment.prototype.toString = function () { return serializePath(this); };\n      return UrlSegment;\n  }());\n  /**\n   * @param {?} a\n   * @param {?} b\n   * @return {?}\n   */\n  function equalSegments(a, b) {\n      if (a.length !== b.length)\n          return false;\n      for (var /** @type {?} */ i = 0; i < a.length; ++i) {\n          if (a[i].path !== b[i].path)\n              return false;\n          if (!shallowEqual(a[i].parameters, b[i].parameters))\n              return false;\n      }\n      return true;\n  }\n  /**\n   * @param {?} a\n   * @param {?} b\n   * @return {?}\n   */\n  function equalPath(a, b) {\n      if (a.length !== b.length)\n          return false;\n      for (var /** @type {?} */ i = 0; i < a.length; ++i) {\n          if (a[i].path !== b[i].path)\n              return false;\n      }\n      return true;\n  }\n  /**\n   * @param {?} segment\n   * @param {?} fn\n   * @return {?}\n   */\n  function mapChildrenIntoArray(segment, fn) {\n      var /** @type {?} */ res = [];\n      forEach(segment.children, function (child, childOutlet) {\n          if (childOutlet === PRIMARY_OUTLET) {\n              res = res.concat(fn(child, childOutlet));\n          }\n      });\n      forEach(segment.children, function (child, childOutlet) {\n          if (childOutlet !== PRIMARY_OUTLET) {\n              res = res.concat(fn(child, childOutlet));\n          }\n      });\n      return res;\n  }\n  /**\n   *  *\n    * make all URLs case insensitive by providing a custom UrlSerializer.\n    * *\n    * See {@link DefaultUrlSerializer} for an example of a URL serializer.\n    * *\n   * @abstract\n   */\n  var UrlSerializer = (function () {\n      function UrlSerializer() {\n      }\n      /**\n       *  Parse a url into a {@link UrlTree}\n       * @abstract\n       * @param {?} url\n       * @return {?}\n       */\n      UrlSerializer.prototype.parse = function (url) { };\n      /**\n       *  Converts a {@link UrlTree} into a url\n       * @abstract\n       * @param {?} tree\n       * @return {?}\n       */\n      UrlSerializer.prototype.serialize = function (tree) { };\n      return UrlSerializer;\n  }());\n  /**\n   *  *\n    * *\n    * Example URLs:\n    * *\n    * ```\n    * /inbox/33(popup:compose)\n    * /inbox/33;open=true/messages/44\n    * ```\n    * *\n    * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n    * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n    * specify route specific parameters.\n    * *\n   */\n  var DefaultUrlSerializer = (function () {\n      function DefaultUrlSerializer() {\n      }\n      /**\n       *  Parses a url into a {@link UrlTree}\n       * @param {?} url\n       * @return {?}\n       */\n      DefaultUrlSerializer.prototype.parse = function (url) {\n          var /** @type {?} */ p = new UrlParser(url);\n          return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n      };\n      /**\n       *  Converts a {@link UrlTree} into a url\n       * @param {?} tree\n       * @return {?}\n       */\n      DefaultUrlSerializer.prototype.serialize = function (tree) {\n          var /** @type {?} */ segment = \"/\" + serializeSegment(tree.root, true);\n          var /** @type {?} */ query = serializeQueryParams(tree.queryParams);\n          var /** @type {?} */ fragment = tree.fragment !== null && tree.fragment !== undefined ? \"#\" + encodeURI(tree.fragment) : '';\n          return \"\" + segment + query + fragment;\n      };\n      return DefaultUrlSerializer;\n  }());\n  /**\n   * @param {?} segment\n   * @return {?}\n   */\n  function serializePaths(segment) {\n      return segment.segments.map(function (p) { return serializePath(p); }).join('/');\n  }\n  /**\n   * @param {?} segment\n   * @param {?} root\n   * @return {?}\n   */\n  function serializeSegment(segment, root) {\n      if (segment.hasChildren() && root) {\n          var /** @type {?} */ primary = segment.children[PRIMARY_OUTLET] ?\n              serializeSegment(segment.children[PRIMARY_OUTLET], false) :\n              '';\n          var /** @type {?} */ children_1 = [];\n          forEach(segment.children, function (v, k) {\n              if (k !== PRIMARY_OUTLET) {\n                  children_1.push(k + \":\" + serializeSegment(v, false));\n              }\n          });\n          if (children_1.length > 0) {\n              return primary + \"(\" + children_1.join('//') + \")\";\n          }\n          else {\n              return \"\" + primary;\n          }\n      }\n      else if (segment.hasChildren() && !root) {\n          var /** @type {?} */ children = mapChildrenIntoArray(segment, function (v, k) {\n              if (k === PRIMARY_OUTLET) {\n                  return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n              }\n              else {\n                  return [(k + \":\" + serializeSegment(v, false))];\n              }\n          });\n          return serializePaths(segment) + \"/(\" + children.join('//') + \")\";\n      }\n      else {\n          return serializePaths(segment);\n      }\n  }\n  /**\n   * @param {?} s\n   * @return {?}\n   */\n  function encode(s) {\n      return encodeURIComponent(s);\n  }\n  /**\n   * @param {?} s\n   * @return {?}\n   */\n  function decode(s) {\n      return decodeURIComponent(s);\n  }\n  /**\n   * @param {?} path\n   * @return {?}\n   */\n  function serializePath(path) {\n      return \"\" + encode(path.path) + serializeParams(path.parameters);\n  }\n  /**\n   * @param {?} params\n   * @return {?}\n   */\n  function serializeParams(params) {\n      return pairs(params).map(function (p) { return (\";\" + encode(p.first) + \"=\" + encode(p.second)); }).join('');\n  }\n  /**\n   * @param {?} params\n   * @return {?}\n   */\n  function serializeQueryParams(params) {\n      var /** @type {?} */ strParams = Object.keys(params).map(function (name) {\n          var /** @type {?} */ value = params[name];\n          return Array.isArray(value) ? value.map(function (v) { return (encode(name) + \"=\" + encode(v)); }).join('&') :\n              encode(name) + \"=\" + encode(value);\n      });\n      return strParams.length ? \"?\" + strParams.join(\"&\") : '';\n  }\n  var Pair = (function () {\n      /**\n       * @param {?} first\n       * @param {?} second\n       */\n      function Pair(first, second) {\n          this.first = first;\n          this.second = second;\n      }\n      return Pair;\n  }());\n  /**\n   * @param {?} obj\n   * @return {?}\n   */\n  function pairs(obj) {\n      var /** @type {?} */ res = [];\n      for (var prop in obj) {\n          if (obj.hasOwnProperty(prop)) {\n              res.push(new Pair(prop, obj[prop]));\n          }\n      }\n      return res;\n  }\n  var /** @type {?} */ SEGMENT_RE = /^[^\\/()?;=&#]+/;\n  /**\n   * @param {?} str\n   * @return {?}\n   */\n  function matchSegments(str) {\n      SEGMENT_RE.lastIndex = 0;\n      var /** @type {?} */ match = str.match(SEGMENT_RE);\n      return match ? match[0] : '';\n  }\n  var /** @type {?} */ QUERY_PARAM_RE = /^[^=?&#]+/;\n  /**\n   * @param {?} str\n   * @return {?}\n   */\n  function matchQueryParams(str) {\n      QUERY_PARAM_RE.lastIndex = 0;\n      var /** @type {?} */ match = str.match(SEGMENT_RE);\n      return match ? match[0] : '';\n  }\n  var /** @type {?} */ QUERY_PARAM_VALUE_RE = /^[^?&#]+/;\n  /**\n   * @param {?} str\n   * @return {?}\n   */\n  function matchUrlQueryParamValue(str) {\n      QUERY_PARAM_VALUE_RE.lastIndex = 0;\n      var /** @type {?} */ match = str.match(QUERY_PARAM_VALUE_RE);\n      return match ? match[0] : '';\n  }\n  var UrlParser = (function () {\n      /**\n       * @param {?} url\n       */\n      function UrlParser(url) {\n          this.url = url;\n          this.remaining = url;\n      }\n      /**\n       * @param {?} str\n       * @return {?}\n       */\n      UrlParser.prototype.peekStartsWith = function (str) { return this.remaining.startsWith(str); };\n      /**\n       * @param {?} str\n       * @return {?}\n       */\n      UrlParser.prototype.capture = function (str) {\n          if (!this.remaining.startsWith(str)) {\n              throw new Error(\"Expected \\\"\" + str + \"\\\".\");\n          }\n          this.remaining = this.remaining.substring(str.length);\n      };\n      /**\n       * @return {?}\n       */\n      UrlParser.prototype.parseRootSegment = function () {\n          if (this.remaining.startsWith('/')) {\n              this.capture('/');\n          }\n          if (this.remaining === '' || this.remaining.startsWith('?') || this.remaining.startsWith('#')) {\n              return new UrlSegmentGroup([], {});\n          }\n          return new UrlSegmentGroup([], this.parseChildren());\n      };\n      /**\n       * @return {?}\n       */\n      UrlParser.prototype.parseChildren = function () {\n          if (this.remaining.length == 0) {\n              return {};\n          }\n          if (this.peekStartsWith('/')) {\n              this.capture('/');\n          }\n          var /** @type {?} */ paths = [];\n          if (!this.peekStartsWith('(')) {\n              paths.push(this.parseSegments());\n          }\n          while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n              this.capture('/');\n              paths.push(this.parseSegments());\n          }\n          var /** @type {?} */ children = {};\n          if (this.peekStartsWith('/(')) {\n              this.capture('/');\n              children = this.parseParens(true);\n          }\n          var /** @type {?} */ res = {};\n          if (this.peekStartsWith('(')) {\n              res = this.parseParens(false);\n          }\n          if (paths.length > 0 || Object.keys(children).length > 0) {\n              res[PRIMARY_OUTLET] = new UrlSegmentGroup(paths, children);\n          }\n          return res;\n      };\n      /**\n       * @return {?}\n       */\n      UrlParser.prototype.parseSegments = function () {\n          var /** @type {?} */ path = matchSegments(this.remaining);\n          if (path === '' && this.peekStartsWith(';')) {\n              throw new Error(\"Empty path url segment cannot have parameters: '\" + this.remaining + \"'.\");\n          }\n          this.capture(path);\n          var /** @type {?} */ matrixParams = {};\n          if (this.peekStartsWith(';')) {\n              matrixParams = this.parseMatrixParams();\n          }\n          return new UrlSegment(decode(path), matrixParams);\n      };\n      /**\n       * @return {?}\n       */\n      UrlParser.prototype.parseQueryParams = function () {\n          var /** @type {?} */ params = {};\n          if (this.peekStartsWith('?')) {\n              this.capture('?');\n              this.parseQueryParam(params);\n              while (this.remaining.length > 0 && this.peekStartsWith('&')) {\n                  this.capture('&');\n                  this.parseQueryParam(params);\n              }\n          }\n          return params;\n      };\n      /**\n       * @return {?}\n       */\n      UrlParser.prototype.parseFragment = function () {\n          if (this.peekStartsWith('#')) {\n              return decodeURI(this.remaining.substring(1));\n          }\n          return null;\n      };\n      /**\n       * @return {?}\n       */\n      UrlParser.prototype.parseMatrixParams = function () {\n          var /** @type {?} */ params = {};\n          while (this.remaining.length > 0 && this.peekStartsWith(';')) {\n              this.capture(';');\n              this.parseParam(params);\n          }\n          return params;\n      };\n      /**\n       * @param {?} params\n       * @return {?}\n       */\n      UrlParser.prototype.parseParam = function (params) {\n          var /** @type {?} */ key = matchSegments(this.remaining);\n          if (!key) {\n              return;\n          }\n          this.capture(key);\n          var /** @type {?} */ value = '';\n          if (this.peekStartsWith('=')) {\n              this.capture('=');\n              var /** @type {?} */ valueMatch = matchSegments(this.remaining);\n              if (valueMatch) {\n                  value = valueMatch;\n                  this.capture(value);\n              }\n          }\n          params[decode(key)] = decode(value);\n      };\n      /**\n       * @param {?} params\n       * @return {?}\n       */\n      UrlParser.prototype.parseQueryParam = function (params) {\n          var /** @type {?} */ key = matchQueryParams(this.remaining);\n          if (!key) {\n              return;\n          }\n          this.capture(key);\n          var /** @type {?} */ value = '';\n          if (this.peekStartsWith('=')) {\n              this.capture('=');\n              var /** @type {?} */ valueMatch = matchUrlQueryParamValue(this.remaining);\n              if (valueMatch) {\n                  value = valueMatch;\n                  this.capture(value);\n              }\n          }\n          var /** @type {?} */ decodedKey = decode(key);\n          var /** @type {?} */ decodedVal = decode(value);\n          if (params.hasOwnProperty(decodedKey)) {\n              // Append to existing values\n              var /** @type {?} */ currentVal = params[decodedKey];\n              if (!Array.isArray(currentVal)) {\n                  currentVal = [currentVal];\n                  params[decodedKey] = currentVal;\n              }\n              currentVal.push(decodedVal);\n          }\n          else {\n              // Create a new value\n              params[decodedKey] = decodedVal;\n          }\n      };\n      /**\n       * @param {?} allowPrimary\n       * @return {?}\n       */\n      UrlParser.prototype.parseParens = function (allowPrimary) {\n          var /** @type {?} */ segments = {};\n          this.capture('(');\n          while (!this.peekStartsWith(')') && this.remaining.length > 0) {\n              var /** @type {?} */ path = matchSegments(this.remaining);\n              var /** @type {?} */ next = this.remaining[path.length];\n              // if is is not one of these characters, then the segment was unescaped\n              // or the group was not closed\n              if (next !== '/' && next !== ')' && next !== ';') {\n                  throw new Error(\"Cannot parse url '\" + this.url + \"'\");\n              }\n              var /** @type {?} */ outletName = void 0;\n              if (path.indexOf(':') > -1) {\n                  outletName = path.substr(0, path.indexOf(':'));\n                  this.capture(outletName);\n                  this.capture(':');\n              }\n              else if (allowPrimary) {\n                  outletName = PRIMARY_OUTLET;\n              }\n              var /** @type {?} */ children = this.parseChildren();\n              segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :\n                  new UrlSegmentGroup([], children);\n              if (this.peekStartsWith('//')) {\n                  this.capture('//');\n              }\n          }\n          this.capture(')');\n          return segments;\n      };\n      return UrlParser;\n  }());\n\n  var NoMatch = (function () {\n      /**\n       * @param {?=} segmentGroup\n       */\n      function NoMatch(segmentGroup) {\n          if (segmentGroup === void 0) { segmentGroup = null; }\n          this.segmentGroup = segmentGroup;\n      }\n      return NoMatch;\n  }());\n  var AbsoluteRedirect = (function () {\n      /**\n       * @param {?} urlTree\n       */\n      function AbsoluteRedirect(urlTree) {\n          this.urlTree = urlTree;\n      }\n      return AbsoluteRedirect;\n  }());\n  /**\n   * @param {?} segmentGroup\n   * @return {?}\n   */\n  function noMatch(segmentGroup) {\n      return new rxjs_Observable.Observable(function (obs) { return obs.error(new NoMatch(segmentGroup)); });\n  }\n  /**\n   * @param {?} newTree\n   * @return {?}\n   */\n  function absoluteRedirect(newTree) {\n      return new rxjs_Observable.Observable(function (obs) { return obs.error(new AbsoluteRedirect(newTree)); });\n  }\n  /**\n   * @param {?} redirectTo\n   * @return {?}\n   */\n  function namedOutletsRedirect(redirectTo) {\n      return new rxjs_Observable.Observable(function (obs) { return obs.error(new Error(\"Only absolute redirects can have named outlets. redirectTo: '\" + redirectTo + \"'\")); });\n  }\n  /**\n   * @param {?} route\n   * @return {?}\n   */\n  function canLoadFails(route) {\n      return new rxjs_Observable.Observable(function (obs) { return obs.error(new NavigationCancelingError(\"Cannot load children because the guard of the route \\\"path: '\" + route.path + \"'\\\" returned false\")); });\n  }\n  /**\n   * @param {?} injector\n   * @param {?} configLoader\n   * @param {?} urlSerializer\n   * @param {?} urlTree\n   * @param {?} config\n   * @return {?}\n   */\n  function applyRedirects(injector, configLoader, urlSerializer, urlTree, config) {\n      return new ApplyRedirects(injector, configLoader, urlSerializer, urlTree, config).apply();\n  }\n  var ApplyRedirects = (function () {\n      /**\n       * @param {?} injector\n       * @param {?} configLoader\n       * @param {?} urlSerializer\n       * @param {?} urlTree\n       * @param {?} config\n       */\n      function ApplyRedirects(injector, configLoader, urlSerializer, urlTree, config) {\n          this.injector = injector;\n          this.configLoader = configLoader;\n          this.urlSerializer = urlSerializer;\n          this.urlTree = urlTree;\n          this.config = config;\n          this.allowRedirects = true;\n      }\n      /**\n       * @return {?}\n       */\n      ApplyRedirects.prototype.apply = function () {\n          var _this = this;\n          var /** @type {?} */ expanded$ = this.expandSegmentGroup(this.injector, this.config, this.urlTree.root, PRIMARY_OUTLET);\n          var /** @type {?} */ urlTrees$ = rxjs_operator_map.map.call(expanded$, function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup, _this.urlTree.queryParams, _this.urlTree.fragment); });\n          return rxjs_operator_catch._catch.call(urlTrees$, function (e) {\n              if (e instanceof AbsoluteRedirect) {\n                  // after an absolute redirect we do not apply any more redirects!\n                  _this.allowRedirects = false;\n                  // we need to run matching, so we can fetch all lazy-loaded modules\n                  return _this.match(e.urlTree);\n              }\n              else if (e instanceof NoMatch) {\n                  throw _this.noMatchError(e);\n              }\n              else {\n                  throw e;\n              }\n          });\n      };\n      /**\n       * @param {?} tree\n       * @return {?}\n       */\n      ApplyRedirects.prototype.match = function (tree) {\n          var _this = this;\n          var /** @type {?} */ expanded$ = this.expandSegmentGroup(this.injector, this.config, tree.root, PRIMARY_OUTLET);\n          var /** @type {?} */ mapped$ = rxjs_operator_map.map.call(expanded$, function (rootSegmentGroup) {\n              return _this.createUrlTree(rootSegmentGroup, tree.queryParams, tree.fragment);\n          });\n          return rxjs_operator_catch._catch.call(mapped$, function (e) {\n              if (e instanceof NoMatch) {\n                  throw _this.noMatchError(e);\n              }\n              else {\n                  throw e;\n              }\n          });\n      };\n      /**\n       * @param {?} e\n       * @return {?}\n       */\n      ApplyRedirects.prototype.noMatchError = function (e) {\n          return new Error(\"Cannot match any routes. URL Segment: '\" + e.segmentGroup + \"'\");\n      };\n      /**\n       * @param {?} rootCandidate\n       * @param {?} queryParams\n       * @param {?} fragment\n       * @return {?}\n       */\n      ApplyRedirects.prototype.createUrlTree = function (rootCandidate, queryParams, fragment) {\n          var /** @type {?} */ root = rootCandidate.segments.length > 0 ?\n              new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = rootCandidate, _a)) :\n              rootCandidate;\n          return new UrlTree(root, queryParams, fragment);\n          var _a;\n      };\n      /**\n       * @param {?} injector\n       * @param {?} routes\n       * @param {?} segmentGroup\n       * @param {?} outlet\n       * @return {?}\n       */\n      ApplyRedirects.prototype.expandSegmentGroup = function (injector, routes, segmentGroup, outlet) {\n          if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n              return rxjs_operator_map.map.call(this.expandChildren(injector, routes, segmentGroup), function (children) { return new UrlSegmentGroup([], children); });\n          }\n          else {\n              return this.expandSegment(injector, segmentGroup, routes, segmentGroup.segments, outlet, true);\n          }\n      };\n      /**\n       * @param {?} injector\n       * @param {?} routes\n       * @param {?} segmentGroup\n       * @return {?}\n       */\n      ApplyRedirects.prototype.expandChildren = function (injector, routes, segmentGroup) {\n          var _this = this;\n          return waitForMap(segmentGroup.children, function (childOutlet, child) { return _this.expandSegmentGroup(injector, routes, child, childOutlet); });\n      };\n      /**\n       * @param {?} injector\n       * @param {?} segmentGroup\n       * @param {?} routes\n       * @param {?} segments\n       * @param {?} outlet\n       * @param {?} allowRedirects\n       * @return {?}\n       */\n      ApplyRedirects.prototype.expandSegment = function (injector, segmentGroup, routes, segments, outlet, allowRedirects) {\n          var _this = this;\n          var /** @type {?} */ routes$ = rxjs_observable_of.of.apply(void 0, routes);\n          var /** @type {?} */ processedRoutes$ = rxjs_operator_map.map.call(routes$, function (r) {\n              var /** @type {?} */ expanded$ = _this.expandSegmentAgainstRoute(injector, segmentGroup, routes, r, segments, outlet, allowRedirects);\n              return rxjs_operator_catch._catch.call(expanded$, function (e) {\n                  if (e instanceof NoMatch)\n                      return rxjs_observable_of.of(null);\n                  else\n                      throw e;\n              });\n          });\n          var /** @type {?} */ concattedProcessedRoutes$ = rxjs_operator_concatAll.concatAll.call(processedRoutes$);\n          var /** @type {?} */ first$ = rxjs_operator_first.first.call(concattedProcessedRoutes$, function (s) { return !!s; });\n          return rxjs_operator_catch._catch.call(first$, function (e, _) {\n              if (e instanceof rxjs_util_EmptyError.EmptyError) {\n                  if (_this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n                      return rxjs_observable_of.of(new UrlSegmentGroup([], {}));\n                  }\n                  else {\n                      throw new NoMatch(segmentGroup);\n                  }\n              }\n              else {\n                  throw e;\n              }\n          });\n      };\n      /**\n       * @param {?} segmentGroup\n       * @param {?} segments\n       * @param {?} outlet\n       * @return {?}\n       */\n      ApplyRedirects.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {\n          return segments.length === 0 && !segmentGroup.children[outlet];\n      };\n      /**\n       * @param {?} injector\n       * @param {?} segmentGroup\n       * @param {?} routes\n       * @param {?} route\n       * @param {?} paths\n       * @param {?} outlet\n       * @param {?} allowRedirects\n       * @return {?}\n       */\n      ApplyRedirects.prototype.expandSegmentAgainstRoute = function (injector, segmentGroup, routes, route, paths, outlet, allowRedirects) {\n          if (getOutlet$1(route) !== outlet)\n              return noMatch(segmentGroup);\n          if (route.redirectTo !== undefined && !(allowRedirects && this.allowRedirects))\n              return noMatch(segmentGroup);\n          if (route.redirectTo === undefined) {\n              return this.matchSegmentAgainstRoute(injector, segmentGroup, route, paths);\n          }\n          else {\n              return this.expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, paths, outlet);\n          }\n      };\n      /**\n       * @param {?} injector\n       * @param {?} segmentGroup\n       * @param {?} routes\n       * @param {?} route\n       * @param {?} segments\n       * @param {?} outlet\n       * @return {?}\n       */\n      ApplyRedirects.prototype.expandSegmentAgainstRouteUsingRedirect = function (injector, segmentGroup, routes, route, segments, outlet) {\n          if (route.path === '**') {\n              return this.expandWildCardWithParamsAgainstRouteUsingRedirect(injector, routes, route, outlet);\n          }\n          else {\n              return this.expandRegularSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet);\n          }\n      };\n      /**\n       * @param {?} injector\n       * @param {?} routes\n       * @param {?} route\n       * @param {?} outlet\n       * @return {?}\n       */\n      ApplyRedirects.prototype.expandWildCardWithParamsAgainstRouteUsingRedirect = function (injector, routes, route, outlet) {\n          var _this = this;\n          var /** @type {?} */ newTree = this.applyRedirectCommands([], route.redirectTo, {});\n          if (route.redirectTo.startsWith('/')) {\n              return absoluteRedirect(newTree);\n          }\n          else {\n              return rxjs_operator_mergeMap.mergeMap.call(this.lineralizeSegments(route, newTree), function (newSegments) {\n                  var /** @type {?} */ group = new UrlSegmentGroup(newSegments, {});\n                  return _this.expandSegment(injector, group, routes, newSegments, outlet, false);\n              });\n          }\n      };\n      /**\n       * @param {?} injector\n       * @param {?} segmentGroup\n       * @param {?} routes\n       * @param {?} route\n       * @param {?} segments\n       * @param {?} outlet\n       * @return {?}\n       */\n      ApplyRedirects.prototype.expandRegularSegmentAgainstRouteUsingRedirect = function (injector, segmentGroup, routes, route, segments, outlet) {\n          var _this = this;\n          var _a = match(segmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild, positionalParamSegments = _a.positionalParamSegments;\n          if (!matched)\n              return noMatch(segmentGroup);\n          var /** @type {?} */ newTree = this.applyRedirectCommands(consumedSegments, route.redirectTo, /** @type {?} */ (positionalParamSegments));\n          if (route.redirectTo.startsWith('/')) {\n              return absoluteRedirect(newTree);\n          }\n          else {\n              return rxjs_operator_mergeMap.mergeMap.call(this.lineralizeSegments(route, newTree), function (newSegments) {\n                  return _this.expandSegment(injector, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);\n              });\n          }\n      };\n      /**\n       * @param {?} injector\n       * @param {?} rawSegmentGroup\n       * @param {?} route\n       * @param {?} segments\n       * @return {?}\n       */\n      ApplyRedirects.prototype.matchSegmentAgainstRoute = function (injector, rawSegmentGroup, route, segments) {\n          var _this = this;\n          if (route.path === '**') {\n              if (route.loadChildren) {\n                  return rxjs_operator_map.map.call(this.configLoader.load(injector, route.loadChildren), function (r) {\n                      ((route))._loadedConfig = r;\n                      return rxjs_observable_of.of(new UrlSegmentGroup(segments, {}));\n                  });\n              }\n              else {\n                  return rxjs_observable_of.of(new UrlSegmentGroup(segments, {}));\n              }\n          }\n          else {\n              var _a = match(rawSegmentGroup, route, segments), matched = _a.matched, consumedSegments_1 = _a.consumedSegments, lastChild = _a.lastChild;\n              if (!matched)\n                  return noMatch(rawSegmentGroup);\n              var /** @type {?} */ rawSlicedSegments_1 = segments.slice(lastChild);\n              var /** @type {?} */ childConfig$ = this.getChildConfig(injector, route);\n              return rxjs_operator_mergeMap.mergeMap.call(childConfig$, function (routerConfig) {\n                  var /** @type {?} */ childInjector = routerConfig.injector;\n                  var /** @type {?} */ childConfig = routerConfig.routes;\n                  var _a = split(rawSegmentGroup, consumedSegments_1, rawSlicedSegments_1, childConfig), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;\n                  if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n                      var /** @type {?} */ expanded$ = _this.expandChildren(childInjector, childConfig, segmentGroup);\n                      return rxjs_operator_map.map.call(expanded$, function (children) { return new UrlSegmentGroup(consumedSegments_1, children); });\n                  }\n                  else if (childConfig.length === 0 && slicedSegments.length === 0) {\n                      return rxjs_observable_of.of(new UrlSegmentGroup(consumedSegments_1, {}));\n                  }\n                  else {\n                      var /** @type {?} */ expanded$ = _this.expandSegment(childInjector, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);\n                      return rxjs_operator_map.map.call(expanded$, function (cs) { return new UrlSegmentGroup(consumedSegments_1.concat(cs.segments), cs.children); });\n                  }\n              });\n          }\n      };\n      /**\n       * @param {?} injector\n       * @param {?} route\n       * @return {?}\n       */\n      ApplyRedirects.prototype.getChildConfig = function (injector, route) {\n          var _this = this;\n          if (route.children) {\n              return rxjs_observable_of.of(new LoadedRouterConfig(route.children, injector, null, null));\n          }\n          else if (route.loadChildren) {\n              return rxjs_operator_mergeMap.mergeMap.call(runGuards(injector, route), function (shouldLoad) {\n                  if (shouldLoad) {\n                      if (((route))._loadedConfig) {\n                          return rxjs_observable_of.of(((route))._loadedConfig);\n                      }\n                      else {\n                          return rxjs_operator_map.map.call(_this.configLoader.load(injector, route.loadChildren), function (r) {\n                              ((route))._loadedConfig = r;\n                              return r;\n                          });\n                      }\n                  }\n                  else {\n                      return canLoadFails(route);\n                  }\n              });\n          }\n          else {\n              return rxjs_observable_of.of(new LoadedRouterConfig([], injector, null, null));\n          }\n      };\n      /**\n       * @param {?} route\n       * @param {?} urlTree\n       * @return {?}\n       */\n      ApplyRedirects.prototype.lineralizeSegments = function (route, urlTree) {\n          var /** @type {?} */ res = [];\n          var /** @type {?} */ c = urlTree.root;\n          while (true) {\n              res = res.concat(c.segments);\n              if (c.numberOfChildren === 0) {\n                  return rxjs_observable_of.of(res);\n              }\n              else if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n                  return namedOutletsRedirect(route.redirectTo);\n              }\n              else {\n                  c = c.children[PRIMARY_OUTLET];\n              }\n          }\n      };\n      /**\n       * @param {?} segments\n       * @param {?} redirectTo\n       * @param {?} posParams\n       * @return {?}\n       */\n      ApplyRedirects.prototype.applyRedirectCommands = function (segments, redirectTo, posParams) {\n          var /** @type {?} */ t = this.urlSerializer.parse(redirectTo);\n          return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\n      };\n      /**\n       * @param {?} redirectTo\n       * @param {?} urlTree\n       * @param {?} segments\n       * @param {?} posParams\n       * @return {?}\n       */\n      ApplyRedirects.prototype.applyRedirectCreatreUrlTree = function (redirectTo, urlTree, segments, posParams) {\n          var /** @type {?} */ newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n          return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\n      };\n      /**\n       * @param {?} redirectToParams\n       * @param {?} actualParams\n       * @return {?}\n       */\n      ApplyRedirects.prototype.createQueryParams = function (redirectToParams, actualParams) {\n          var /** @type {?} */ res = {};\n          forEach(redirectToParams, function (v, k) {\n              if (v.startsWith(':')) {\n                  res[k] = actualParams[v.substring(1)];\n              }\n              else {\n                  res[k] = v;\n              }\n          });\n          return res;\n      };\n      /**\n       * @param {?} redirectTo\n       * @param {?} group\n       * @param {?} segments\n       * @param {?} posParams\n       * @return {?}\n       */\n      ApplyRedirects.prototype.createSegmentGroup = function (redirectTo, group, segments, posParams) {\n          var _this = this;\n          var /** @type {?} */ updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n          var /** @type {?} */ children = {};\n          forEach(group.children, function (child, name) {\n              children[name] = _this.createSegmentGroup(redirectTo, child, segments, posParams);\n          });\n          return new UrlSegmentGroup(updatedSegments, children);\n      };\n      /**\n       * @param {?} redirectTo\n       * @param {?} redirectToSegments\n       * @param {?} actualSegments\n       * @param {?} posParams\n       * @return {?}\n       */\n      ApplyRedirects.prototype.createSegments = function (redirectTo, redirectToSegments, actualSegments, posParams) {\n          var _this = this;\n          return redirectToSegments.map(function (s) { return s.path.startsWith(':') ? _this.findPosParam(redirectTo, s, posParams) :\n              _this.findOrReturn(s, actualSegments); });\n      };\n      /**\n       * @param {?} redirectTo\n       * @param {?} redirectToUrlSegment\n       * @param {?} posParams\n       * @return {?}\n       */\n      ApplyRedirects.prototype.findPosParam = function (redirectTo, redirectToUrlSegment, posParams) {\n          var /** @type {?} */ pos = posParams[redirectToUrlSegment.path.substring(1)];\n          if (!pos)\n              throw new Error(\"Cannot redirect to '\" + redirectTo + \"'. Cannot find '\" + redirectToUrlSegment.path + \"'.\");\n          return pos;\n      };\n      /**\n       * @param {?} redirectToUrlSegment\n       * @param {?} actualSegments\n       * @return {?}\n       */\n      ApplyRedirects.prototype.findOrReturn = function (redirectToUrlSegment, actualSegments) {\n          var /** @type {?} */ idx = 0;\n          for (var _i = 0, actualSegments_1 = actualSegments; _i < actualSegments_1.length; _i++) {\n              var s = actualSegments_1[_i];\n              if (s.path === redirectToUrlSegment.path) {\n                  actualSegments.splice(idx);\n                  return s;\n              }\n              idx++;\n          }\n          return redirectToUrlSegment;\n      };\n      return ApplyRedirects;\n  }());\n  /**\n   * @param {?} injector\n   * @param {?} route\n   * @return {?}\n   */\n  function runGuards(injector, route) {\n      var /** @type {?} */ canLoad = route.canLoad;\n      if (!canLoad || canLoad.length === 0)\n          return rxjs_observable_of.of(true);\n      var /** @type {?} */ obs = rxjs_operator_map.map.call(rxjs_observable_from.from(canLoad), function (c) {\n          var /** @type {?} */ guard = injector.get(c);\n          if (guard.canLoad) {\n              return wrapIntoObservable(guard.canLoad(route));\n          }\n          else {\n              return wrapIntoObservable(guard(route));\n          }\n      });\n      return andObservables(obs);\n  }\n  /**\n   * @param {?} segmentGroup\n   * @param {?} route\n   * @param {?} segments\n   * @return {?}\n   */\n  function match(segmentGroup, route, segments) {\n      var /** @type {?} */ noMatch = { matched: false, consumedSegments: /** @type {?} */ ([]), lastChild: 0, positionalParamSegments: {} };\n      if (route.path === '') {\n          if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {\n              return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n          }\n          else {\n              return { matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n          }\n      }\n      var /** @type {?} */ matcher = route.matcher || defaultUrlMatcher;\n      var /** @type {?} */ res = matcher(segments, segmentGroup, route);\n      if (!res)\n          return noMatch;\n      return {\n          matched: true,\n          consumedSegments: res.consumed,\n          lastChild: res.consumed.length,\n          positionalParamSegments: res.posParams\n      };\n  }\n  /**\n   * @param {?} segmentGroup\n   * @param {?} consumedSegments\n   * @param {?} slicedSegments\n   * @param {?} config\n   * @return {?}\n   */\n  function split(segmentGroup, consumedSegments, slicedSegments, config) {\n      if (slicedSegments.length > 0 &&\n          containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n          var /** @type {?} */ s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n          return { segmentGroup: mergeTrivialChildren(s), slicedSegments: [] };\n      }\n      else if (slicedSegments.length === 0 &&\n          containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {\n          var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n          return { segmentGroup: mergeTrivialChildren(s), slicedSegments: slicedSegments };\n      }\n      else {\n          return { segmentGroup: segmentGroup, slicedSegments: slicedSegments };\n      }\n  }\n  /**\n   * @param {?} s\n   * @return {?}\n   */\n  function mergeTrivialChildren(s) {\n      if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n          var /** @type {?} */ c = s.children[PRIMARY_OUTLET];\n          return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n      }\n      else {\n          return s;\n      }\n  }\n  /**\n   * @param {?} segmentGroup\n   * @param {?} slicedSegments\n   * @param {?} routes\n   * @param {?} children\n   * @return {?}\n   */\n  function addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n      var /** @type {?} */ res = {};\n      for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n          var r = routes_1[_i];\n          if (emptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {\n              res[getOutlet$1(r)] = new UrlSegmentGroup([], {});\n          }\n      }\n      return merge(children, res);\n  }\n  /**\n   * @param {?} routes\n   * @param {?} primarySegmentGroup\n   * @return {?}\n   */\n  function createChildrenForEmptySegments(routes, primarySegmentGroup) {\n      var /** @type {?} */ res = {};\n      res[PRIMARY_OUTLET] = primarySegmentGroup;\n      for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {\n          var r = routes_2[_i];\n          if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {\n              res[getOutlet$1(r)] = new UrlSegmentGroup([], {});\n          }\n      }\n      return res;\n  }\n  /**\n   * @param {?} segmentGroup\n   * @param {?} slicedSegments\n   * @param {?} routes\n   * @return {?}\n   */\n  function containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n      return routes\n          .filter(function (r) { return emptyPathRedirect(segmentGroup, slicedSegments, r) &&\n          getOutlet$1(r) !== PRIMARY_OUTLET; })\n          .length > 0;\n  }\n  /**\n   * @param {?} segmentGroup\n   * @param {?} slicedSegments\n   * @param {?} routes\n   * @return {?}\n   */\n  function containsEmptyPathRedirects(segmentGroup, slicedSegments, routes) {\n      return routes.filter(function (r) { return emptyPathRedirect(segmentGroup, slicedSegments, r); }).length > 0;\n  }\n  /**\n   * @param {?} segmentGroup\n   * @param {?} slicedSegments\n   * @param {?} r\n   * @return {?}\n   */\n  function emptyPathRedirect(segmentGroup, slicedSegments, r) {\n      if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full')\n          return false;\n      return r.path === '' && r.redirectTo !== undefined;\n  }\n  /**\n   * @param {?} route\n   * @return {?}\n   */\n  function getOutlet$1(route) {\n      return route.outlet ? route.outlet : PRIMARY_OUTLET;\n  }\n\n  /**\n   * @param {?} config\n   * @param {?=} parentPath\n   * @return {?}\n   */\n  function validateConfig(config, parentPath) {\n      if (parentPath === void 0) { parentPath = ''; }\n      // forEach doesn't iterate undefined values\n      for (var /** @type {?} */ i = 0; i < config.length; i++) {\n          var /** @type {?} */ route = config[i];\n          var /** @type {?} */ fullPath = getFullPath(parentPath, route);\n          validateNode(route, fullPath);\n      }\n  }\n  /**\n   * @param {?} route\n   * @param {?} fullPath\n   * @return {?}\n   */\n  function validateNode(route, fullPath) {\n      if (!route) {\n          throw new Error(\"\\n      Invalid configuration of route '\" + fullPath + \"': Encountered undefined route.\\n      The reason might be an extra comma.\\n       \\n      Example: \\n      const routes: Routes = [\\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\\n        { path: 'detail/:id', component: HeroDetailComponent }\\n      ];\\n    \");\n      }\n      if (Array.isArray(route)) {\n          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': Array cannot be specified\");\n      }\n      if (!route.component && (route.outlet && route.outlet !== PRIMARY_OUTLET)) {\n          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': a componentless route cannot have a named outlet set\");\n      }\n      if (route.redirectTo && route.children) {\n          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': redirectTo and children cannot be used together\");\n      }\n      if (route.redirectTo && route.loadChildren) {\n          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': redirectTo and loadChildren cannot be used together\");\n      }\n      if (route.children && route.loadChildren) {\n          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': children and loadChildren cannot be used together\");\n      }\n      if (route.redirectTo && route.component) {\n          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': redirectTo and component cannot be used together\");\n      }\n      if (route.path && route.matcher) {\n          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': path and matcher cannot be used together\");\n      }\n      if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {\n          throw new Error(\"Invalid configuration of route '\" + fullPath + \"'. One of the following must be provided: component, redirectTo, children or loadChildren\");\n      }\n      if (route.path === void 0 && route.matcher === void 0) {\n          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': routes must have either a path or a matcher specified\");\n      }\n      if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': path cannot start with a slash\");\n      }\n      if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n          var /** @type {?} */ exp = \"The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.\";\n          throw new Error(\"Invalid configuration of route '{path: \\\"\" + fullPath + \"\\\", redirectTo: \\\"\" + route.redirectTo + \"\\\"}': please provide 'pathMatch'. \" + exp);\n      }\n      if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {\n          throw new Error(\"Invalid configuration of route '\" + fullPath + \"': pathMatch can only be set to 'prefix' or 'full'\");\n      }\n      if (route.children) {\n          validateConfig(route.children, fullPath);\n      }\n  }\n  /**\n   * @param {?} parentPath\n   * @param {?} currentRoute\n   * @return {?}\n   */\n  function getFullPath(parentPath, currentRoute) {\n      if (!currentRoute) {\n          return parentPath;\n      }\n      if (!parentPath && !currentRoute.path) {\n          return '';\n      }\n      else if (parentPath && !currentRoute.path) {\n          return parentPath + \"/\";\n      }\n      else if (!parentPath && currentRoute.path) {\n          return currentRoute.path;\n      }\n      else {\n          return parentPath + \"/\" + currentRoute.path;\n      }\n  }\n\n  /**\n   * @license undefined\n    * Copyright Google Inc. All Rights Reserved.\n    * *\n    * Use of this source code is governed by an MIT-style license that can be\n    * found in the LICENSE file at https://angular.io/license\n   */\n  var Tree = (function () {\n      /**\n       * @param {?} root\n       */\n      function Tree(root) {\n          this._root = root;\n      }\n      Object.defineProperty(Tree.prototype, \"root\", {\n          /**\n           * @return {?}\n           */\n          get: function () { return this._root.value; },\n          enumerable: true,\n          configurable: true\n      });\n      /**\n       * @param {?} t\n       * @return {?}\n       */\n      Tree.prototype.parent = function (t) {\n          var /** @type {?} */ p = this.pathFromRoot(t);\n          return p.length > 1 ? p[p.length - 2] : null;\n      };\n      /**\n       * @param {?} t\n       * @return {?}\n       */\n      Tree.prototype.children = function (t) {\n          var /** @type {?} */ n = findNode(t, this._root);\n          return n ? n.children.map(function (t) { return t.value; }) : [];\n      };\n      /**\n       * @param {?} t\n       * @return {?}\n       */\n      Tree.prototype.firstChild = function (t) {\n          var /** @type {?} */ n = findNode(t, this._root);\n          return n && n.children.length > 0 ? n.children[0].value : null;\n      };\n      /**\n       * @param {?} t\n       * @return {?}\n       */\n      Tree.prototype.siblings = function (t) {\n          var /** @type {?} */ p = findPath(t, this._root, []);\n          if (p.length < 2)\n              return [];\n          var /** @type {?} */ c = p[p.length - 2].children.map(function (c) { return c.value; });\n          return c.filter(function (cc) { return cc !== t; });\n      };\n      /**\n       * @param {?} t\n       * @return {?}\n       */\n      Tree.prototype.pathFromRoot = function (t) { return findPath(t, this._root, []).map(function (s) { return s.value; }); };\n      return Tree;\n  }());\n  /**\n   * @param {?} expected\n   * @param {?} c\n   * @return {?}\n   */\n  function findNode(expected, c) {\n      if (expected === c.value)\n          return c;\n      for (var _i = 0, _a = c.children; _i < _a.length; _i++) {\n          var cc = _a[_i];\n          var /** @type {?} */ r = findNode(expected, cc);\n          if (r)\n              return r;\n      }\n      return null;\n  }\n  /**\n   * @param {?} expected\n   * @param {?} c\n   * @param {?} collected\n   * @return {?}\n   */\n  function findPath(expected, c, collected) {\n      collected.push(c);\n      if (expected === c.value)\n          return collected;\n      for (var _i = 0, _a = c.children; _i < _a.length; _i++) {\n          var cc = _a[_i];\n          var /** @type {?} */ cloned = collected.slice(0);\n          var /** @type {?} */ r = findPath(expected, cc, cloned);\n          if (r.length > 0)\n              return r;\n      }\n      return [];\n  }\n  var TreeNode = (function () {\n      /**\n       * @param {?} value\n       * @param {?} children\n       */\n      function TreeNode(value, children) {\n          this.value = value;\n          this.children = children;\n      }\n      /**\n       * @return {?}\n       */\n      TreeNode.prototype.toString = function () { return \"TreeNode(\" + this.value + \")\"; };\n      return TreeNode;\n  }());\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$1 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  /**\n   *  *\n    * *\n    * ```\n    * class MyComponent {\n    * constructor(router: Router) {\n    * const state: RouterState = router.routerState;\n    * const root: ActivatedRoute = state.root;\n    * const child = root.firstChild;\n    * const id: Observable<string> = child.params.map(p => p.id);\n    * //...\n    * }\n    * }\n    * ```\n    * *\n    * RouterState is a tree of activated routes. Every node in this tree knows about the \"consumed\" URL\n    * segments,\n    * the extracted parameters, and the resolved data.\n    * *\n    * See {@link ActivatedRoute} for more information.\n    * *\n   */\n  var RouterState = (function (_super) {\n      __extends$1(RouterState, _super);\n      /**\n       * @param {?} root\n       * @param {?} snapshot\n       */\n      function RouterState(root, snapshot) {\n          _super.call(this, root);\n          this.snapshot = snapshot;\n          setRouterStateSnapshot(this, root);\n      }\n      /**\n       * @return {?}\n       */\n      RouterState.prototype.toString = function () { return this.snapshot.toString(); };\n      return RouterState;\n  }(Tree));\n  /**\n   * @param {?} urlTree\n   * @param {?} rootComponent\n   * @return {?}\n   */\n  function createEmptyState(urlTree, rootComponent) {\n      var /** @type {?} */ snapshot = createEmptyStateSnapshot(urlTree, rootComponent);\n      var /** @type {?} */ emptyUrl = new rxjs_BehaviorSubject.BehaviorSubject([new UrlSegment('', {})]);\n      var /** @type {?} */ emptyParams = new rxjs_BehaviorSubject.BehaviorSubject({});\n      var /** @type {?} */ emptyData = new rxjs_BehaviorSubject.BehaviorSubject({});\n      var /** @type {?} */ emptyQueryParams = new rxjs_BehaviorSubject.BehaviorSubject({});\n      var /** @type {?} */ fragment = new rxjs_BehaviorSubject.BehaviorSubject('');\n      var /** @type {?} */ activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n      activated.snapshot = snapshot.root;\n      return new RouterState(new TreeNode(activated, []), snapshot);\n  }\n  /**\n   * @param {?} urlTree\n   * @param {?} rootComponent\n   * @return {?}\n   */\n  function createEmptyStateSnapshot(urlTree, rootComponent) {\n      var /** @type {?} */ emptyParams = {};\n      var /** @type {?} */ emptyData = {};\n      var /** @type {?} */ emptyQueryParams = {};\n      var /** @type {?} */ fragment = '';\n      var /** @type {?} */ activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});\n      return new RouterStateSnapshot('', new TreeNode(activated, []));\n  }\n  /**\n   *  outlet.\n    * An `ActivatedRoute` can also be used to traverse the router state tree.\n    * *\n    * *\n    * ```\n    * class MyComponent {\n    * constructor(route: ActivatedRoute) {\n    * const id: Observable<string> = route.params.map(p => p.id);\n    * const url: Observable<string> = route.url.map(segments => segments.join(''));\n    * // route.data includes both `data` and `resolve`\n    * const user = route.data.map(d => d.user);\n    * }\n    * }\n    * ```\n    * *\n   */\n  var ActivatedRoute = (function () {\n      /**\n       * @param {?} url\n       * @param {?} params\n       * @param {?} queryParams\n       * @param {?} fragment\n       * @param {?} data\n       * @param {?} outlet\n       * @param {?} component\n       * @param {?} futureSnapshot\n       */\n      function ActivatedRoute(url, params, queryParams, fragment, data, outlet, component, futureSnapshot) {\n          this.url = url;\n          this.params = params;\n          this.queryParams = queryParams;\n          this.fragment = fragment;\n          this.data = data;\n          this.outlet = outlet;\n          this.component = component;\n          this._futureSnapshot = futureSnapshot;\n      }\n      Object.defineProperty(ActivatedRoute.prototype, \"routeConfig\", {\n          /**\n           *  The configuration used to match this route\n           * @return {?}\n           */\n          get: function () { return this._futureSnapshot.routeConfig; },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(ActivatedRoute.prototype, \"root\", {\n          /**\n           *  The root of the router state\n           * @return {?}\n           */\n          get: function () { return this._routerState.root; },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(ActivatedRoute.prototype, \"parent\", {\n          /**\n           *  The parent of this route in the router state tree\n           * @return {?}\n           */\n          get: function () { return this._routerState.parent(this); },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(ActivatedRoute.prototype, \"firstChild\", {\n          /**\n           *  The first child of this route in the router state tree\n           * @return {?}\n           */\n          get: function () { return this._routerState.firstChild(this); },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(ActivatedRoute.prototype, \"children\", {\n          /**\n           *  The children of this route in the router state tree\n           * @return {?}\n           */\n          get: function () { return this._routerState.children(this); },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(ActivatedRoute.prototype, \"pathFromRoot\", {\n          /**\n           *  The path from the root of the router state tree to this route\n           * @return {?}\n           */\n          get: function () { return this._routerState.pathFromRoot(this); },\n          enumerable: true,\n          configurable: true\n      });\n      /**\n       * @return {?}\n       */\n      ActivatedRoute.prototype.toString = function () {\n          return this.snapshot ? this.snapshot.toString() : \"Future(\" + this._futureSnapshot + \")\";\n      };\n      return ActivatedRoute;\n  }());\n  /**\n   * @param {?} route\n   * @return {?}\n   */\n  function inheritedParamsDataResolve(route) {\n      var /** @type {?} */ pathToRoot = route.pathFromRoot;\n      var /** @type {?} */ inhertingStartingFrom = pathToRoot.length - 1;\n      while (inhertingStartingFrom >= 1) {\n          var /** @type {?} */ current = pathToRoot[inhertingStartingFrom];\n          var /** @type {?} */ parent_1 = pathToRoot[inhertingStartingFrom - 1];\n          // current route is an empty path => inherits its parent's params and data\n          if (current.routeConfig && current.routeConfig.path === '') {\n              inhertingStartingFrom--;\n          }\n          else if (!parent_1.component) {\n              inhertingStartingFrom--;\n          }\n          else {\n              break;\n          }\n      }\n      return pathToRoot.slice(inhertingStartingFrom).reduce(function (res, curr) {\n          var /** @type {?} */ params = merge(res.params, curr.params);\n          var /** @type {?} */ data = merge(res.data, curr.data);\n          var /** @type {?} */ resolve = merge(res.resolve, curr._resolvedData);\n          return { params: params, data: data, resolve: resolve };\n      }, /** @type {?} */ ({ params: {}, data: {}, resolve: {} }));\n  }\n  /**\n   *  outlet\n    * at a particular moment in time. ActivatedRouteSnapshot can also be used to traverse the router\n    * state tree.\n    * *\n    * *\n    * ```\n    * class MyComponent {\n    * constructor(route: ActivatedRoute) {\n    * const id: string = route.snapshot.params.id;\n    * const url: string = route.snapshot.url.join('');\n    * const user = route.snapshot.data.user;\n    * }\n    * }\n    * ```\n    * *\n   */\n  var ActivatedRouteSnapshot = (function () {\n      /**\n       * @param {?} url\n       * @param {?} params\n       * @param {?} queryParams\n       * @param {?} fragment\n       * @param {?} data\n       * @param {?} outlet\n       * @param {?} component\n       * @param {?} routeConfig\n       * @param {?} urlSegment\n       * @param {?} lastPathIndex\n       * @param {?} resolve\n       */\n      function ActivatedRouteSnapshot(url, params, queryParams, fragment, data, outlet, component, routeConfig, urlSegment, lastPathIndex, resolve) {\n          this.url = url;\n          this.params = params;\n          this.queryParams = queryParams;\n          this.fragment = fragment;\n          this.data = data;\n          this.outlet = outlet;\n          this.component = component;\n          this._routeConfig = routeConfig;\n          this._urlSegment = urlSegment;\n          this._lastPathIndex = lastPathIndex;\n          this._resolve = resolve;\n      }\n      Object.defineProperty(ActivatedRouteSnapshot.prototype, \"routeConfig\", {\n          /**\n           *  The configuration used to match this route\n           * @return {?}\n           */\n          get: function () { return this._routeConfig; },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(ActivatedRouteSnapshot.prototype, \"root\", {\n          /**\n           *  The root of the router state\n           * @return {?}\n           */\n          get: function () { return this._routerState.root; },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(ActivatedRouteSnapshot.prototype, \"parent\", {\n          /**\n           *  The parent of this route in the router state tree\n           * @return {?}\n           */\n          get: function () { return this._routerState.parent(this); },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(ActivatedRouteSnapshot.prototype, \"firstChild\", {\n          /**\n           *  The first child of this route in the router state tree\n           * @return {?}\n           */\n          get: function () { return this._routerState.firstChild(this); },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(ActivatedRouteSnapshot.prototype, \"children\", {\n          /**\n           *  The children of this route in the router state tree\n           * @return {?}\n           */\n          get: function () { return this._routerState.children(this); },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(ActivatedRouteSnapshot.prototype, \"pathFromRoot\", {\n          /**\n           *  The path from the root of the router state tree to this route\n           * @return {?}\n           */\n          get: function () { return this._routerState.pathFromRoot(this); },\n          enumerable: true,\n          configurable: true\n      });\n      /**\n       * @return {?}\n       */\n      ActivatedRouteSnapshot.prototype.toString = function () {\n          var /** @type {?} */ url = this.url.map(function (segment) { return segment.toString(); }).join('/');\n          var /** @type {?} */ matched = this._routeConfig ? this._routeConfig.path : '';\n          return \"Route(url:'\" + url + \"', path:'\" + matched + \"')\";\n      };\n      return ActivatedRouteSnapshot;\n  }());\n  /**\n   *  *\n    * *\n    * ```\n    * class MyComponent {\n    * constructor(router: Router) {\n    * const state: RouterState = router.routerState;\n    * const snapshot: RouterStateSnapshot = state.snapshot;\n    * const root: ActivatedRouteSnapshot = snapshot.root;\n    * const child = root.firstChild;\n    * const id: Observable<string> = child.params.map(p => p.id);\n    * //...\n    * }\n    * }\n    * ```\n    * *\n    * RouterStateSnapshot is a tree of activated route snapshots. Every node in this tree knows about\n    * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n    * *\n   */\n  var RouterStateSnapshot = (function (_super) {\n      __extends$1(RouterStateSnapshot, _super);\n      /**\n       * @param {?} url\n       * @param {?} root\n       */\n      function RouterStateSnapshot(url, root) {\n          _super.call(this, root);\n          this.url = url;\n          setRouterStateSnapshot(this, root);\n      }\n      /**\n       * @return {?}\n       */\n      RouterStateSnapshot.prototype.toString = function () { return serializeNode(this._root); };\n      return RouterStateSnapshot;\n  }(Tree));\n  /**\n   * @param {?} state\n   * @param {?} node\n   * @return {?}\n   */\n  function setRouterStateSnapshot(state, node) {\n      node.value._routerState = state;\n      node.children.forEach(function (c) { return setRouterStateSnapshot(state, c); });\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  function serializeNode(node) {\n      var /** @type {?} */ c = node.children.length > 0 ? \" { \" + node.children.map(serializeNode).join(\", \") + \" } \" : '';\n      return \"\" + node.value + c;\n  }\n  /**\n   *  The expectation is that the activate route is created with the right set of parameters.\n    * So we push new values into the observables only when they are not the initial values.\n    * And we detect that by checking if the snapshot field is set.\n   * @param {?} route\n   * @return {?}\n   */\n  function advanceActivatedRoute(route) {\n      if (route.snapshot) {\n          if (!shallowEqual(route.snapshot.queryParams, route._futureSnapshot.queryParams)) {\n              ((route.queryParams)).next(route._futureSnapshot.queryParams);\n          }\n          if (route.snapshot.fragment !== route._futureSnapshot.fragment) {\n              ((route.fragment)).next(route._futureSnapshot.fragment);\n          }\n          if (!shallowEqual(route.snapshot.params, route._futureSnapshot.params)) {\n              ((route.params)).next(route._futureSnapshot.params);\n          }\n          if (!shallowEqualArrays(route.snapshot.url, route._futureSnapshot.url)) {\n              ((route.url)).next(route._futureSnapshot.url);\n          }\n          if (!equalParamsAndUrlSegments(route.snapshot, route._futureSnapshot)) {\n              ((route.data)).next(route._futureSnapshot.data);\n          }\n          route.snapshot = route._futureSnapshot;\n      }\n      else {\n          route.snapshot = route._futureSnapshot;\n          // this is for resolved data\n          ((route.data)).next(route._futureSnapshot.data);\n      }\n  }\n  /**\n   * @param {?} a\n   * @param {?} b\n   * @return {?}\n   */\n  function equalParamsAndUrlSegments(a, b) {\n      return shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n  }\n\n  /**\n   * @param {?} routeReuseStrategy\n   * @param {?} curr\n   * @param {?} prevState\n   * @return {?}\n   */\n  function createRouterState(routeReuseStrategy, curr, prevState) {\n      var /** @type {?} */ root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n      return new RouterState(root, curr);\n  }\n  /**\n   * @param {?} routeReuseStrategy\n   * @param {?} curr\n   * @param {?=} prevState\n   * @return {?}\n   */\n  function createNode(routeReuseStrategy, curr, prevState) {\n      // reuse an activated route that is currently displayed on the screen\n      if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n          var /** @type {?} */ value = prevState.value;\n          value._futureSnapshot = curr.value;\n          var /** @type {?} */ children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n          return new TreeNode(value, children);\n      }\n      else if (routeReuseStrategy.retrieve(curr.value)) {\n          var /** @type {?} */ tree = ((routeReuseStrategy.retrieve(curr.value))).route;\n          setFutureSnapshotsOfActivatedRoutes(curr, tree);\n          return tree;\n      }\n      else {\n          var /** @type {?} */ value = createActivatedRoute(curr.value);\n          var /** @type {?} */ children = curr.children.map(function (c) { return createNode(routeReuseStrategy, c); });\n          return new TreeNode(value, children);\n      }\n  }\n  /**\n   * @param {?} curr\n   * @param {?} result\n   * @return {?}\n   */\n  function setFutureSnapshotsOfActivatedRoutes(curr, result) {\n      if (curr.value.routeConfig !== result.value.routeConfig) {\n          throw new Error('Cannot reattach ActivatedRouteSnapshot created from a different route');\n      }\n      if (curr.children.length !== result.children.length) {\n          throw new Error('Cannot reattach ActivatedRouteSnapshot with a different number of children');\n      }\n      result.value._futureSnapshot = curr.value;\n      for (var /** @type {?} */ i = 0; i < curr.children.length; ++i) {\n          setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);\n      }\n  }\n  /**\n   * @param {?} routeReuseStrategy\n   * @param {?} curr\n   * @param {?} prevState\n   * @return {?}\n   */\n  function createOrReuseChildren(routeReuseStrategy, curr, prevState) {\n      return curr.children.map(function (child) {\n          for (var _i = 0, _a = prevState.children; _i < _a.length; _i++) {\n              var p = _a[_i];\n              if (routeReuseStrategy.shouldReuseRoute(p.value.snapshot, child.value)) {\n                  return createNode(routeReuseStrategy, child, p);\n              }\n          }\n          return createNode(routeReuseStrategy, child);\n      });\n  }\n  /**\n   * @param {?} c\n   * @return {?}\n   */\n  function createActivatedRoute(c) {\n      return new ActivatedRoute(new rxjs_BehaviorSubject.BehaviorSubject(c.url), new rxjs_BehaviorSubject.BehaviorSubject(c.params), new rxjs_BehaviorSubject.BehaviorSubject(c.queryParams), new rxjs_BehaviorSubject.BehaviorSubject(c.fragment), new rxjs_BehaviorSubject.BehaviorSubject(c.data), c.outlet, c.component, c);\n  }\n\n  /**\n   * @param {?} route\n   * @param {?} urlTree\n   * @param {?} commands\n   * @param {?} queryParams\n   * @param {?} fragment\n   * @return {?}\n   */\n  function createUrlTree(route, urlTree, commands, queryParams, fragment) {\n      if (commands.length === 0) {\n          return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);\n      }\n      var /** @type {?} */ nav = computeNavigation(commands);\n      if (nav.toRoot()) {\n          return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);\n      }\n      var /** @type {?} */ startingPosition = findStartingPosition(nav, urlTree, route);\n      var /** @type {?} */ segmentGroup = startingPosition.processChildren ?\n          updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) :\n          updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);\n      return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);\n  }\n  /**\n   * @param {?} command\n   * @return {?}\n   */\n  function isMatrixParams(command) {\n      return typeof command === 'object' && !command.outlets && !command.segmentPath;\n  }\n  /**\n   * @param {?} oldSegmentGroup\n   * @param {?} newSegmentGroup\n   * @param {?} urlTree\n   * @param {?} queryParams\n   * @param {?} fragment\n   * @return {?}\n   */\n  function tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {\n      if (urlTree.root === oldSegmentGroup) {\n          return new UrlTree(newSegmentGroup, stringify(queryParams), fragment);\n      }\n      return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), stringify(queryParams), fragment);\n  }\n  /**\n   * @param {?} current\n   * @param {?} oldSegment\n   * @param {?} newSegment\n   * @return {?}\n   */\n  function replaceSegment(current, oldSegment, newSegment) {\n      var /** @type {?} */ children = {};\n      forEach(current.children, function (c, outletName) {\n          if (c === oldSegment) {\n              children[outletName] = newSegment;\n          }\n          else {\n              children[outletName] = replaceSegment(c, oldSegment, newSegment);\n          }\n      });\n      return new UrlSegmentGroup(current.segments, children);\n  }\n  var Navigation = (function () {\n      /**\n       * @param {?} isAbsolute\n       * @param {?} numberOfDoubleDots\n       * @param {?} commands\n       */\n      function Navigation(isAbsolute, numberOfDoubleDots, commands) {\n          this.isAbsolute = isAbsolute;\n          this.numberOfDoubleDots = numberOfDoubleDots;\n          this.commands = commands;\n          if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n              throw new Error('Root segment cannot have matrix parameters');\n          }\n          var cmdWithOutlet = commands.find(function (c) { return typeof c === 'object' && c.outlets; });\n          if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\n              throw new Error('{outlets:{}} has to be the last command');\n          }\n      }\n      /**\n       * @return {?}\n       */\n      Navigation.prototype.toRoot = function () {\n          return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n      };\n      return Navigation;\n  }());\n  /**\n   *  Transforms commands to a normalized `Navigation`\n   * @param {?} commands\n   * @return {?}\n   */\n  function computeNavigation(commands) {\n      if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] === '/') {\n          return new Navigation(true, 0, commands);\n      }\n      var /** @type {?} */ numberOfDoubleDots = 0;\n      var /** @type {?} */ isAbsolute = false;\n      var /** @type {?} */ res = commands.reduce(function (res, cmd, cmdIdx) {\n          if (typeof cmd === 'object') {\n              if (cmd.outlets) {\n                  var /** @type {?} */ outlets_1 = {};\n                  forEach(cmd.outlets, function (commands, name) {\n                      outlets_1[name] = typeof commands === 'string' ? commands.split('/') : commands;\n                  });\n                  return res.concat([{ outlets: outlets_1 }]);\n              }\n              if (cmd.segmentPath) {\n                  return res.concat([cmd.segmentPath]);\n              }\n          }\n          if (!(typeof cmd === 'string')) {\n              return res.concat([cmd]);\n          }\n          if (cmdIdx === 0) {\n              cmd.split('/').forEach(function (urlPart, partIndex) {\n                  if (partIndex == 0 && urlPart === '.') {\n                  }\n                  else if (partIndex == 0 && urlPart === '') {\n                      isAbsolute = true;\n                  }\n                  else if (urlPart === '..') {\n                      numberOfDoubleDots++;\n                  }\n                  else if (urlPart != '') {\n                      res.push(urlPart);\n                  }\n              });\n              return res;\n          }\n          return res.concat([cmd]);\n      }, []);\n      return new Navigation(isAbsolute, numberOfDoubleDots, res);\n  }\n  var Position = (function () {\n      /**\n       * @param {?} segmentGroup\n       * @param {?} processChildren\n       * @param {?} index\n       */\n      function Position(segmentGroup, processChildren, index) {\n          this.segmentGroup = segmentGroup;\n          this.processChildren = processChildren;\n          this.index = index;\n      }\n      return Position;\n  }());\n  /**\n   * @param {?} nav\n   * @param {?} tree\n   * @param {?} route\n   * @return {?}\n   */\n  function findStartingPosition(nav, tree, route) {\n      if (nav.isAbsolute) {\n          return new Position(tree.root, true, 0);\n      }\n      if (route.snapshot._lastPathIndex === -1) {\n          return new Position(route.snapshot._urlSegment, true, 0);\n      }\n      var /** @type {?} */ modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n      var /** @type {?} */ index = route.snapshot._lastPathIndex + modifier;\n      return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, nav.numberOfDoubleDots);\n  }\n  /**\n   * @param {?} group\n   * @param {?} index\n   * @param {?} numberOfDoubleDots\n   * @return {?}\n   */\n  function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n      var /** @type {?} */ g = group;\n      var /** @type {?} */ ci = index;\n      var /** @type {?} */ dd = numberOfDoubleDots;\n      while (dd > ci) {\n          dd -= ci;\n          g = g.parent;\n          if (!g) {\n              throw new Error('Invalid number of \\'../\\'');\n          }\n          ci = g.segments.length;\n      }\n      return new Position(g, false, ci - dd);\n  }\n  /**\n   * @param {?} command\n   * @return {?}\n   */\n  function getPath(command) {\n      if (typeof command === 'object' && command.outlets)\n          return command.outlets[PRIMARY_OUTLET];\n      return \"\" + command;\n  }\n  /**\n   * @param {?} commands\n   * @return {?}\n   */\n  function getOutlets(commands) {\n      if (!(typeof commands[0] === 'object'))\n          return (_a = {}, _a[PRIMARY_OUTLET] = commands, _a);\n      if (commands[0].outlets === undefined)\n          return (_b = {}, _b[PRIMARY_OUTLET] = commands, _b);\n      return commands[0].outlets;\n      var _a, _b;\n  }\n  /**\n   * @param {?} segmentGroup\n   * @param {?} startIndex\n   * @param {?} commands\n   * @return {?}\n   */\n  function updateSegmentGroup(segmentGroup, startIndex, commands) {\n      if (!segmentGroup) {\n          segmentGroup = new UrlSegmentGroup([], {});\n      }\n      if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n          return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n      }\n      var /** @type {?} */ m = prefixedWith(segmentGroup, startIndex, commands);\n      var /** @type {?} */ slicedCommands = commands.slice(m.commandIndex);\n      if (m.match && m.pathIndex < segmentGroup.segments.length) {\n          var /** @type {?} */ g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n          g.children[PRIMARY_OUTLET] =\n              new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n          return updateSegmentGroupChildren(g, 0, slicedCommands);\n      }\n      else if (m.match && slicedCommands.length === 0) {\n          return new UrlSegmentGroup(segmentGroup.segments, {});\n      }\n      else if (m.match && !segmentGroup.hasChildren()) {\n          return createNewSegmentGroup(segmentGroup, startIndex, commands);\n      }\n      else if (m.match) {\n          return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n      }\n      else {\n          return createNewSegmentGroup(segmentGroup, startIndex, commands);\n      }\n  }\n  /**\n   * @param {?} segmentGroup\n   * @param {?} startIndex\n   * @param {?} commands\n   * @return {?}\n   */\n  function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n      if (commands.length === 0) {\n          return new UrlSegmentGroup(segmentGroup.segments, {});\n      }\n      else {\n          var /** @type {?} */ outlets_2 = getOutlets(commands);\n          var /** @type {?} */ children_1 = {};\n          forEach(outlets_2, function (commands, outlet) {\n              if (commands !== null) {\n                  children_1[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n              }\n          });\n          forEach(segmentGroup.children, function (child, childOutlet) {\n              if (outlets_2[childOutlet] === undefined) {\n                  children_1[childOutlet] = child;\n              }\n          });\n          return new UrlSegmentGroup(segmentGroup.segments, children_1);\n      }\n  }\n  /**\n   * @param {?} segmentGroup\n   * @param {?} startIndex\n   * @param {?} commands\n   * @return {?}\n   */\n  function prefixedWith(segmentGroup, startIndex, commands) {\n      var /** @type {?} */ currentCommandIndex = 0;\n      var /** @type {?} */ currentPathIndex = startIndex;\n      var /** @type {?} */ noMatch = { match: false, pathIndex: 0, commandIndex: 0 };\n      while (currentPathIndex < segmentGroup.segments.length) {\n          if (currentCommandIndex >= commands.length)\n              return noMatch;\n          var /** @type {?} */ path = segmentGroup.segments[currentPathIndex];\n          var /** @type {?} */ curr = getPath(commands[currentCommandIndex]);\n          var /** @type {?} */ next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n          if (currentPathIndex > 0 && curr === undefined)\n              break;\n          if (curr && next && (typeof next === 'object') && next.outlets === undefined) {\n              if (!compare(curr, next, path))\n                  return noMatch;\n              currentCommandIndex += 2;\n          }\n          else {\n              if (!compare(curr, {}, path))\n                  return noMatch;\n              currentCommandIndex++;\n          }\n          currentPathIndex++;\n      }\n      return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };\n  }\n  /**\n   * @param {?} segmentGroup\n   * @param {?} startIndex\n   * @param {?} commands\n   * @return {?}\n   */\n  function createNewSegmentGroup(segmentGroup, startIndex, commands) {\n      var /** @type {?} */ paths = segmentGroup.segments.slice(0, startIndex);\n      var /** @type {?} */ i = 0;\n      while (i < commands.length) {\n          if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {\n              var /** @type {?} */ children = createNewSegmentChildren(commands[i].outlets);\n              return new UrlSegmentGroup(paths, children);\n          }\n          // if we start with an object literal, we need to reuse the path part from the segment\n          if (i === 0 && isMatrixParams(commands[0])) {\n              var /** @type {?} */ p = segmentGroup.segments[startIndex];\n              paths.push(new UrlSegment(p.path, commands[0]));\n              i++;\n              continue;\n          }\n          var /** @type {?} */ curr = getPath(commands[i]);\n          var /** @type {?} */ next = (i < commands.length - 1) ? commands[i + 1] : null;\n          if (curr && next && isMatrixParams(next)) {\n              paths.push(new UrlSegment(curr, stringify(next)));\n              i += 2;\n          }\n          else {\n              paths.push(new UrlSegment(curr, {}));\n              i++;\n          }\n      }\n      return new UrlSegmentGroup(paths, {});\n  }\n  /**\n   * @param {?} outlets\n   * @return {?}\n   */\n  function createNewSegmentChildren(outlets) {\n      var /** @type {?} */ children = {};\n      forEach(outlets, function (commands, outlet) {\n          if (commands !== null) {\n              children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n          }\n      });\n      return children;\n  }\n  /**\n   * @param {?} params\n   * @return {?}\n   */\n  function stringify(params) {\n      var /** @type {?} */ res = {};\n      forEach(params, function (v, k) { return res[k] = \"\" + v; });\n      return res;\n  }\n  /**\n   * @param {?} path\n   * @param {?} params\n   * @param {?} segment\n   * @return {?}\n   */\n  function compare(path, params, segment) {\n      return path == segment.path && shallowEqual(params, segment.parameters);\n  }\n\n  var NoMatch$1 = (function () {\n      function NoMatch() {\n      }\n      return NoMatch;\n  }());\n  /**\n   * @param {?} rootComponentType\n   * @param {?} config\n   * @param {?} urlTree\n   * @param {?} url\n   * @return {?}\n   */\n  function recognize(rootComponentType, config, urlTree, url) {\n      return new Recognizer(rootComponentType, config, urlTree, url).recognize();\n  }\n  var Recognizer = (function () {\n      /**\n       * @param {?} rootComponentType\n       * @param {?} config\n       * @param {?} urlTree\n       * @param {?} url\n       */\n      function Recognizer(rootComponentType, config, urlTree, url) {\n          this.rootComponentType = rootComponentType;\n          this.config = config;\n          this.urlTree = urlTree;\n          this.url = url;\n      }\n      /**\n       * @return {?}\n       */\n      Recognizer.prototype.recognize = function () {\n          try {\n              var /** @type {?} */ rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config).segmentGroup;\n              var /** @type {?} */ children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);\n              var /** @type {?} */ root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});\n              var /** @type {?} */ rootNode = new TreeNode(root, children);\n              var /** @type {?} */ routeState = new RouterStateSnapshot(this.url, rootNode);\n              this.inheriteParamsAndData(routeState._root);\n              return rxjs_observable_of.of(routeState);\n          }\n          catch (e) {\n              return new rxjs_Observable.Observable(function (obs) { return obs.error(e); });\n          }\n      };\n      /**\n       * @param {?} routeNode\n       * @return {?}\n       */\n      Recognizer.prototype.inheriteParamsAndData = function (routeNode) {\n          var _this = this;\n          var /** @type {?} */ route = routeNode.value;\n          var /** @type {?} */ i = inheritedParamsDataResolve(route);\n          route.params = Object.freeze(i.params);\n          route.data = Object.freeze(i.data);\n          routeNode.children.forEach(function (n) { return _this.inheriteParamsAndData(n); });\n      };\n      /**\n       * @param {?} config\n       * @param {?} segmentGroup\n       * @param {?} outlet\n       * @return {?}\n       */\n      Recognizer.prototype.processSegmentGroup = function (config, segmentGroup, outlet) {\n          if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n              return this.processChildren(config, segmentGroup);\n          }\n          else {\n              return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);\n          }\n      };\n      /**\n       * @param {?} config\n       * @param {?} segmentGroup\n       * @return {?}\n       */\n      Recognizer.prototype.processChildren = function (config, segmentGroup) {\n          var _this = this;\n          var /** @type {?} */ children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) { return _this.processSegmentGroup(config, child, childOutlet); });\n          checkOutletNameUniqueness(children);\n          sortActivatedRouteSnapshots(children);\n          return children;\n      };\n      /**\n       * @param {?} config\n       * @param {?} segmentGroup\n       * @param {?} segments\n       * @param {?} outlet\n       * @return {?}\n       */\n      Recognizer.prototype.processSegment = function (config, segmentGroup, segments, outlet) {\n          for (var _i = 0, config_1 = config; _i < config_1.length; _i++) {\n              var r = config_1[_i];\n              try {\n                  return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);\n              }\n              catch (e) {\n                  if (!(e instanceof NoMatch$1))\n                      throw e;\n              }\n          }\n          if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n              return [];\n          }\n          else {\n              throw new NoMatch$1();\n          }\n      };\n      /**\n       * @param {?} segmentGroup\n       * @param {?} segments\n       * @param {?} outlet\n       * @return {?}\n       */\n      Recognizer.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {\n          return segments.length === 0 && !segmentGroup.children[outlet];\n      };\n      /**\n       * @param {?} route\n       * @param {?} rawSegment\n       * @param {?} segments\n       * @param {?} outlet\n       * @return {?}\n       */\n      Recognizer.prototype.processSegmentAgainstRoute = function (route, rawSegment, segments, outlet) {\n          if (route.redirectTo)\n              throw new NoMatch$1();\n          if ((route.outlet ? route.outlet : PRIMARY_OUTLET) !== outlet)\n              throw new NoMatch$1();\n          if (route.path === '**') {\n              var /** @type {?} */ params = segments.length > 0 ? last(segments).parameters : {};\n              var /** @type {?} */ snapshot_1 = new ActivatedRouteSnapshot(segments, params, Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));\n              return [new TreeNode(snapshot_1, [])];\n          }\n          var _a = match$1(rawSegment, route, segments), consumedSegments = _a.consumedSegments, parameters = _a.parameters, lastChild = _a.lastChild;\n          var /** @type {?} */ rawSlicedSegments = segments.slice(lastChild);\n          var /** @type {?} */ childConfig = getChildConfig(route);\n          var _b = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _b.segmentGroup, slicedSegments = _b.slicedSegments;\n          var /** @type {?} */ snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));\n          if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n              var /** @type {?} */ children = this.processChildren(childConfig, segmentGroup);\n              return [new TreeNode(snapshot, children)];\n          }\n          else if (childConfig.length === 0 && slicedSegments.length === 0) {\n              return [new TreeNode(snapshot, [])];\n          }\n          else {\n              var /** @type {?} */ children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);\n              return [new TreeNode(snapshot, children)];\n          }\n      };\n      return Recognizer;\n  }());\n  /**\n   * @param {?} nodes\n   * @return {?}\n   */\n  function sortActivatedRouteSnapshots(nodes) {\n      nodes.sort(function (a, b) {\n          if (a.value.outlet === PRIMARY_OUTLET)\n              return -1;\n          if (b.value.outlet === PRIMARY_OUTLET)\n              return 1;\n          return a.value.outlet.localeCompare(b.value.outlet);\n      });\n  }\n  /**\n   * @param {?} route\n   * @return {?}\n   */\n  function getChildConfig(route) {\n      if (route.children) {\n          return route.children;\n      }\n      else if (route.loadChildren) {\n          return ((route))._loadedConfig.routes;\n      }\n      else {\n          return [];\n      }\n  }\n  /**\n   * @param {?} segmentGroup\n   * @param {?} route\n   * @param {?} segments\n   * @return {?}\n   */\n  function match$1(segmentGroup, route, segments) {\n      if (route.path === '') {\n          if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n              throw new NoMatch$1();\n          }\n          else {\n              return { consumedSegments: [], lastChild: 0, parameters: {} };\n          }\n      }\n      var /** @type {?} */ matcher = route.matcher || defaultUrlMatcher;\n      var /** @type {?} */ res = matcher(segments, segmentGroup, route);\n      if (!res)\n          throw new NoMatch$1();\n      var /** @type {?} */ posParams = {};\n      forEach(res.posParams, function (v, k) { posParams[k] = v.path; });\n      var /** @type {?} */ parameters = merge(posParams, res.consumed[res.consumed.length - 1].parameters);\n      return { consumedSegments: res.consumed, lastChild: res.consumed.length, parameters: parameters };\n  }\n  /**\n   * @param {?} nodes\n   * @return {?}\n   */\n  function checkOutletNameUniqueness(nodes) {\n      var /** @type {?} */ names = {};\n      nodes.forEach(function (n) {\n          var /** @type {?} */ routeWithSameOutletName = names[n.value.outlet];\n          if (routeWithSameOutletName) {\n              var /** @type {?} */ p = routeWithSameOutletName.url.map(function (s) { return s.toString(); }).join('/');\n              var /** @type {?} */ c = n.value.url.map(function (s) { return s.toString(); }).join('/');\n              throw new Error(\"Two segments cannot have the same outlet name: '\" + p + \"' and '\" + c + \"'.\");\n          }\n          names[n.value.outlet] = n.value;\n      });\n  }\n  /**\n   * @param {?} segmentGroup\n   * @return {?}\n   */\n  function getSourceSegmentGroup(segmentGroup) {\n      var /** @type {?} */ s = segmentGroup;\n      while (s._sourceSegment) {\n          s = s._sourceSegment;\n      }\n      return s;\n  }\n  /**\n   * @param {?} segmentGroup\n   * @return {?}\n   */\n  function getPathIndexShift(segmentGroup) {\n      var /** @type {?} */ s = segmentGroup;\n      var /** @type {?} */ res = (s._segmentIndexShift ? s._segmentIndexShift : 0);\n      while (s._sourceSegment) {\n          s = s._sourceSegment;\n          res += (s._segmentIndexShift ? s._segmentIndexShift : 0);\n      }\n      return res - 1;\n  }\n  /**\n   * @param {?} segmentGroup\n   * @param {?} consumedSegments\n   * @param {?} slicedSegments\n   * @param {?} config\n   * @return {?}\n   */\n  function split$1(segmentGroup, consumedSegments, slicedSegments, config) {\n      if (slicedSegments.length > 0 &&\n          containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n          var /** @type {?} */ s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n          s._sourceSegment = segmentGroup;\n          s._segmentIndexShift = consumedSegments.length;\n          return { segmentGroup: s, slicedSegments: [] };\n      }\n      else if (slicedSegments.length === 0 &&\n          containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n          var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n          s._sourceSegment = segmentGroup;\n          s._segmentIndexShift = consumedSegments.length;\n          return { segmentGroup: s, slicedSegments: slicedSegments };\n      }\n      else {\n          var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n          s._sourceSegment = segmentGroup;\n          s._segmentIndexShift = consumedSegments.length;\n          return { segmentGroup: s, slicedSegments: slicedSegments };\n      }\n  }\n  /**\n   * @param {?} segmentGroup\n   * @param {?} slicedSegments\n   * @param {?} routes\n   * @param {?} children\n   * @return {?}\n   */\n  function addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n      var /** @type {?} */ res = {};\n      for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n          var r = routes_1[_i];\n          if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$2(r)]) {\n              var /** @type {?} */ s = new UrlSegmentGroup([], {});\n              s._sourceSegment = segmentGroup;\n              s._segmentIndexShift = segmentGroup.segments.length;\n              res[getOutlet$2(r)] = s;\n          }\n      }\n      return merge(children, res);\n  }\n  /**\n   * @param {?} segmentGroup\n   * @param {?} consumedSegments\n   * @param {?} routes\n   * @param {?} primarySegment\n   * @return {?}\n   */\n  function createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {\n      var /** @type {?} */ res = {};\n      res[PRIMARY_OUTLET] = primarySegment;\n      primarySegment._sourceSegment = segmentGroup;\n      primarySegment._segmentIndexShift = consumedSegments.length;\n      for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {\n          var r = routes_2[_i];\n          if (r.path === '' && getOutlet$2(r) !== PRIMARY_OUTLET) {\n              var /** @type {?} */ s = new UrlSegmentGroup([], {});\n              s._sourceSegment = segmentGroup;\n              s._segmentIndexShift = consumedSegments.length;\n              res[getOutlet$2(r)] = s;\n          }\n      }\n      return res;\n  }\n  /**\n   * @param {?} segmentGroup\n   * @param {?} slicedSegments\n   * @param {?} routes\n   * @return {?}\n   */\n  function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n      return routes\n          .filter(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r) &&\n          getOutlet$2(r) !== PRIMARY_OUTLET; })\n          .length > 0;\n  }\n  /**\n   * @param {?} segmentGroup\n   * @param {?} slicedSegments\n   * @param {?} routes\n   * @return {?}\n   */\n  function containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\n      return routes.filter(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r); }).length > 0;\n  }\n  /**\n   * @param {?} segmentGroup\n   * @param {?} slicedSegments\n   * @param {?} r\n   * @return {?}\n   */\n  function emptyPathMatch(segmentGroup, slicedSegments, r) {\n      if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full')\n          return false;\n      return r.path === '' && r.redirectTo === undefined;\n  }\n  /**\n   * @param {?} route\n   * @return {?}\n   */\n  function getOutlet$2(route) {\n      return route.outlet ? route.outlet : PRIMARY_OUTLET;\n  }\n  /**\n   * @param {?} route\n   * @return {?}\n   */\n  function getData(route) {\n      return route.data ? route.data : {};\n  }\n  /**\n   * @param {?} route\n   * @return {?}\n   */\n  function getResolve(route) {\n      return route.resolve ? route.resolve : {};\n  }\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  /**\n   *  *\n   */\n  var RouterOutletMap = (function () {\n      function RouterOutletMap() {\n          /** @internal */\n          this._outlets = {};\n      }\n      /**\n       *  Adds an outlet to this map.\n       * @param {?} name\n       * @param {?} outlet\n       * @return {?}\n       */\n      RouterOutletMap.prototype.registerOutlet = function (name, outlet) { this._outlets[name] = outlet; };\n      /**\n       *  Removes an outlet from this map.\n       * @param {?} name\n       * @return {?}\n       */\n      RouterOutletMap.prototype.removeOutlet = function (name) { this._outlets[name] = undefined; };\n      return RouterOutletMap;\n  }());\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  /**\n   *  *\n   * @abstract\n   */\n  var UrlHandlingStrategy = (function () {\n      function UrlHandlingStrategy() {\n      }\n      /**\n       *  Tells the router if this URL should be processed.\n        * *\n        * When it returns true, the router will execute the regular navigation.\n        * When it returns false, the router will set the router state to an empty state.\n        * As a result, all the active components will be destroyed.\n        * *\n       * @abstract\n       * @param {?} url\n       * @return {?}\n       */\n      UrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { };\n      /**\n       *  Extracts the part of the URL that should be handled by the router.\n        * The rest of the URL will remain untouched.\n       * @abstract\n       * @param {?} url\n       * @return {?}\n       */\n      UrlHandlingStrategy.prototype.extract = function (url) { };\n      /**\n       *  Merges the URL fragment with the rest of the URL.\n       * @abstract\n       * @param {?} newUrlPart\n       * @param {?} rawUrl\n       * @return {?}\n       */\n      UrlHandlingStrategy.prototype.merge = function (newUrlPart, rawUrl) { };\n      return UrlHandlingStrategy;\n  }());\n  /**\n   * @experimental\n   */\n  var DefaultUrlHandlingStrategy = (function () {\n      function DefaultUrlHandlingStrategy() {\n      }\n      /**\n       * @param {?} url\n       * @return {?}\n       */\n      DefaultUrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { return true; };\n      /**\n       * @param {?} url\n       * @return {?}\n       */\n      DefaultUrlHandlingStrategy.prototype.extract = function (url) { return url; };\n      /**\n       * @param {?} newUrlPart\n       * @param {?} wholeUrl\n       * @return {?}\n       */\n      DefaultUrlHandlingStrategy.prototype.merge = function (newUrlPart, wholeUrl) { return newUrlPart; };\n      return DefaultUrlHandlingStrategy;\n  }());\n\n  /**\n   *  *\n   */\n  var NavigationStart = (function () {\n      /**\n       * @param {?} id\n       * @param {?} url\n       */\n      function NavigationStart(id, url) {\n          this.id = id;\n          this.url = url;\n      }\n      /**\n       * @return {?}\n       */\n      NavigationStart.prototype.toString = function () { return \"NavigationStart(id: \" + this.id + \", url: '\" + this.url + \"')\"; };\n      return NavigationStart;\n  }());\n  /**\n   *  *\n   */\n  var NavigationEnd = (function () {\n      /**\n       * @param {?} id\n       * @param {?} url\n       * @param {?} urlAfterRedirects\n       */\n      function NavigationEnd(id, url, urlAfterRedirects) {\n          this.id = id;\n          this.url = url;\n          this.urlAfterRedirects = urlAfterRedirects;\n      }\n      /**\n       * @return {?}\n       */\n      NavigationEnd.prototype.toString = function () {\n          return \"NavigationEnd(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"')\";\n      };\n      return NavigationEnd;\n  }());\n  /**\n   *  *\n   */\n  var NavigationCancel = (function () {\n      /**\n       * @param {?} id\n       * @param {?} url\n       * @param {?} reason\n       */\n      function NavigationCancel(id, url, reason) {\n          this.id = id;\n          this.url = url;\n          this.reason = reason;\n      }\n      /**\n       * @return {?}\n       */\n      NavigationCancel.prototype.toString = function () { return \"NavigationCancel(id: \" + this.id + \", url: '\" + this.url + \"')\"; };\n      return NavigationCancel;\n  }());\n  /**\n   *  *\n   */\n  var NavigationError = (function () {\n      /**\n       * @param {?} id\n       * @param {?} url\n       * @param {?} error\n       */\n      function NavigationError(id, url, error) {\n          this.id = id;\n          this.url = url;\n          this.error = error;\n      }\n      /**\n       * @return {?}\n       */\n      NavigationError.prototype.toString = function () {\n          return \"NavigationError(id: \" + this.id + \", url: '\" + this.url + \"', error: \" + this.error + \")\";\n      };\n      return NavigationError;\n  }());\n  /**\n   *  *\n   */\n  var RoutesRecognized = (function () {\n      /**\n       * @param {?} id\n       * @param {?} url\n       * @param {?} urlAfterRedirects\n       * @param {?} state\n       */\n      function RoutesRecognized(id, url, urlAfterRedirects, state) {\n          this.id = id;\n          this.url = url;\n          this.urlAfterRedirects = urlAfterRedirects;\n          this.state = state;\n      }\n      /**\n       * @return {?}\n       */\n      RoutesRecognized.prototype.toString = function () {\n          return \"RoutesRecognized(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \")\";\n      };\n      return RoutesRecognized;\n  }());\n  /**\n   * @param {?} error\n   * @return {?}\n   */\n  function defaultErrorHandler(error) {\n      throw error;\n  }\n  /**\n   *  Does not detach any subtrees. Reuses routes as long as their route config is the same.\n   */\n  var DefaultRouteReuseStrategy = (function () {\n      function DefaultRouteReuseStrategy() {\n      }\n      /**\n       * @param {?} route\n       * @return {?}\n       */\n      DefaultRouteReuseStrategy.prototype.shouldDetach = function (route) { return false; };\n      /**\n       * @param {?} route\n       * @param {?} detachedTree\n       * @return {?}\n       */\n      DefaultRouteReuseStrategy.prototype.store = function (route, detachedTree) { };\n      /**\n       * @param {?} route\n       * @return {?}\n       */\n      DefaultRouteReuseStrategy.prototype.shouldAttach = function (route) { return false; };\n      /**\n       * @param {?} route\n       * @return {?}\n       */\n      DefaultRouteReuseStrategy.prototype.retrieve = function (route) { return null; };\n      /**\n       * @param {?} future\n       * @param {?} curr\n       * @return {?}\n       */\n      DefaultRouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) {\n          return future.routeConfig === curr.routeConfig;\n      };\n      return DefaultRouteReuseStrategy;\n  }());\n  /**\n   *  *\n    * See {@link Routes} for more details and examples.\n    * *\n    * *\n   */\n  var Router = (function () {\n      /**\n       * @param {?} rootComponentType\n       * @param {?} urlSerializer\n       * @param {?} outletMap\n       * @param {?} location\n       * @param {?} injector\n       * @param {?} loader\n       * @param {?} compiler\n       * @param {?} config\n       */\n      function Router(rootComponentType, urlSerializer, outletMap, location, injector, loader, compiler, config) {\n          this.rootComponentType = rootComponentType;\n          this.urlSerializer = urlSerializer;\n          this.outletMap = outletMap;\n          this.location = location;\n          this.injector = injector;\n          this.config = config;\n          this.navigations = new rxjs_BehaviorSubject.BehaviorSubject(null);\n          this.routerEvents = new rxjs_Subject.Subject();\n          this.navigationId = 0;\n          /**\n           * Error handler that is invoked when a navigation errors.\n           *\n           * See {@link ErrorHandler} for more information.\n           */\n          this.errorHandler = defaultErrorHandler;\n          /**\n           * Indicates if at least one navigation happened.\n           */\n          this.navigated = false;\n          /**\n           * Extracts and merges URLs. Used for Angular 1 to Angular 2 migrations.\n           */\n          this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();\n          this.routeReuseStrategy = new DefaultRouteReuseStrategy();\n          this.resetConfig(config);\n          this.currentUrlTree = createEmptyUrlTree();\n          this.rawUrlTree = this.currentUrlTree;\n          this.configLoader = new RouterConfigLoader(loader, compiler);\n          this.currentRouterState = createEmptyState(this.currentUrlTree, this.rootComponentType);\n          this.processNavigations();\n      }\n      /**\n       *  TODO: this should be removed once the constructor of the router made internal\n       * @param {?} rootComponentType\n       * @return {?}\n       */\n      Router.prototype.resetRootComponentType = function (rootComponentType) {\n          this.rootComponentType = rootComponentType;\n          // TODO: vsavkin router 4.0 should make the root component set to null\n          // this will simplify the lifecycle of the router.\n          this.currentRouterState.root.component = this.rootComponentType;\n      };\n      /**\n       *  Sets up the location change listener and performs the initial navigation.\n       * @return {?}\n       */\n      Router.prototype.initialNavigation = function () {\n          this.setUpLocationChangeListener();\n          this.navigateByUrl(this.location.path(true), { replaceUrl: true });\n      };\n      /**\n       *  Sets up the location change listener.\n       * @return {?}\n       */\n      Router.prototype.setUpLocationChangeListener = function () {\n          var _this = this;\n          // Zone.current.wrap is needed because of the issue with RxJS scheduler,\n          // which does not work properly with zone.js in IE and Safari\n          if (!this.locationSubscription) {\n              this.locationSubscription = (this.location.subscribe(Zone.current.wrap(function (change) {\n                  var /** @type {?} */ rawUrlTree = _this.urlSerializer.parse(change['url']);\n                  var /** @type {?} */ source = change['type'] === 'popstate' ? 'popstate' : 'hashchange';\n                  setTimeout(function () { _this.scheduleNavigation(rawUrlTree, source, { replaceUrl: true }); }, 0);\n              })));\n          }\n      };\n      Object.defineProperty(Router.prototype, \"routerState\", {\n          /**\n           *  The current route state\n           * @return {?}\n           */\n          get: function () { return this.currentRouterState; },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(Router.prototype, \"url\", {\n          /**\n           *  The current url\n           * @return {?}\n           */\n          get: function () { return this.serializeUrl(this.currentUrlTree); },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(Router.prototype, \"events\", {\n          /**\n           *  An observable of router events\n           * @return {?}\n           */\n          get: function () { return this.routerEvents; },\n          enumerable: true,\n          configurable: true\n      });\n      /**\n       *  Resets the configuration used for navigation and generating links.\n        * *\n        * ### Usage\n        * *\n        * ```\n        * router.resetConfig([\n        * { path: 'team/:id', component: TeamCmp, children: [\n        * { path: 'simple', component: SimpleCmp },\n        * { path: 'user/:name', component: UserCmp }\n        * ]}\n        * ]);\n        * ```\n       * @param {?} config\n       * @return {?}\n       */\n      Router.prototype.resetConfig = function (config) {\n          validateConfig(config);\n          this.config = config;\n      };\n      /**\n       * @return {?}\n       */\n      Router.prototype.ngOnDestroy = function () { this.dispose(); };\n      /**\n       *  Disposes of the router\n       * @return {?}\n       */\n      Router.prototype.dispose = function () {\n          if (this.locationSubscription) {\n              this.locationSubscription.unsubscribe();\n              this.locationSubscription = null;\n          }\n      };\n      /**\n       *  Applies an array of commands to the current url tree and creates a new url tree.\n        * *\n        * When given an activate route, applies the given commands starting from the route.\n        * When not given a route, applies the given command starting from the root.\n        * *\n        * ### Usage\n        * *\n        * ```\n        * // create /team/33/user/11\n        * router.createUrlTree(['/team', 33, 'user', 11]);\n        * *\n        * // create /team/33;expand=true/user/11\n        * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n        * *\n        * // you can collapse static segments like this (this works only with the first passed-in value):\n        * router.createUrlTree(['/team/33/user', userId]);\n        * *\n        * // If the first segment can contain slashes, and you do not want the router to split it, you\n        * // can do the following:\n        * *\n        * router.createUrlTree([{segmentPath: '/one/two'}]);\n        * *\n        * // create /team/33/(user/11//right:chat)\n        * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n        * *\n        * // remove the right secondary node\n        * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n        * *\n        * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n        * *\n        * // navigate to /team/33/user/11/details\n        * router.createUrlTree(['details'], {relativeTo: route});\n        * *\n        * // navigate to /team/33/user/22\n        * router.createUrlTree(['../22'], {relativeTo: route});\n        * *\n        * // navigate to /team/44/user/22\n        * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n        * ```\n       * @param {?} commands\n       * @param {?=} __1\n       * @return {?}\n       */\n      Router.prototype.createUrlTree = function (commands, _a) {\n          var _b = _a === void 0 ? {} : _a, relativeTo = _b.relativeTo, queryParams = _b.queryParams, fragment = _b.fragment, preserveQueryParams = _b.preserveQueryParams, preserveFragment = _b.preserveFragment;\n          var /** @type {?} */ a = relativeTo || this.routerState.root;\n          var /** @type {?} */ q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams;\n          var /** @type {?} */ f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n          return createUrlTree(a, this.currentUrlTree, commands, q, f);\n      };\n      /**\n       *  Navigate based on the provided url. This navigation is always absolute.\n        * *\n        * Returns a promise that:\n        * - resolves to 'true' when navigation succeeds,\n        * - resolves to 'false' when navigation fails,\n        * - is rejected when an error happens.\n        * *\n        * ### Usage\n        * *\n        * ```\n        * router.navigateByUrl(\"/team/33/user/11\");\n        * *\n        * // Navigate without updating the URL\n        * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n        * ```\n        * *\n        * In opposite to `navigate`, `navigateByUrl` takes a whole URL\n        * and does not apply any delta to the current one.\n       * @param {?} url\n       * @param {?=} extras\n       * @return {?}\n       */\n      Router.prototype.navigateByUrl = function (url, extras) {\n          if (extras === void 0) { extras = { skipLocationChange: false }; }\n          if (url instanceof UrlTree) {\n              return this.scheduleNavigation(this.urlHandlingStrategy.merge(url, this.rawUrlTree), 'imperative', extras);\n          }\n          var /** @type {?} */ urlTree = this.urlSerializer.parse(url);\n          return this.scheduleNavigation(this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree), 'imperative', extras);\n      };\n      /**\n       *  Navigate based on the provided array of commands and a starting point.\n        * If no starting route is provided, the navigation is absolute.\n        * *\n        * Returns a promise that:\n        * - resolves to 'true' when navigation succeeds,\n        * - resolves to 'false' when navigation fails,\n        * - is rejected when an error happens.\n        * *\n        * ### Usage\n        * *\n        * ```\n        * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n        * *\n        * // Navigate without updating the URL\n        * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n        * ```\n        * *\n        * In opposite to `navigateByUrl`, `navigate` always takes a delta that is applied to the current\n        * URL.\n       * @param {?} commands\n       * @param {?=} extras\n       * @return {?}\n       */\n      Router.prototype.navigate = function (commands, extras) {\n          if (extras === void 0) { extras = { skipLocationChange: false }; }\n          if (typeof extras.queryParams === 'object' && extras.queryParams !== null) {\n              extras.queryParams = this.removeEmptyProps(extras.queryParams);\n          }\n          return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n      };\n      /**\n       *  Serializes a {@link UrlTree} into a string\n       * @param {?} url\n       * @return {?}\n       */\n      Router.prototype.serializeUrl = function (url) { return this.urlSerializer.serialize(url); };\n      /**\n       *  Parses a string into a {@link UrlTree}\n       * @param {?} url\n       * @return {?}\n       */\n      Router.prototype.parseUrl = function (url) { return this.urlSerializer.parse(url); };\n      /**\n       *  Returns whether the url is activated\n       * @param {?} url\n       * @param {?} exact\n       * @return {?}\n       */\n      Router.prototype.isActive = function (url, exact) {\n          if (url instanceof UrlTree) {\n              return containsTree(this.currentUrlTree, url, exact);\n          }\n          else {\n              var /** @type {?} */ urlTree = this.urlSerializer.parse(url);\n              return containsTree(this.currentUrlTree, urlTree, exact);\n          }\n      };\n      /**\n       * @param {?} params\n       * @return {?}\n       */\n      Router.prototype.removeEmptyProps = function (params) {\n          return Object.keys(params).reduce(function (result, key) {\n              var /** @type {?} */ value = params[key];\n              if (value !== null && value !== undefined) {\n                  result[key] = value;\n              }\n              return result;\n          }, {});\n      };\n      /**\n       * @return {?}\n       */\n      Router.prototype.processNavigations = function () {\n          var _this = this;\n          rxjs_operator_concatMap.concatMap\n              .call(this.navigations, function (nav) {\n              if (nav) {\n                  _this.executeScheduledNavigation(nav);\n                  // a failed navigation should not stop the router from processing\n                  // further navigations => the catch\n                  return nav.promise.catch(function () { });\n              }\n              else {\n                  return (rxjs_observable_of.of(null));\n              }\n          })\n              .subscribe(function () { });\n      };\n      /**\n       * @param {?} rawUrl\n       * @param {?} source\n       * @param {?} extras\n       * @return {?}\n       */\n      Router.prototype.scheduleNavigation = function (rawUrl, source, extras) {\n          var /** @type {?} */ lastNavigation = this.navigations.value;\n          // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),\n          // and that navigation results in 'replaceState' that leads to the same URL,\n          // we should skip those.\n          if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' &&\n              lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n              return null; // return value is not used\n          }\n          // Because of a bug in IE and Edge, the location class fires two events (popstate and\n          // hashchange)\n          // every single time. The second one should be ignored. Otherwise, the URL will flicker.\n          if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' &&\n              lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n              return null; // return value is not used\n          }\n          var /** @type {?} */ resolve = null;\n          var /** @type {?} */ reject = null;\n          var /** @type {?} */ promise = new Promise(function (res, rej) {\n              resolve = res;\n              reject = rej;\n          });\n          var /** @type {?} */ id = ++this.navigationId;\n          this.navigations.next({ id: id, source: source, rawUrl: rawUrl, extras: extras, resolve: resolve, reject: reject, promise: promise });\n          // Make sure that the error is propagated even though `processNavigations` catch\n          // handler does not rethrow\n          return promise.catch(function (e) { return Promise.reject(e); });\n      };\n      /**\n       * @param {?} __0\n       * @return {?}\n       */\n      Router.prototype.executeScheduledNavigation = function (_a) {\n          var _this = this;\n          var id = _a.id, rawUrl = _a.rawUrl, extras = _a.extras, resolve = _a.resolve, reject = _a.reject;\n          var /** @type {?} */ url = this.urlHandlingStrategy.extract(rawUrl);\n          var /** @type {?} */ urlTransition = !this.navigated || url.toString() !== this.currentUrlTree.toString();\n          if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(rawUrl)) {\n              this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));\n              Promise.resolve()\n                  .then(function (_) { return _this.runNavigate(url, rawUrl, extras.skipLocationChange, extras.replaceUrl, id, null); })\n                  .then(resolve, reject);\n          }\n          else if (urlTransition && this.rawUrlTree &&\n              this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) {\n              this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));\n              Promise.resolve()\n                  .then(function (_) { return _this.runNavigate(url, rawUrl, false, false, id, createEmptyState(url, _this.rootComponentType).snapshot); })\n                  .then(resolve, reject);\n          }\n          else {\n              this.rawUrlTree = rawUrl;\n              resolve(null);\n          }\n      };\n      /**\n       * @param {?} url\n       * @param {?} rawUrl\n       * @param {?} shouldPreventPushState\n       * @param {?} shouldReplaceUrl\n       * @param {?} id\n       * @param {?} precreatedState\n       * @return {?}\n       */\n      Router.prototype.runNavigate = function (url, rawUrl, shouldPreventPushState, shouldReplaceUrl, id, precreatedState) {\n          var _this = this;\n          if (id !== this.navigationId) {\n              this.location.go(this.urlSerializer.serialize(this.currentUrlTree));\n              this.routerEvents.next(new NavigationCancel(id, this.serializeUrl(url), \"Navigation ID \" + id + \" is not equal to the current navigation id \" + this.navigationId));\n              return Promise.resolve(false);\n          }\n          return new Promise(function (resolvePromise, rejectPromise) {\n              // create an observable of the url and route state snapshot\n              // this operation do not result in any side effects\n              var /** @type {?} */ urlAndSnapshot$;\n              if (!precreatedState) {\n                  var /** @type {?} */ redirectsApplied$ = applyRedirects(_this.injector, _this.configLoader, _this.urlSerializer, url, _this.config);\n                  urlAndSnapshot$ = rxjs_operator_mergeMap.mergeMap.call(redirectsApplied$, function (appliedUrl) {\n                      return rxjs_operator_map.map.call(recognize(_this.rootComponentType, _this.config, appliedUrl, _this.serializeUrl(appliedUrl)), function (snapshot) {\n                          _this.routerEvents.next(new RoutesRecognized(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl), snapshot));\n                          return { appliedUrl: appliedUrl, snapshot: snapshot };\n                      });\n                  });\n              }\n              else {\n                  urlAndSnapshot$ = rxjs_observable_of.of({ appliedUrl: url, snapshot: precreatedState });\n              }\n              // run preactivation: guards and data resolvers\n              var /** @type {?} */ preActivation;\n              var /** @type {?} */ preactivationTraverse$ = rxjs_operator_map.map.call(urlAndSnapshot$, function (_a) {\n                  var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;\n                  preActivation =\n                      new PreActivation(snapshot, _this.currentRouterState.snapshot, _this.injector);\n                  preActivation.traverse(_this.outletMap);\n                  return { appliedUrl: appliedUrl, snapshot: snapshot };\n              });\n              var /** @type {?} */ preactivationCheckGuards = rxjs_operator_mergeMap.mergeMap.call(preactivationTraverse$, function (_a) {\n                  var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;\n                  if (_this.navigationId !== id)\n                      return rxjs_observable_of.of(false);\n                  return rxjs_operator_map.map.call(preActivation.checkGuards(), function (shouldActivate) {\n                      return { appliedUrl: appliedUrl, snapshot: snapshot, shouldActivate: shouldActivate };\n                  });\n              });\n              var /** @type {?} */ preactivationResolveData$ = rxjs_operator_mergeMap.mergeMap.call(preactivationCheckGuards, function (p) {\n                  if (_this.navigationId !== id)\n                      return rxjs_observable_of.of(false);\n                  if (p.shouldActivate) {\n                      return rxjs_operator_map.map.call(preActivation.resolveData(), function () { return p; });\n                  }\n                  else {\n                      return rxjs_observable_of.of(p);\n                  }\n              });\n              // create router state\n              // this operation has side effects => route state is being affected\n              var /** @type {?} */ routerState$ = rxjs_operator_map.map.call(preactivationResolveData$, function (_a) {\n                  var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot, shouldActivate = _a.shouldActivate;\n                  if (shouldActivate) {\n                      var /** @type {?} */ state = createRouterState(_this.routeReuseStrategy, snapshot, _this.currentRouterState);\n                      return { appliedUrl: appliedUrl, state: state, shouldActivate: shouldActivate };\n                  }\n                  else {\n                      return { appliedUrl: appliedUrl, state: null, shouldActivate: shouldActivate };\n                  }\n              });\n              // applied the new router state\n              // this operation has side effects\n              var /** @type {?} */ navigationIsSuccessful;\n              var /** @type {?} */ storedState = _this.currentRouterState;\n              var /** @type {?} */ storedUrl = _this.currentUrlTree;\n              routerState$\n                  .forEach(function (_a) {\n                  var appliedUrl = _a.appliedUrl, state = _a.state, shouldActivate = _a.shouldActivate;\n                  if (!shouldActivate || id !== _this.navigationId) {\n                      navigationIsSuccessful = false;\n                      return;\n                  }\n                  _this.currentUrlTree = appliedUrl;\n                  _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);\n                  _this.currentRouterState = state;\n                  if (!shouldPreventPushState) {\n                      var /** @type {?} */ path = _this.urlSerializer.serialize(_this.rawUrlTree);\n                      if (_this.location.isCurrentPathEqualTo(path) || shouldReplaceUrl) {\n                          _this.location.replaceState(path);\n                      }\n                      else {\n                          _this.location.go(path);\n                      }\n                  }\n                  new ActivateRoutes(_this.routeReuseStrategy, state, storedState)\n                      .activate(_this.outletMap);\n                  navigationIsSuccessful = true;\n              })\n                  .then(function () {\n                  _this.navigated = true;\n                  if (navigationIsSuccessful) {\n                      _this.routerEvents.next(new NavigationEnd(id, _this.serializeUrl(url), _this.serializeUrl(_this.currentUrlTree)));\n                      resolvePromise(true);\n                  }\n                  else {\n                      _this.resetUrlToCurrentUrlTree();\n                      _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), ''));\n                      resolvePromise(false);\n                  }\n              }, function (e) {\n                  if (e instanceof NavigationCancelingError) {\n                      _this.resetUrlToCurrentUrlTree();\n                      _this.navigated = true;\n                      _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), e.message));\n                      resolvePromise(false);\n                  }\n                  else {\n                      _this.routerEvents.next(new NavigationError(id, _this.serializeUrl(url), e));\n                      try {\n                          resolvePromise(_this.errorHandler(e));\n                      }\n                      catch (ee) {\n                          rejectPromise(ee);\n                      }\n                  }\n                  _this.currentRouterState = storedState;\n                  _this.currentUrlTree = storedUrl;\n                  _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);\n                  _this.location.replaceState(_this.serializeUrl(_this.rawUrlTree));\n              });\n          });\n      };\n      /**\n       * @return {?}\n       */\n      Router.prototype.resetUrlToCurrentUrlTree = function () {\n          var /** @type {?} */ path = this.urlSerializer.serialize(this.rawUrlTree);\n          this.location.replaceState(path);\n      };\n      return Router;\n  }());\n  var CanActivate = (function () {\n      /**\n       * @param {?} path\n       */\n      function CanActivate(path) {\n          this.path = path;\n      }\n      Object.defineProperty(CanActivate.prototype, \"route\", {\n          /**\n           * @return {?}\n           */\n          get: function () { return this.path[this.path.length - 1]; },\n          enumerable: true,\n          configurable: true\n      });\n      return CanActivate;\n  }());\n  var CanDeactivate = (function () {\n      /**\n       * @param {?} component\n       * @param {?} route\n       */\n      function CanDeactivate(component, route) {\n          this.component = component;\n          this.route = route;\n      }\n      return CanDeactivate;\n  }());\n  var PreActivation = (function () {\n      /**\n       * @param {?} future\n       * @param {?} curr\n       * @param {?} injector\n       */\n      function PreActivation(future, curr, injector) {\n          this.future = future;\n          this.curr = curr;\n          this.injector = injector;\n          this.checks = [];\n      }\n      /**\n       * @param {?} parentOutletMap\n       * @return {?}\n       */\n      PreActivation.prototype.traverse = function (parentOutletMap) {\n          var /** @type {?} */ futureRoot = this.future._root;\n          var /** @type {?} */ currRoot = this.curr ? this.curr._root : null;\n          this.traverseChildRoutes(futureRoot, currRoot, parentOutletMap, [futureRoot.value]);\n      };\n      /**\n       * @return {?}\n       */\n      PreActivation.prototype.checkGuards = function () {\n          var _this = this;\n          if (this.checks.length === 0)\n              return rxjs_observable_of.of(true);\n          var /** @type {?} */ checks$ = rxjs_observable_from.from(this.checks);\n          var /** @type {?} */ runningChecks$ = rxjs_operator_mergeMap.mergeMap.call(checks$, function (s) {\n              if (s instanceof CanActivate) {\n                  return andObservables(rxjs_observable_from.from([_this.runCanActivateChild(s.path), _this.runCanActivate(s.route)]));\n              }\n              else if (s instanceof CanDeactivate) {\n                  // workaround https://github.com/Microsoft/TypeScript/issues/7271\n                  var /** @type {?} */ s2 = (s);\n                  return _this.runCanDeactivate(s2.component, s2.route);\n              }\n              else {\n                  throw new Error('Cannot be reached');\n              }\n          });\n          return rxjs_operator_every.every.call(runningChecks$, function (result) { return result === true; });\n      };\n      /**\n       * @return {?}\n       */\n      PreActivation.prototype.resolveData = function () {\n          var _this = this;\n          if (this.checks.length === 0)\n              return rxjs_observable_of.of(null);\n          var /** @type {?} */ checks$ = rxjs_observable_from.from(this.checks);\n          var /** @type {?} */ runningChecks$ = rxjs_operator_concatMap.concatMap.call(checks$, function (s) {\n              if (s instanceof CanActivate) {\n                  return _this.runResolve(s.route);\n              }\n              else {\n                  return rxjs_observable_of.of(null);\n              }\n          });\n          return rxjs_operator_reduce.reduce.call(runningChecks$, function (_, __) { return _; });\n      };\n      /**\n       * @param {?} futureNode\n       * @param {?} currNode\n       * @param {?} outletMap\n       * @param {?} futurePath\n       * @return {?}\n       */\n      PreActivation.prototype.traverseChildRoutes = function (futureNode, currNode, outletMap, futurePath) {\n          var _this = this;\n          var /** @type {?} */ prevChildren = nodeChildrenAsMap(currNode);\n          futureNode.children.forEach(function (c) {\n              _this.traverseRoutes(c, prevChildren[c.value.outlet], outletMap, futurePath.concat([c.value]));\n              delete prevChildren[c.value.outlet];\n          });\n          forEach(prevChildren, function (v, k) { return _this.deactiveRouteAndItsChildren(v, outletMap._outlets[k]); });\n      };\n      /**\n       * @param {?} futureNode\n       * @param {?} currNode\n       * @param {?} parentOutletMap\n       * @param {?} futurePath\n       * @return {?}\n       */\n      PreActivation.prototype.traverseRoutes = function (futureNode, currNode, parentOutletMap, futurePath) {\n          var /** @type {?} */ future = futureNode.value;\n          var /** @type {?} */ curr = currNode ? currNode.value : null;\n          var /** @type {?} */ outlet = parentOutletMap ? parentOutletMap._outlets[futureNode.value.outlet] : null;\n          // reusing the node\n          if (curr && future._routeConfig === curr._routeConfig) {\n              if (!equalParamsAndUrlSegments(future, curr)) {\n                  this.checks.push(new CanDeactivate(outlet.component, curr), new CanActivate(futurePath));\n              }\n              else {\n                  // we need to set the data\n                  future.data = curr.data;\n                  future._resolvedData = curr._resolvedData;\n              }\n              // If we have a component, we need to go through an outlet.\n              if (future.component) {\n                  this.traverseChildRoutes(futureNode, currNode, outlet ? outlet.outletMap : null, futurePath);\n              }\n              else {\n                  this.traverseChildRoutes(futureNode, currNode, parentOutletMap, futurePath);\n              }\n          }\n          else {\n              if (curr) {\n                  this.deactiveRouteAndItsChildren(currNode, outlet);\n              }\n              this.checks.push(new CanActivate(futurePath));\n              // If we have a component, we need to go through an outlet.\n              if (future.component) {\n                  this.traverseChildRoutes(futureNode, null, outlet ? outlet.outletMap : null, futurePath);\n              }\n              else {\n                  this.traverseChildRoutes(futureNode, null, parentOutletMap, futurePath);\n              }\n          }\n      };\n      /**\n       * @param {?} route\n       * @param {?} outlet\n       * @return {?}\n       */\n      PreActivation.prototype.deactiveRouteAndItsChildren = function (route, outlet) {\n          var _this = this;\n          var /** @type {?} */ prevChildren = nodeChildrenAsMap(route);\n          var /** @type {?} */ r = route.value;\n          forEach(prevChildren, function (v, k) {\n              if (!r.component) {\n                  _this.deactiveRouteAndItsChildren(v, outlet);\n              }\n              else if (!!outlet) {\n                  _this.deactiveRouteAndItsChildren(v, outlet.outletMap._outlets[k]);\n              }\n              else {\n                  _this.deactiveRouteAndItsChildren(v, null);\n              }\n          });\n          if (!r.component) {\n              this.checks.push(new CanDeactivate(null, r));\n          }\n          else if (outlet && outlet.isActivated) {\n              this.checks.push(new CanDeactivate(outlet.component, r));\n          }\n          else {\n              this.checks.push(new CanDeactivate(null, r));\n          }\n      };\n      /**\n       * @param {?} future\n       * @return {?}\n       */\n      PreActivation.prototype.runCanActivate = function (future) {\n          var _this = this;\n          var /** @type {?} */ canActivate = future._routeConfig ? future._routeConfig.canActivate : null;\n          if (!canActivate || canActivate.length === 0)\n              return rxjs_observable_of.of(true);\n          var /** @type {?} */ obs = rxjs_operator_map.map.call(rxjs_observable_from.from(canActivate), function (c) {\n              var /** @type {?} */ guard = _this.getToken(c, future);\n              var /** @type {?} */ observable;\n              if (guard.canActivate) {\n                  observable = wrapIntoObservable(guard.canActivate(future, _this.future));\n              }\n              else {\n                  observable = wrapIntoObservable(guard(future, _this.future));\n              }\n              return rxjs_operator_first.first.call(observable);\n          });\n          return andObservables(obs);\n      };\n      /**\n       * @param {?} path\n       * @return {?}\n       */\n      PreActivation.prototype.runCanActivateChild = function (path) {\n          var _this = this;\n          var /** @type {?} */ future = path[path.length - 1];\n          var /** @type {?} */ canActivateChildGuards = path.slice(0, path.length - 1)\n              .reverse()\n              .map(function (p) { return _this.extractCanActivateChild(p); })\n              .filter(function (_) { return _ !== null; });\n          return andObservables(rxjs_operator_map.map.call(rxjs_observable_from.from(canActivateChildGuards), function (d) {\n              var /** @type {?} */ obs = rxjs_operator_map.map.call(rxjs_observable_from.from(d.guards), function (c) {\n                  var /** @type {?} */ guard = _this.getToken(c, c.node);\n                  var /** @type {?} */ observable;\n                  if (guard.canActivateChild) {\n                      observable = wrapIntoObservable(guard.canActivateChild(future, _this.future));\n                  }\n                  else {\n                      observable = wrapIntoObservable(guard(future, _this.future));\n                  }\n                  return rxjs_operator_first.first.call(observable);\n              });\n              return andObservables(obs);\n          }));\n      };\n      /**\n       * @param {?} p\n       * @return {?}\n       */\n      PreActivation.prototype.extractCanActivateChild = function (p) {\n          var /** @type {?} */ canActivateChild = p._routeConfig ? p._routeConfig.canActivateChild : null;\n          if (!canActivateChild || canActivateChild.length === 0)\n              return null;\n          return { node: p, guards: canActivateChild };\n      };\n      /**\n       * @param {?} component\n       * @param {?} curr\n       * @return {?}\n       */\n      PreActivation.prototype.runCanDeactivate = function (component, curr) {\n          var _this = this;\n          var /** @type {?} */ canDeactivate = curr && curr._routeConfig ? curr._routeConfig.canDeactivate : null;\n          if (!canDeactivate || canDeactivate.length === 0)\n              return rxjs_observable_of.of(true);\n          var /** @type {?} */ canDeactivate$ = rxjs_operator_mergeMap.mergeMap.call(rxjs_observable_from.from(canDeactivate), function (c) {\n              var /** @type {?} */ guard = _this.getToken(c, curr);\n              var /** @type {?} */ observable;\n              if (guard.canDeactivate) {\n                  observable = wrapIntoObservable(guard.canDeactivate(component, curr, _this.curr));\n              }\n              else {\n                  observable = wrapIntoObservable(guard(component, curr, _this.curr));\n              }\n              return rxjs_operator_first.first.call(observable);\n          });\n          return rxjs_operator_every.every.call(canDeactivate$, function (result) { return result === true; });\n      };\n      /**\n       * @param {?} future\n       * @return {?}\n       */\n      PreActivation.prototype.runResolve = function (future) {\n          var /** @type {?} */ resolve = future._resolve;\n          return rxjs_operator_map.map.call(this.resolveNode(resolve, future), function (resolvedData) {\n              future._resolvedData = resolvedData;\n              future.data = merge(future.data, inheritedParamsDataResolve(future).resolve);\n              return null;\n          });\n      };\n      /**\n       * @param {?} resolve\n       * @param {?} future\n       * @return {?}\n       */\n      PreActivation.prototype.resolveNode = function (resolve, future) {\n          var _this = this;\n          return waitForMap(resolve, function (k, v) {\n              var /** @type {?} */ resolver = _this.getToken(v, future);\n              return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, _this.future)) :\n                  wrapIntoObservable(resolver(future, _this.future));\n          });\n      };\n      /**\n       * @param {?} token\n       * @param {?} snapshot\n       * @return {?}\n       */\n      PreActivation.prototype.getToken = function (token, snapshot) {\n          var /** @type {?} */ config = closestLoadedConfig(snapshot);\n          var /** @type {?} */ injector = config ? config.injector : this.injector;\n          return injector.get(token);\n      };\n      return PreActivation;\n  }());\n  var ActivateRoutes = (function () {\n      /**\n       * @param {?} routeReuseStrategy\n       * @param {?} futureState\n       * @param {?} currState\n       */\n      function ActivateRoutes(routeReuseStrategy, futureState, currState) {\n          this.routeReuseStrategy = routeReuseStrategy;\n          this.futureState = futureState;\n          this.currState = currState;\n      }\n      /**\n       * @param {?} parentOutletMap\n       * @return {?}\n       */\n      ActivateRoutes.prototype.activate = function (parentOutletMap) {\n          var /** @type {?} */ futureRoot = this.futureState._root;\n          var /** @type {?} */ currRoot = this.currState ? this.currState._root : null;\n          this.deactivateChildRoutes(futureRoot, currRoot, parentOutletMap);\n          advanceActivatedRoute(this.futureState.root);\n          this.activateChildRoutes(futureRoot, currRoot, parentOutletMap);\n      };\n      /**\n       * @param {?} futureNode\n       * @param {?} currNode\n       * @param {?} outletMap\n       * @return {?}\n       */\n      ActivateRoutes.prototype.deactivateChildRoutes = function (futureNode, currNode, outletMap) {\n          var _this = this;\n          var /** @type {?} */ prevChildren = nodeChildrenAsMap(currNode);\n          futureNode.children.forEach(function (c) {\n              _this.deactivateRoutes(c, prevChildren[c.value.outlet], outletMap);\n              delete prevChildren[c.value.outlet];\n          });\n          forEach(prevChildren, function (v, k) { return _this.deactiveRouteAndItsChildren(v, outletMap); });\n      };\n      /**\n       * @param {?} futureNode\n       * @param {?} currNode\n       * @param {?} outletMap\n       * @return {?}\n       */\n      ActivateRoutes.prototype.activateChildRoutes = function (futureNode, currNode, outletMap) {\n          var _this = this;\n          var /** @type {?} */ prevChildren = nodeChildrenAsMap(currNode);\n          futureNode.children.forEach(function (c) { _this.activateRoutes(c, prevChildren[c.value.outlet], outletMap); });\n      };\n      /**\n       * @param {?} futureNode\n       * @param {?} currNode\n       * @param {?} parentOutletMap\n       * @return {?}\n       */\n      ActivateRoutes.prototype.deactivateRoutes = function (futureNode, currNode, parentOutletMap) {\n          var /** @type {?} */ future = futureNode.value;\n          var /** @type {?} */ curr = currNode ? currNode.value : null;\n          // reusing the node\n          if (future === curr) {\n              // If we have a normal route, we need to go through an outlet.\n              if (future.component) {\n                  var /** @type {?} */ outlet = getOutlet(parentOutletMap, future);\n                  this.deactivateChildRoutes(futureNode, currNode, outlet.outletMap);\n              }\n              else {\n                  this.deactivateChildRoutes(futureNode, currNode, parentOutletMap);\n              }\n          }\n          else {\n              if (curr) {\n                  this.deactiveRouteAndItsChildren(currNode, parentOutletMap);\n              }\n          }\n      };\n      /**\n       * @param {?} futureNode\n       * @param {?} currNode\n       * @param {?} parentOutletMap\n       * @return {?}\n       */\n      ActivateRoutes.prototype.activateRoutes = function (futureNode, currNode, parentOutletMap) {\n          var /** @type {?} */ future = futureNode.value;\n          var /** @type {?} */ curr = currNode ? currNode.value : null;\n          // reusing the node\n          if (future === curr) {\n              // advance the route to push the parameters\n              advanceActivatedRoute(future);\n              // If we have a normal route, we need to go through an outlet.\n              if (future.component) {\n                  var /** @type {?} */ outlet = getOutlet(parentOutletMap, future);\n                  this.activateChildRoutes(futureNode, currNode, outlet.outletMap);\n              }\n              else {\n                  this.activateChildRoutes(futureNode, currNode, parentOutletMap);\n              }\n          }\n          else {\n              // if we have a normal route, we need to advance the route\n              // and place the component into the outlet. After that recurse.\n              if (future.component) {\n                  advanceActivatedRoute(future);\n                  var /** @type {?} */ outlet = getOutlet(parentOutletMap, futureNode.value);\n                  if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n                      var /** @type {?} */ stored = ((this.routeReuseStrategy.retrieve(future.snapshot)));\n                      this.routeReuseStrategy.store(future.snapshot, null);\n                      outlet.attach(stored.componentRef, stored.route.value);\n                      advanceActivatedRouteNodeAndItsChildren(stored.route);\n                  }\n                  else {\n                      var /** @type {?} */ outletMap = new RouterOutletMap();\n                      this.placeComponentIntoOutlet(outletMap, future, outlet);\n                      this.activateChildRoutes(futureNode, null, outletMap);\n                  }\n              }\n              else {\n                  advanceActivatedRoute(future);\n                  this.activateChildRoutes(futureNode, null, parentOutletMap);\n              }\n          }\n      };\n      /**\n       * @param {?} outletMap\n       * @param {?} future\n       * @param {?} outlet\n       * @return {?}\n       */\n      ActivateRoutes.prototype.placeComponentIntoOutlet = function (outletMap, future, outlet) {\n          var /** @type {?} */ resolved = ([{ provide: ActivatedRoute, useValue: future }, {\n                  provide: RouterOutletMap,\n                  useValue: outletMap\n              }]);\n          var /** @type {?} */ config = parentLoadedConfig(future.snapshot);\n          var /** @type {?} */ resolver = null;\n          var /** @type {?} */ injector = null;\n          if (config) {\n              injector = config.injectorFactory(outlet.locationInjector);\n              resolver = config.factoryResolver;\n              resolved.push({ provide: _angular_core.ComponentFactoryResolver, useValue: resolver });\n          }\n          else {\n              injector = outlet.locationInjector;\n              resolver = outlet.locationFactoryResolver;\n          }\n          outlet.activate(future, resolver, injector, _angular_core.ReflectiveInjector.resolve(resolved), outletMap);\n      };\n      /**\n       * @param {?} route\n       * @param {?} parentOutletMap\n       * @return {?}\n       */\n      ActivateRoutes.prototype.deactiveRouteAndItsChildren = function (route, parentOutletMap) {\n          if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n              this.detachAndStoreRouteSubtree(route, parentOutletMap);\n          }\n          else {\n              this.deactiveRouteAndOutlet(route, parentOutletMap);\n          }\n      };\n      /**\n       * @param {?} route\n       * @param {?} parentOutletMap\n       * @return {?}\n       */\n      ActivateRoutes.prototype.detachAndStoreRouteSubtree = function (route, parentOutletMap) {\n          var /** @type {?} */ outlet = getOutlet(parentOutletMap, route.value);\n          var /** @type {?} */ componentRef = outlet.detach();\n          this.routeReuseStrategy.store(route.value.snapshot, { componentRef: componentRef, route: route });\n      };\n      /**\n       * @param {?} route\n       * @param {?} parentOutletMap\n       * @return {?}\n       */\n      ActivateRoutes.prototype.deactiveRouteAndOutlet = function (route, parentOutletMap) {\n          var _this = this;\n          var /** @type {?} */ prevChildren = nodeChildrenAsMap(route);\n          var /** @type {?} */ outlet = null;\n          // getOutlet throws when cannot find the right outlet,\n          // which can happen if an outlet was in an NgIf and was removed\n          try {\n              outlet = getOutlet(parentOutletMap, route.value);\n          }\n          catch (e) {\n              return;\n          }\n          var /** @type {?} */ childOutletMap = outlet.outletMap;\n          forEach(prevChildren, function (v, k) {\n              if (route.value.component) {\n                  _this.deactiveRouteAndItsChildren(v, childOutletMap);\n              }\n              else {\n                  _this.deactiveRouteAndItsChildren(v, parentOutletMap);\n              }\n          });\n          if (outlet && outlet.isActivated) {\n              outlet.deactivate();\n          }\n      };\n      return ActivateRoutes;\n  }());\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  function advanceActivatedRouteNodeAndItsChildren(node) {\n      advanceActivatedRoute(node.value);\n      node.children.forEach(advanceActivatedRouteNodeAndItsChildren);\n  }\n  /**\n   * @param {?} snapshot\n   * @return {?}\n   */\n  function parentLoadedConfig(snapshot) {\n      var /** @type {?} */ s = snapshot.parent;\n      while (s) {\n          var /** @type {?} */ c = s._routeConfig;\n          if (c && c._loadedConfig)\n              return c._loadedConfig;\n          if (c && c.component)\n              return null;\n          s = s.parent;\n      }\n      return null;\n  }\n  /**\n   * @param {?} snapshot\n   * @return {?}\n   */\n  function closestLoadedConfig(snapshot) {\n      if (!snapshot)\n          return null;\n      var /** @type {?} */ s = snapshot.parent;\n      while (s) {\n          var /** @type {?} */ c = s._routeConfig;\n          if (c && c._loadedConfig)\n              return c._loadedConfig;\n          s = s.parent;\n      }\n      return null;\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  function nodeChildrenAsMap(node) {\n      return node ? node.children.reduce(function (m, c) {\n          m[c.value.outlet] = c;\n          return m;\n      }, {}) : {};\n  }\n  /**\n   * @param {?} outletMap\n   * @param {?} route\n   * @return {?}\n   */\n  function getOutlet(outletMap, route) {\n      var /** @type {?} */ outlet = outletMap._outlets[route.outlet];\n      if (!outlet) {\n          var /** @type {?} */ componentName = ((route.component)).name;\n          if (route.outlet === PRIMARY_OUTLET) {\n              throw new Error(\"Cannot find primary outlet to load '\" + componentName + \"'\");\n          }\n          else {\n              throw new Error(\"Cannot find the outlet \" + route.outlet + \" to load '\" + componentName + \"'\");\n          }\n      }\n      return outlet;\n  }\n\n  /**\n   *  *\n    * *\n    * Consider the following route configuration:\n    * `[{ path: 'user/:name', component: UserCmp }]`\n    * *\n    * When linking to this `user/:name` route, you can write:\n    * `<a routerLink='/user/bob'>link to user component</a>`\n    * *\n    * *\n    * The RouterLink directives let you link to specific parts of your app.\n    * *\n    * When the link is static, you can use the directive as follows:\n    * `<a routerLink=\"/user/bob\">link to user component</a>`\n    * *\n    * If you use dynamic values to generate the link, you can pass an array of path\n    * segments, followed by the params for each segment.\n    * *\n    * For instance `['/team', teamId, 'user', userName, {details: true}]`\n    * means that we want to generate a link to `/team/11/user/bob;details=true`.\n    * *\n    * Multiple static segments can be merged into one\n    * (e.g., `['/team/11/user', userName, {details: true}]`).\n    * *\n    * The first segment name can be prepended with `/`, `./`, or `../`:\n    * * If the first segment begins with `/`, the router will look up the route from the root of the\n    * app.\n    * * If the first segment begins with `./`, or doesn't begin with a slash, the router will\n    * instead look in the children of the current activated route.\n    * * And if the first segment begins with `../`, the router will go up one level.\n    * *\n    * You can set query params and fragment as follows:\n    * *\n    * ```\n    * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\n    * link to user component\n    * </a>\n    * ```\n    * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.\n    * *\n    * You can also tell the directive to preserve the current query params and fragment:\n    * *\n    * ```\n    * <a [routerLink]=\"['/user/bob']\" preserveQueryParams preserveFragment>\n    * link to user component\n    * </a>\n    * ```\n    * *\n    * The router link directive always treats the provided input as a delta to the current url.\n    * *\n    * For instance, if the current url is `/user/(box//aux:team)`.\n    * *\n    * Then the following link `<a [routerLink]=\"['/user/jim']\">Jim</a>` will generate the link\n    * `/user/(jim//aux:team)`.\n    * *\n    * *\n    * See {@link Router.createUrlTree} for more information.\n    * *\n   */\n  var RouterLink = (function () {\n      /**\n       * @param {?} router\n       * @param {?} route\n       */\n      function RouterLink(router, route) {\n          this.router = router;\n          this.route = route;\n          this.commands = [];\n      }\n      Object.defineProperty(RouterLink.prototype, \"routerLink\", {\n          /**\n           * @param {?} data\n           * @return {?}\n           */\n          set: function (data) {\n              if (Array.isArray(data)) {\n                  this.commands = data;\n              }\n              else {\n                  this.commands = [data];\n              }\n          },\n          enumerable: true,\n          configurable: true\n      });\n      /**\n       * @return {?}\n       */\n      RouterLink.prototype.onClick = function () {\n          var /** @type {?} */ extras = {\n              skipLocationChange: attrBoolValue(this.skipLocationChange),\n              replaceUrl: attrBoolValue(this.replaceUrl),\n          };\n          this.router.navigateByUrl(this.urlTree, extras);\n          return true;\n      };\n      Object.defineProperty(RouterLink.prototype, \"urlTree\", {\n          /**\n           * @return {?}\n           */\n          get: function () {\n              return this.router.createUrlTree(this.commands, {\n                  relativeTo: this.route,\n                  queryParams: this.queryParams,\n                  fragment: this.fragment,\n                  preserveQueryParams: attrBoolValue(this.preserveQueryParams),\n                  preserveFragment: attrBoolValue(this.preserveFragment),\n              });\n          },\n          enumerable: true,\n          configurable: true\n      });\n      RouterLink.decorators = [\n          { type: _angular_core.Directive, args: [{ selector: ':not(a)[routerLink]' },] },\n      ];\n      /** @nocollapse */\n      RouterLink.ctorParameters = function () { return [\n          { type: Router, },\n          { type: ActivatedRoute, },\n      ]; };\n      RouterLink.propDecorators = {\n          'queryParams': [{ type: _angular_core.Input },],\n          'fragment': [{ type: _angular_core.Input },],\n          'preserveQueryParams': [{ type: _angular_core.Input },],\n          'preserveFragment': [{ type: _angular_core.Input },],\n          'skipLocationChange': [{ type: _angular_core.Input },],\n          'replaceUrl': [{ type: _angular_core.Input },],\n          'routerLink': [{ type: _angular_core.Input },],\n          'onClick': [{ type: _angular_core.HostListener, args: ['click', [],] },],\n      };\n      return RouterLink;\n  }());\n  /**\n   *  *\n    * See {@link RouterLink} for more information.\n    * *\n    * *\n   */\n  var RouterLinkWithHref = (function () {\n      /**\n       * @param {?} router\n       * @param {?} route\n       * @param {?} locationStrategy\n       */\n      function RouterLinkWithHref(router, route, locationStrategy) {\n          var _this = this;\n          this.router = router;\n          this.route = route;\n          this.locationStrategy = locationStrategy;\n          this.commands = [];\n          this.subscription = router.events.subscribe(function (s) {\n              if (s instanceof NavigationEnd) {\n                  _this.updateTargetUrlAndHref();\n              }\n          });\n      }\n      Object.defineProperty(RouterLinkWithHref.prototype, \"routerLink\", {\n          /**\n           * @param {?} data\n           * @return {?}\n           */\n          set: function (data) {\n              if (Array.isArray(data)) {\n                  this.commands = data;\n              }\n              else {\n                  this.commands = [data];\n              }\n          },\n          enumerable: true,\n          configurable: true\n      });\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n      RouterLinkWithHref.prototype.ngOnChanges = function (changes) { this.updateTargetUrlAndHref(); };\n      /**\n       * @return {?}\n       */\n      RouterLinkWithHref.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\n      /**\n       * @param {?} button\n       * @param {?} ctrlKey\n       * @param {?} metaKey\n       * @return {?}\n       */\n      RouterLinkWithHref.prototype.onClick = function (button, ctrlKey, metaKey) {\n          if (button !== 0 || ctrlKey || metaKey) {\n              return true;\n          }\n          if (typeof this.target === 'string' && this.target != '_self') {\n              return true;\n          }\n          var /** @type {?} */ extras = {\n              skipLocationChange: attrBoolValue(this.skipLocationChange),\n              replaceUrl: attrBoolValue(this.replaceUrl),\n          };\n          this.router.navigateByUrl(this.urlTree, extras);\n          return false;\n      };\n      /**\n       * @return {?}\n       */\n      RouterLinkWithHref.prototype.updateTargetUrlAndHref = function () {\n          this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));\n      };\n      Object.defineProperty(RouterLinkWithHref.prototype, \"urlTree\", {\n          /**\n           * @return {?}\n           */\n          get: function () {\n              return this.router.createUrlTree(this.commands, {\n                  relativeTo: this.route,\n                  queryParams: this.queryParams,\n                  fragment: this.fragment,\n                  preserveQueryParams: attrBoolValue(this.preserveQueryParams),\n                  preserveFragment: attrBoolValue(this.preserveFragment),\n              });\n          },\n          enumerable: true,\n          configurable: true\n      });\n      RouterLinkWithHref.decorators = [\n          { type: _angular_core.Directive, args: [{ selector: 'a[routerLink]' },] },\n      ];\n      /** @nocollapse */\n      RouterLinkWithHref.ctorParameters = function () { return [\n          { type: Router, },\n          { type: ActivatedRoute, },\n          { type: _angular_common.LocationStrategy, },\n      ]; };\n      RouterLinkWithHref.propDecorators = {\n          'target': [{ type: _angular_core.Input },],\n          'queryParams': [{ type: _angular_core.Input },],\n          'fragment': [{ type: _angular_core.Input },],\n          'preserveQueryParams': [{ type: _angular_core.Input },],\n          'preserveFragment': [{ type: _angular_core.Input },],\n          'skipLocationChange': [{ type: _angular_core.Input },],\n          'replaceUrl': [{ type: _angular_core.Input },],\n          'href': [{ type: _angular_core.HostBinding },],\n          'routerLink': [{ type: _angular_core.Input },],\n          'onClick': [{ type: _angular_core.HostListener, args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey'],] },],\n      };\n      return RouterLinkWithHref;\n  }());\n  /**\n   * @param {?} s\n   * @return {?}\n   */\n  function attrBoolValue(s) {\n      return s === '' || !!s;\n  }\n\n  /**\n   *  *\n    * *\n    * ```\n    * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n    * ```\n    * *\n    * *\n    * The RouterLinkActive directive lets you add a CSS class to an element when the link's route\n    * becomes active.\n    * *\n    * Consider the following example:\n    * *\n    * ```\n    * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n    * ```\n    * *\n    * When the url is either '/user' or '/user/bob', the active-link class will\n    * be added to the `a` tag. If the url changes, the class will be removed.\n    * *\n    * You can set more than one class, as follows:\n    * *\n    * ```\n    * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n    * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n    * ```\n    * *\n    * You can configure RouterLinkActive by passing `exact: true`. This will add the classes\n    * only when the url matches the link exactly.\n    * *\n    * ```\n    * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n    * true}\">Bob</a>\n    * ```\n    * *\n    * You can assign the RouterLinkActive instance to a template variable and directly check\n    * the `isActive` status.\n    * ```\n    * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n    * Bob {{ rla.isActive ? '(already open)' : ''}}\n    * </a>\n    * ```\n    * *\n    * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.\n    * *\n    * ```\n    * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n    * <a routerLink=\"/user/jim\">Jim</a>\n    * <a routerLink=\"/user/bob\">Bob</a>\n    * </div>\n    * ```\n    * *\n    * This will set the active-link class on the div tag if the url is either '/user/jim' or\n    * '/user/bob'.\n    * *\n    * *\n   */\n  var RouterLinkActive = (function () {\n      /**\n       * @param {?} router\n       * @param {?} element\n       * @param {?} renderer\n       */\n      function RouterLinkActive(router, element, renderer) {\n          var _this = this;\n          this.router = router;\n          this.element = element;\n          this.renderer = renderer;\n          this.classes = [];\n          this.routerLinkActiveOptions = { exact: false };\n          this.subscription = router.events.subscribe(function (s) {\n              if (s instanceof NavigationEnd) {\n                  _this.update();\n              }\n          });\n      }\n      Object.defineProperty(RouterLinkActive.prototype, \"isActive\", {\n          /**\n           * @return {?}\n           */\n          get: function () { return this.hasActiveLink(); },\n          enumerable: true,\n          configurable: true\n      });\n      /**\n       * @return {?}\n       */\n      RouterLinkActive.prototype.ngAfterContentInit = function () {\n          var _this = this;\n          this.links.changes.subscribe(function (s) { return _this.update(); });\n          this.linksWithHrefs.changes.subscribe(function (s) { return _this.update(); });\n          this.update();\n      };\n      Object.defineProperty(RouterLinkActive.prototype, \"routerLinkActive\", {\n          /**\n           * @param {?} data\n           * @return {?}\n           */\n          set: function (data) {\n              if (Array.isArray(data)) {\n                  this.classes = (data);\n              }\n              else {\n                  this.classes = data.split(' ');\n              }\n          },\n          enumerable: true,\n          configurable: true\n      });\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n      RouterLinkActive.prototype.ngOnChanges = function (changes) { this.update(); };\n      /**\n       * @return {?}\n       */\n      RouterLinkActive.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\n      /**\n       * @return {?}\n       */\n      RouterLinkActive.prototype.update = function () {\n          var _this = this;\n          if (!this.links || !this.linksWithHrefs || !this.router.navigated)\n              return;\n          var /** @type {?} */ isActive = this.hasActiveLink();\n          this.classes.forEach(function (c) {\n              if (c) {\n                  _this.renderer.setElementClass(_this.element.nativeElement, c, isActive);\n              }\n          });\n      };\n      /**\n       * @param {?} router\n       * @return {?}\n       */\n      RouterLinkActive.prototype.isLinkActive = function (router) {\n          var _this = this;\n          return function (link) {\n              return router.isActive(link.urlTree, _this.routerLinkActiveOptions.exact);\n          };\n      };\n      /**\n       * @return {?}\n       */\n      RouterLinkActive.prototype.hasActiveLink = function () {\n          return this.links.some(this.isLinkActive(this.router)) ||\n              this.linksWithHrefs.some(this.isLinkActive(this.router));\n      };\n      RouterLinkActive.decorators = [\n          { type: _angular_core.Directive, args: [{\n                      selector: '[routerLinkActive]',\n                      exportAs: 'routerLinkActive',\n                  },] },\n      ];\n      /** @nocollapse */\n      RouterLinkActive.ctorParameters = function () { return [\n          { type: Router, },\n          { type: _angular_core.ElementRef, },\n          { type: _angular_core.Renderer, },\n      ]; };\n      RouterLinkActive.propDecorators = {\n          'links': [{ type: _angular_core.ContentChildren, args: [RouterLink, { descendants: true },] },],\n          'linksWithHrefs': [{ type: _angular_core.ContentChildren, args: [RouterLinkWithHref, { descendants: true },] },],\n          'routerLinkActiveOptions': [{ type: _angular_core.Input },],\n          'routerLinkActive': [{ type: _angular_core.Input },],\n      };\n      return RouterLinkActive;\n  }());\n\n  /**\n   *  state.\n    * *\n    * *\n    * ```\n    * <router-outlet></router-outlet>\n    * <router-outlet name='left'></router-outlet>\n    * <router-outlet name='right'></router-outlet>\n    * ```\n    * *\n    * A router outlet will emit an activate event any time a new component is being instantiated,\n    * and a deactivate event when it is being destroyed.\n    * *\n    * ```\n    * <router-outlet\n    * (activate)='onActivate($event)'\n    * (deactivate)='onDeactivate($event)'></router-outlet>\n    * ```\n    * *\n   */\n  var RouterOutlet = (function () {\n      /**\n       * @param {?} parentOutletMap\n       * @param {?} location\n       * @param {?} resolver\n       * @param {?} name\n       */\n      function RouterOutlet(parentOutletMap, location, resolver, name) {\n          this.parentOutletMap = parentOutletMap;\n          this.location = location;\n          this.resolver = resolver;\n          this.name = name;\n          this.activateEvents = new _angular_core.EventEmitter();\n          this.deactivateEvents = new _angular_core.EventEmitter();\n          parentOutletMap.registerOutlet(name ? name : PRIMARY_OUTLET, this);\n      }\n      /**\n       * @return {?}\n       */\n      RouterOutlet.prototype.ngOnDestroy = function () { this.parentOutletMap.removeOutlet(this.name ? this.name : PRIMARY_OUTLET); };\n      Object.defineProperty(RouterOutlet.prototype, \"locationInjector\", {\n          /**\n           * @return {?}\n           */\n          get: function () { return this.location.injector; },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(RouterOutlet.prototype, \"locationFactoryResolver\", {\n          /**\n           * @return {?}\n           */\n          get: function () { return this.resolver; },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(RouterOutlet.prototype, \"isActivated\", {\n          /**\n           * @return {?}\n           */\n          get: function () { return !!this.activated; },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(RouterOutlet.prototype, \"component\", {\n          /**\n           * @return {?}\n           */\n          get: function () {\n              if (!this.activated)\n                  throw new Error('Outlet is not activated');\n              return this.activated.instance;\n          },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(RouterOutlet.prototype, \"activatedRoute\", {\n          /**\n           * @return {?}\n           */\n          get: function () {\n              if (!this.activated)\n                  throw new Error('Outlet is not activated');\n              return this._activatedRoute;\n          },\n          enumerable: true,\n          configurable: true\n      });\n      /**\n       * @return {?}\n       */\n      RouterOutlet.prototype.detach = function () {\n          if (!this.activated)\n              throw new Error('Outlet is not activated');\n          this.location.detach();\n          var /** @type {?} */ r = this.activated;\n          this.activated = null;\n          this._activatedRoute = null;\n          return r;\n      };\n      /**\n       * @param {?} ref\n       * @param {?} activatedRoute\n       * @return {?}\n       */\n      RouterOutlet.prototype.attach = function (ref, activatedRoute) {\n          this.activated = ref;\n          this._activatedRoute = activatedRoute;\n          this.location.insert(ref.hostView);\n      };\n      /**\n       * @return {?}\n       */\n      RouterOutlet.prototype.deactivate = function () {\n          if (this.activated) {\n              var /** @type {?} */ c = this.component;\n              this.activated.destroy();\n              this.activated = null;\n              this._activatedRoute = null;\n              this.deactivateEvents.emit(c);\n          }\n      };\n      /**\n       * @param {?} activatedRoute\n       * @param {?} resolver\n       * @param {?} injector\n       * @param {?} providers\n       * @param {?} outletMap\n       * @return {?}\n       */\n      RouterOutlet.prototype.activate = function (activatedRoute, resolver, injector, providers, outletMap) {\n          if (this.isActivated) {\n              throw new Error('Cannot activate an already activated outlet');\n          }\n          this.outletMap = outletMap;\n          this._activatedRoute = activatedRoute;\n          var /** @type {?} */ snapshot = activatedRoute._futureSnapshot;\n          var /** @type {?} */ component = (snapshot._routeConfig.component);\n          var /** @type {?} */ factory = resolver.resolveComponentFactory(component);\n          var /** @type {?} */ inj = _angular_core.ReflectiveInjector.fromResolvedProviders(providers, injector);\n          this.activated = this.location.createComponent(factory, this.location.length, inj, []);\n          this.activated.changeDetectorRef.detectChanges();\n          this.activateEvents.emit(this.activated.instance);\n      };\n      RouterOutlet.decorators = [\n          { type: _angular_core.Directive, args: [{ selector: 'router-outlet' },] },\n      ];\n      /** @nocollapse */\n      RouterOutlet.ctorParameters = function () { return [\n          { type: RouterOutletMap, },\n          { type: _angular_core.ViewContainerRef, },\n          { type: _angular_core.ComponentFactoryResolver, },\n          { type: undefined, decorators: [{ type: _angular_core.Attribute, args: ['name',] },] },\n      ]; };\n      RouterOutlet.propDecorators = {\n          'activateEvents': [{ type: _angular_core.Output, args: ['activate',] },],\n          'deactivateEvents': [{ type: _angular_core.Output, args: ['deactivate',] },],\n      };\n      return RouterOutlet;\n  }());\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  /**\n   *  *\n   * @abstract\n   */\n  var RouteReuseStrategy = (function () {\n      function RouteReuseStrategy() {\n      }\n      /**\n       *  Determines if this route (and its subtree) should be detached to be reused later\n       * @abstract\n       * @param {?} route\n       * @return {?}\n       */\n      RouteReuseStrategy.prototype.shouldDetach = function (route) { };\n      /**\n       *  Stores the detached route\n       * @abstract\n       * @param {?} route\n       * @param {?} handle\n       * @return {?}\n       */\n      RouteReuseStrategy.prototype.store = function (route, handle) { };\n      /**\n       *  Determines if this route (and its subtree) should be reattached\n       * @abstract\n       * @param {?} route\n       * @return {?}\n       */\n      RouteReuseStrategy.prototype.shouldAttach = function (route) { };\n      /**\n       *  Retrieves the previously stored route\n       * @abstract\n       * @param {?} route\n       * @return {?}\n       */\n      RouteReuseStrategy.prototype.retrieve = function (route) { };\n      /**\n       *  Determines if a route should be reused\n       * @abstract\n       * @param {?} future\n       * @param {?} curr\n       * @return {?}\n       */\n      RouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) { };\n      return RouteReuseStrategy;\n  }());\n\n  var /** @type {?} */ getDOM = _angular_platformBrowser.__platform_browser_private__.getDOM;\n\n  /**\n   *  *\n   * @abstract\n   */\n  var PreloadingStrategy = (function () {\n      function PreloadingStrategy() {\n      }\n      /**\n       * @abstract\n       * @param {?} route\n       * @param {?} fn\n       * @return {?}\n       */\n      PreloadingStrategy.prototype.preload = function (route, fn) { };\n      return PreloadingStrategy;\n  }());\n  /**\n   *  *\n    * *\n    * ```\n    * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n    * ```\n    * *\n   */\n  var PreloadAllModules = (function () {\n      function PreloadAllModules() {\n      }\n      /**\n       * @param {?} route\n       * @param {?} fn\n       * @return {?}\n       */\n      PreloadAllModules.prototype.preload = function (route, fn) {\n          return rxjs_operator_catch._catch.call(fn(), function () { return rxjs_observable_of.of(null); });\n      };\n      return PreloadAllModules;\n  }());\n  /**\n   *  *\n    * *\n    * This strategy is enabled by default.\n    * *\n   */\n  var NoPreloading = (function () {\n      function NoPreloading() {\n      }\n      /**\n       * @param {?} route\n       * @param {?} fn\n       * @return {?}\n       */\n      NoPreloading.prototype.preload = function (route, fn) { return rxjs_observable_of.of(null); };\n      return NoPreloading;\n  }());\n  /**\n   *  The preloader optimistically loads all router configurations to\n    * make navigations into lazily-loaded sections of the application faster.\n    * *\n    * The preloader runs in the background. When the router bootstraps, the preloader\n    * starts listening to all navigation events. After every such event, the preloader\n    * will check if any configurations can be loaded lazily.\n    * *\n    * If a route is protected by `canLoad` guards, the preloaded will not load it.\n    * *\n   */\n  var RouterPreloader = (function () {\n      /**\n       * @param {?} router\n       * @param {?} moduleLoader\n       * @param {?} compiler\n       * @param {?} injector\n       * @param {?} preloadingStrategy\n       */\n      function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {\n          this.router = router;\n          this.injector = injector;\n          this.preloadingStrategy = preloadingStrategy;\n          this.loader = new RouterConfigLoader(moduleLoader, compiler);\n      }\n      ;\n      /**\n       * @return {?}\n       */\n      RouterPreloader.prototype.setUpPreloading = function () {\n          var _this = this;\n          var /** @type {?} */ navigations = rxjs_operator_filter.filter.call(this.router.events, function (e) { return e instanceof NavigationEnd; });\n          this.subscription = rxjs_operator_concatMap.concatMap.call(navigations, function () { return _this.preload(); }).subscribe(function (v) { });\n      };\n      /**\n       * @return {?}\n       */\n      RouterPreloader.prototype.preload = function () { return this.processRoutes(this.injector, this.router.config); };\n      /**\n       * @return {?}\n       */\n      RouterPreloader.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\n      /**\n       * @param {?} injector\n       * @param {?} routes\n       * @return {?}\n       */\n      RouterPreloader.prototype.processRoutes = function (injector, routes) {\n          var /** @type {?} */ res = [];\n          for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n              var c = routes_1[_i];\n              // we already have the config loaded, just recurce\n              if (c.loadChildren && !c.canLoad && ((c))._loadedConfig) {\n                  var /** @type {?} */ childConfig = ((c))._loadedConfig;\n                  res.push(this.processRoutes(childConfig.injector, childConfig.routes));\n              }\n              else if (c.loadChildren && !c.canLoad) {\n                  res.push(this.preloadConfig(injector, c));\n              }\n              else if (c.children) {\n                  res.push(this.processRoutes(injector, c.children));\n              }\n          }\n          return rxjs_operator_mergeAll.mergeAll.call(rxjs_observable_from.from(res));\n      };\n      /**\n       * @param {?} injector\n       * @param {?} route\n       * @return {?}\n       */\n      RouterPreloader.prototype.preloadConfig = function (injector, route) {\n          var _this = this;\n          return this.preloadingStrategy.preload(route, function () {\n              var /** @type {?} */ loaded = _this.loader.load(injector, route.loadChildren);\n              return rxjs_operator_mergeMap.mergeMap.call(loaded, function (config) {\n                  var /** @type {?} */ c = route;\n                  c._loadedConfig = config;\n                  return _this.processRoutes(config.injector, config.routes);\n              });\n          });\n      };\n      RouterPreloader.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      RouterPreloader.ctorParameters = function () { return [\n          { type: Router, },\n          { type: _angular_core.NgModuleFactoryLoader, },\n          { type: _angular_core.Compiler, },\n          { type: _angular_core.Injector, },\n          { type: PreloadingStrategy, },\n      ]; };\n      return RouterPreloader;\n  }());\n\n  /**\n   * @whatItDoes Contains a list of directives\n   * @stable\n   */\n  var /** @type {?} */ ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive];\n  /**\n   * @whatItDoes Is used in DI to configure the router.\n   * @stable\n   */\n  var /** @type {?} */ ROUTER_CONFIGURATION = new _angular_core.OpaqueToken('ROUTER_CONFIGURATION');\n  /**\n   * @docsNotRequired\n   */\n  var /** @type {?} */ ROUTER_FORROOT_GUARD = new _angular_core.OpaqueToken('ROUTER_FORROOT_GUARD');\n  var /** @type {?} */ ROUTER_PROVIDERS = [\n      _angular_common.Location,\n      { provide: UrlSerializer, useClass: DefaultUrlSerializer },\n      {\n          provide: Router,\n          useFactory: setupRouter,\n          deps: [\n              _angular_core.ApplicationRef, UrlSerializer, RouterOutletMap, _angular_common.Location, _angular_core.Injector, _angular_core.NgModuleFactoryLoader,\n              _angular_core.Compiler, ROUTES, ROUTER_CONFIGURATION, [UrlHandlingStrategy, new _angular_core.Optional()],\n              [RouteReuseStrategy, new _angular_core.Optional()]\n          ]\n      },\n      RouterOutletMap,\n      { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },\n      { provide: _angular_core.NgModuleFactoryLoader, useClass: _angular_core.SystemJsNgModuleLoader },\n      RouterPreloader,\n      NoPreloading,\n      PreloadAllModules,\n      { provide: ROUTER_CONFIGURATION, useValue: { enableTracing: false } },\n  ];\n  /**\n   * @return {?}\n   */\n  function routerNgProbeToken() {\n      return new _angular_core.NgProbeToken('Router', Router);\n  }\n  /**\n   *  *\n    * *\n    * RouterModule can be imported multiple times: once per lazily-loaded bundle.\n    * Since the router deals with a global shared resource--location, we cannot have\n    * more than one router service active.\n    * *\n    * That is why there are two ways to create the module: `RouterModule.forRoot` and\n    * `RouterModule.forChild`.\n    * *\n    * * `forRoot` creates a module that contains all the directives, the given routes, and the router\n    * service itself.\n    * * `forChild` creates a module that contains all the directives and the given routes, but does not\n    * include the router service.\n    * *\n    * When registered at the root, the module should be used as follows\n    * *\n    * ```\n    * imports: [RouterModule.forRoot(ROUTES)]\n    * })\n    * class MyNgModule {}\n    * ```\n    * *\n    * For submodules and lazy loaded submodules the module should be used as follows:\n    * *\n    * ```\n    * imports: [RouterModule.forChild(ROUTES)]\n    * })\n    * class MyNgModule {}\n    * ```\n    * *\n    * *\n    * Managing state transitions is one of the hardest parts of building applications. This is\n    * especially true on the web, where you also need to ensure that the state is reflected in the URL.\n    * In addition, we often want to split applications into multiple bundles and load them on demand.\n    * Doing this transparently is not trivial.\n    * *\n    * The Angular 2 router solves these problems. Using the router, you can declaratively specify\n    * application states, manage state transitions while taking care of the URL, and load bundles on\n    * demand.\n    * *\n    * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an\n    * overview of how the router should be used.\n    * *\n   */\n  var RouterModule = (function () {\n      /**\n       * @param {?} guard\n       */\n      function RouterModule(guard) {\n      }\n      /**\n       *  Creates a module with all the router providers and directives. It also optionally sets up an\n        * application listener to perform an initial navigation.\n        * *\n        * Options:\n        * * `enableTracing` makes the router log all its internal events to the console.\n        * * `useHash` enables the location strategy that uses the URL fragment instead of the history\n        * API.\n        * * `initialNavigation` disables the initial navigation.\n        * * `errorHandler` provides a custom error handler.\n       * @param {?} routes\n       * @param {?=} config\n       * @return {?}\n       */\n      RouterModule.forRoot = function (routes, config) {\n          return {\n              ngModule: RouterModule,\n              providers: [\n                  ROUTER_PROVIDERS,\n                  provideRoutes(routes),\n                  {\n                      provide: ROUTER_FORROOT_GUARD,\n                      useFactory: provideForRootGuard,\n                      deps: [[Router, new _angular_core.Optional(), new _angular_core.SkipSelf()]]\n                  },\n                  { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} },\n                  {\n                      provide: _angular_common.LocationStrategy,\n                      useFactory: provideLocationStrategy,\n                      deps: [\n                          _angular_common.PlatformLocation, [new _angular_core.Inject(_angular_common.APP_BASE_HREF), new _angular_core.Optional()], ROUTER_CONFIGURATION\n                      ]\n                  },\n                  {\n                      provide: PreloadingStrategy,\n                      useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :\n                          NoPreloading\n                  },\n                  { provide: _angular_core.NgProbeToken, multi: true, useFactory: routerNgProbeToken },\n                  provideRouterInitializer(),\n              ],\n          };\n      };\n      /**\n       *  Creates a module with all the router directives and a provider registering routes.\n       * @param {?} routes\n       * @return {?}\n       */\n      RouterModule.forChild = function (routes) {\n          return { ngModule: RouterModule, providers: [provideRoutes(routes)] };\n      };\n      RouterModule.decorators = [\n          { type: _angular_core.NgModule, args: [{ declarations: ROUTER_DIRECTIVES, exports: ROUTER_DIRECTIVES },] },\n      ];\n      /** @nocollapse */\n      RouterModule.ctorParameters = function () { return [\n          { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [ROUTER_FORROOT_GUARD,] },] },\n      ]; };\n      return RouterModule;\n  }());\n  /**\n   * @param {?} platformLocationStrategy\n   * @param {?} baseHref\n   * @param {?=} options\n   * @return {?}\n   */\n  function provideLocationStrategy(platformLocationStrategy, baseHref, options) {\n      if (options === void 0) { options = {}; }\n      return options.useHash ? new _angular_common.HashLocationStrategy(platformLocationStrategy, baseHref) :\n          new _angular_common.PathLocationStrategy(platformLocationStrategy, baseHref);\n  }\n  /**\n   * @param {?} router\n   * @return {?}\n   */\n  function provideForRootGuard(router) {\n      if (router) {\n          throw new Error(\"RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.\");\n      }\n      return 'guarded';\n  }\n  /**\n   *  *\n    * *\n    * ```\n    * imports: [RouterModule.forChild(ROUTES)],\n    * providers: [provideRoutes(EXTRA_ROUTES)]\n    * })\n    * class MyNgModule {}\n    * ```\n    * *\n   * @param {?} routes\n   * @return {?}\n   */\n  function provideRoutes(routes) {\n      return [\n          { provide: _angular_core.ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes },\n          { provide: ROUTES, multi: true, useValue: routes },\n      ];\n  }\n  /**\n   * @param {?} ref\n   * @param {?} urlSerializer\n   * @param {?} outletMap\n   * @param {?} location\n   * @param {?} injector\n   * @param {?} loader\n   * @param {?} compiler\n   * @param {?} config\n   * @param {?=} opts\n   * @param {?=} urlHandlingStrategy\n   * @param {?=} routeReuseStrategy\n   * @return {?}\n   */\n  function setupRouter(ref, urlSerializer, outletMap, location, injector, loader, compiler, config, opts, urlHandlingStrategy, routeReuseStrategy) {\n      if (opts === void 0) { opts = {}; }\n      var /** @type {?} */ router = new Router(null, urlSerializer, outletMap, location, injector, loader, compiler, flatten(config));\n      if (urlHandlingStrategy) {\n          router.urlHandlingStrategy = urlHandlingStrategy;\n      }\n      if (routeReuseStrategy) {\n          router.routeReuseStrategy = routeReuseStrategy;\n      }\n      if (opts.errorHandler) {\n          router.errorHandler = opts.errorHandler;\n      }\n      if (opts.enableTracing) {\n          var /** @type {?} */ dom_1 = getDOM();\n          router.events.subscribe(function (e) {\n              dom_1.logGroup(\"Router Event: \" + ((e.constructor)).name);\n              dom_1.log(e.toString());\n              dom_1.log(e);\n              dom_1.logGroupEnd();\n          });\n      }\n      return router;\n  }\n  /**\n   * @param {?} router\n   * @return {?}\n   */\n  function rootRoute(router) {\n      return router.routerState.root;\n  }\n  /**\n   * @param {?} router\n   * @param {?} ref\n   * @param {?} preloader\n   * @param {?} opts\n   * @return {?}\n   */\n  function initialRouterNavigation(router, ref, preloader, opts) {\n      return function (bootstrappedComponentRef) {\n          if (bootstrappedComponentRef !== ref.components[0]) {\n              return;\n          }\n          router.resetRootComponentType(ref.componentTypes[0]);\n          preloader.setUpPreloading();\n          if (opts.initialNavigation === false) {\n              router.setUpLocationChangeListener();\n          }\n          else {\n              router.initialNavigation();\n          }\n      };\n  }\n  /**\n   * A token for the router initializer that will be called after the app is bootstrapped.\n   *\n   * @experimental\n   */\n  var /** @type {?} */ ROUTER_INITIALIZER = new _angular_core.OpaqueToken('Router Initializer');\n  /**\n   * @return {?}\n   */\n  function provideRouterInitializer() {\n      return [\n          {\n              provide: ROUTER_INITIALIZER,\n              useFactory: initialRouterNavigation,\n              deps: [Router, _angular_core.ApplicationRef, RouterPreloader, ROUTER_CONFIGURATION]\n          },\n          { provide: _angular_core.APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER },\n      ];\n  }\n\n  /**\n   * @stable\n   */\n  var /** @type {?} */ VERSION = new _angular_core.Version('3.4.1');\n\n  var /** @type {?} */ __router_private__ = {\n      ROUTER_PROVIDERS: ROUTER_PROVIDERS,\n      ROUTES: ROUTES,\n      flatten: flatten,\n  };\n\n  exports.RouterLink = RouterLink;\n  exports.RouterLinkWithHref = RouterLinkWithHref;\n  exports.RouterLinkActive = RouterLinkActive;\n  exports.RouterOutlet = RouterOutlet;\n  exports.RouteReuseStrategy = RouteReuseStrategy;\n  exports.NavigationCancel = NavigationCancel;\n  exports.NavigationEnd = NavigationEnd;\n  exports.NavigationError = NavigationError;\n  exports.NavigationStart = NavigationStart;\n  exports.Router = Router;\n  exports.RoutesRecognized = RoutesRecognized;\n  exports.ROUTER_CONFIGURATION = ROUTER_CONFIGURATION;\n  exports.ROUTER_INITIALIZER = ROUTER_INITIALIZER;\n  exports.RouterModule = RouterModule;\n  exports.provideRoutes = provideRoutes;\n  exports.RouterOutletMap = RouterOutletMap;\n  exports.NoPreloading = NoPreloading;\n  exports.PreloadAllModules = PreloadAllModules;\n  exports.PreloadingStrategy = PreloadingStrategy;\n  exports.RouterPreloader = RouterPreloader;\n  exports.ActivatedRoute = ActivatedRoute;\n  exports.ActivatedRouteSnapshot = ActivatedRouteSnapshot;\n  exports.RouterState = RouterState;\n  exports.RouterStateSnapshot = RouterStateSnapshot;\n  exports.PRIMARY_OUTLET = PRIMARY_OUTLET;\n  exports.UrlHandlingStrategy = UrlHandlingStrategy;\n  exports.DefaultUrlSerializer = DefaultUrlSerializer;\n  exports.UrlSegment = UrlSegment;\n  exports.UrlSegmentGroup = UrlSegmentGroup;\n  exports.UrlSerializer = UrlSerializer;\n  exports.UrlTree = UrlTree;\n  exports.VERSION = VERSION;\n  exports.__router_private__ = __router_private__;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@angular/router/bundles/router.umd.js\n// module id = 83\n// module chunks = 2","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar core_1 = require('@angular/core');\r\nvar AppComponent = (function () {\r\n    function AppComponent() {\r\n    }\r\n    AppComponent = __decorate([\r\n        core_1.Component({\r\n            selector: 'my-app',\r\n            styles: [\"\\n        .menu {\\n            display: flex;\\n            width: 50%;\\n            justify-content: space-between;\\n            margin: 20px auto;\\n        }\\n\\n        a {\\n          text-decoration: none;\\n          font-size: 16px;\\n          padding: 10px;\\n          transition: all .2s ease-out;\\n        }\\n\\n        a.active, a:hover {\\n          background-color: #3498db;\\n          color: #fff !important;\\n        }\\n    \"],\r\n            template: \"\\n        <div class=\\\"menu\\\">\\n            <a routerLink=\\\"/fade-in-image\\\" routerLinkActive=\\\"active\\\">Fade in image</a>\\n            <a routerLink=\\\"/default-image\\\" routerLinkActive=\\\"active\\\">Default image</a>\\n            <a routerLink=\\\"/pixelated-image\\\" routerLinkActive=\\\"active\\\">Pixelated transform</a>\\n            <a routerLink=\\\"/bg-image\\\" routerLinkActive=\\\"active\\\">Background image</a>\\n            <a routerLink=\\\"/scroll-container\\\" routerLinkActive=\\\"active\\\">Scroll Container</a>\\n        </div>\\n\\n        <router-outlet></router-outlet>\\n    \",\r\n            changeDetection: core_1.ChangeDetectionStrategy.OnPush\r\n        }), \r\n        __metadata('design:paramtypes', [])\r\n    ], AppComponent);\r\n    return AppComponent;\r\n}());\r\nexports.AppComponent = AppComponent;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./example/app.component.ts\n// module id = 84\n// module chunks = 2","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar core_1 = require('@angular/core');\r\nvar platform_browser_1 = require('@angular/platform-browser');\r\nvar router_1 = require('@angular/router');\r\nvar lazyload_image_module_1 = require('../src/lazyload-image.module');\r\nvar app_component_1 = require('./app.component');\r\nvar fade_in_image_component_1 = require('./fade-in-image.component');\r\nvar bg_image_component_1 = require('./bg-image.component');\r\nvar default_image_component_1 = require('./default-image.component');\r\nvar pixelated_image_component_1 = require('./pixelated-image.component');\r\nvar scroll_container_component_1 = require('./scroll-container.component');\r\nvar AppModule = (function () {\r\n    function AppModule() {\r\n    }\r\n    AppModule = __decorate([\r\n        core_1.NgModule({\r\n            declarations: [\r\n                app_component_1.AppComponent,\r\n                fade_in_image_component_1.FadeInImageComponent,\r\n                bg_image_component_1.BgImageComponent,\r\n                default_image_component_1.DefaultImageComponent,\r\n                pixelated_image_component_1.PixelatedImageComponent,\r\n                scroll_container_component_1.ScrollContainerComponent\r\n            ],\r\n            imports: [\r\n                platform_browser_1.BrowserModule,\r\n                router_1.RouterModule.forRoot([\r\n                    {\r\n                        path: '',\r\n                        redirectTo: '/fade-in-image',\r\n                        pathMatch: 'full'\r\n                    },\r\n                    { path: 'fade-in-image', component: fade_in_image_component_1.FadeInImageComponent },\r\n                    { path: 'bg-image', component: bg_image_component_1.BgImageComponent },\r\n                    { path: 'default-image', component: default_image_component_1.DefaultImageComponent },\r\n                    { path: 'pixelated-image', component: pixelated_image_component_1.PixelatedImageComponent },\r\n                    { path: 'scroll-container', component: scroll_container_component_1.ScrollContainerComponent },\r\n                ]),\r\n                lazyload_image_module_1.LazyLoadImageModule\r\n            ],\r\n            bootstrap: [app_component_1.AppComponent]\r\n        }), \r\n        __metadata('design:paramtypes', [])\r\n    ], AppModule);\r\n    return AppModule;\r\n}());\r\nexports.AppModule = AppModule;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./example/app.module.ts\n// module id = 85\n// module chunks = 2","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar core_1 = require('@angular/core');\r\nvar BgImageComponent = (function () {\r\n    function BgImageComponent() {\r\n        this.errorImage = 'https://i.imgur.com/XkU4Ajf.png';\r\n        this.images = [\r\n            'https://hd.unsplash.com/photo-1470165525439-3cf9e6dccbad',\r\n            'https://hd.unsplash.com/photo-1471109880861-75a04f9b7833',\r\n            'https://hd.unsplash.com/photo-1431400445088-1750c997c6b5'\r\n        ];\r\n    }\r\n    BgImageComponent = __decorate([\r\n        core_1.Component({\r\n            selector: 'bg-image',\r\n            styles: [\"\\n        div {\\n            min-width: 1497px;\\n            width: 100%;\\n            min-height: 1127px;\\n            background-position: center;\\n            background-size: cover;\\n            transition: opacity 1s;\\n            opacity: 0;\\n        }\\n        .ng2-lazyloaded {\\n            opacity: 1;\\n        }\\n    \"],\r\n            template: \"\\n      <div\\n        *ngFor=\\\"let image of images\\\"\\n        src=\\\"https://www.placecage.com/1000/1000\\\"\\n        [lazyLoad]=\\\"image\\\"\\n        [errorImage]=\\\"errorImage\\\">\\n      </div>\\n    \",\r\n            changeDetection: core_1.ChangeDetectionStrategy.OnPush\r\n        }), \r\n        __metadata('design:paramtypes', [])\r\n    ], BgImageComponent);\r\n    return BgImageComponent;\r\n}());\r\nexports.BgImageComponent = BgImageComponent;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./example/bg-image.component.ts\n// module id = 86\n// module chunks = 2","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar core_1 = require('@angular/core');\r\nvar DefaultImageComponent = (function () {\r\n    function DefaultImageComponent() {\r\n        this.errorImage = 'https://i.imgur.com/XkU4Ajf.png';\r\n        this.defaultImage = 'https://www.placecage.com/1000/1000';\r\n        this.images = [\r\n            'https://images.unsplash.com/photo-1467932760935-519284fc87fa?dpr=2&auto=compress,format&fit=crop&w=1199&h=800&q=80',\r\n            'https://images.unsplash.com/photo-1468103933896-2c34a78104c2?dpr=2&auto=compress,format&fit=crop&w=1199&h=799&q=80',\r\n            'https://images.unsplash.com/photo-1471201187657-6406da15e43b?dpr=2&auto=compress,format&fit=crop&w=1199&h=1199&q=80'\r\n        ];\r\n    }\r\n    DefaultImageComponent = __decorate([\r\n        core_1.Component({\r\n            selector: 'default-image',\r\n            styles: [\"\\n        img {\\n            min-width: 1497px;\\n            width: 100%;\\n            min-height: 1127px;\\n        }\\n\\n        img.ng2-lazyloaded {\\n            animation: fadein .5s;\\n        }\\n\\n        @keyframes fadein {\\n            from { opacity: 0; }\\n            to   { opacity: 1; }\\n        }\\n    \"],\r\n            template: \"\\n        <img\\n            *ngFor=\\\"let image of images\\\"\\n            [src]=\\\"defaultImage\\\"\\n            [errorImage]=\\\"errorImage\\\"\\n            [lazyLoad]=\\\"image\\\">\\n    \",\r\n            changeDetection: core_1.ChangeDetectionStrategy.OnPush\r\n        }), \r\n        __metadata('design:paramtypes', [])\r\n    ], DefaultImageComponent);\r\n    return DefaultImageComponent;\r\n}());\r\nexports.DefaultImageComponent = DefaultImageComponent;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./example/default-image.component.ts\n// module id = 87\n// module chunks = 2","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar core_1 = require('@angular/core');\r\nvar FadeInImageComponent = (function () {\r\n    function FadeInImageComponent() {\r\n        this.errorImage = 'https://i.imgur.com/XkU4Ajf.png';\r\n        this.images = [\r\n            'https://hd.unsplash.com/photo-1441765425173-8fd330fb4a02',\r\n            'https://hd.unsplash.com/photo-1451481454041-104482d8e284',\r\n            'https://hd.unsplash.com/photo-1471070855862-324d571a1857',\r\n            'https://hd.unsplash.com/photo-1415045550139-59b6fafc832f'\r\n        ];\r\n    }\r\n    FadeInImageComponent = __decorate([\r\n        core_1.Component({\r\n            selector: 'fade-in-image',\r\n            styles: [\"\\n        img {\\n            min-width: 1497px;\\n            width: 100%;\\n            min-height: 1127px;\\n            transition: opacity 1s;\\n            opacity: 0;\\n        }\\n\\n        img.ng2-lazyloaded {\\n            opacity: 1;\\n        }\\n    \"],\r\n            template: \"\\n        <img\\n          *ngFor=\\\"let image of images\\\"\\n          src=\\\"https://www.placecage.com/1000/1000\\\"\\n          [errorImage]=\\\"errorImage\\\"\\n          [lazyLoad]=\\\"image\\\">\\n    \",\r\n            changeDetection: core_1.ChangeDetectionStrategy.OnPush\r\n        }), \r\n        __metadata('design:paramtypes', [])\r\n    ], FadeInImageComponent);\r\n    return FadeInImageComponent;\r\n}());\r\nexports.FadeInImageComponent = FadeInImageComponent;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./example/fade-in-image.component.ts\n// module id = 88\n// module chunks = 2","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar core_1 = require('@angular/core');\r\nvar PixelatedImageComponent = (function () {\r\n    function PixelatedImageComponent() {\r\n    }\r\n    PixelatedImageComponent = __decorate([\r\n        core_1.Component({\r\n            selector: 'pixelated-image',\r\n            styles: [\"\\n        .wrapper {\\n            position: relative;\\n            width: 100%;\\n            height: 1000px;\\n            min-width: 960px;\\n        }\\n        img {\\n            position: absolute;\\n            left: 0;\\n            top: 0;\\n            width: 100%;\\n            height: 100%;\\n        }\\n        .fanart {\\n            position: absolute;\\n            left: 0;\\n            top: 0;\\n            width: 100%;\\n            height: 100%;\\n            background-repeat: no-repeat;\\n            background-position: 0 0;\\n            background-size: cover;\\n            transition: opacity 1s;\\n            opacity: 0;\\n        }\\n        .ng2-lazyloaded {\\n            opacity: 1;\\n        }\\n    \"],\r\n            template: \"\\n        <div class=\\\"wrapper\\\">\\n            <img src=\\\"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAUFBQUFBQYGBgYICQgJCAwLCgoLDBINDg0ODRIbERQRERQRGxgdGBYYHRgrIh4eIisyKigqMjw2NjxMSExkZIYBCgoKCgoKCwwMCw8RDxEPFxUTExUXIhkaGRoZIjQhJiEhJiE0LjguKy44LlNBOjpBU2BRTFFgdGhodJOLk8DA///AABEIAAUABQMBEQACEQEDEQH/xABcAAEAAAAAAAAAAAAAAAAAAAAHEAEAAgEFAAAAAAAAAAAAAAACAQMRAAQFB0EBAQEAAAAAAAAAAAAAAAAAAAMEEQAABQUAAAAAAAAAAAAAAAAAAQIDQRITISKR/9oADAMBAAIRAxEAPwAZjt2+oGm3hNumMwmLmIUx7ic6mtPQ/iNSC1plsuj/2Q==\\\">\\n            <div class=\\\"fanart\\\" lazyLoad=\\\"https://images.unsplash.com/photo-1450101215322-bf5cd27642fc?ixlib=rb-0.3.5&q=80&fm=jpg\\\"></div>\\n        </div>\\n    \",\r\n            changeDetection: core_1.ChangeDetectionStrategy.OnPush\r\n        }), \r\n        __metadata('design:paramtypes', [])\r\n    ], PixelatedImageComponent);\r\n    return PixelatedImageComponent;\r\n}());\r\nexports.PixelatedImageComponent = PixelatedImageComponent;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./example/pixelated-image.component.ts\n// module id = 89\n// module chunks = 2","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar core_1 = require('@angular/core');\r\nvar ScrollContainerComponent = (function () {\r\n    function ScrollContainerComponent(elmRef) {\r\n        this.elmRef = elmRef;\r\n        this.images = [\r\n            'https://images.unsplash.com/photo-1467932760935-519284fc87fa?dpr=2&auto=compress,format&fit=crop&w=1199&h=800&q=80',\r\n            'https://images.unsplash.com/photo-1468103933896-2c34a78104c2?dpr=2&auto=compress,format&fit=crop&w=1199&h=799&q=80',\r\n            'https://images.unsplash.com/photo-1471201187657-6406da15e43b?dpr=2&auto=compress,format&fit=crop&w=1199&h=1199&q=80'\r\n        ];\r\n        this.errorImage = 'https://i.imgur.com/XkU4Ajf.png';\r\n    }\r\n    ScrollContainerComponent.prototype.ngOnInit = function () {\r\n        this.myScrollCOntainer = this.elmRef.nativeElement.querySelector('#my-scroll-container');\r\n    };\r\n    ScrollContainerComponent = __decorate([\r\n        core_1.Component({\r\n            selector: 'scroll-container',\r\n            styles: [\"\\n        img {\\n            min-width: 1497px;\\n            width: 100%;\\n            min-height: 1127px;\\n        }\\n\\n        img.ng2-lazyloaded {\\n            animation: fadein .5s;\\n        }\\n\\n        .scroll-container {\\n            height: 500px;\\n            overflow: scroll;\\n            border: 2px solid red;\\n            margin-bottom: 100px;\\n        }\\n\\n        @keyframes fadein {\\n            from { opacity: 0; }\\n            to   { opacity: 1; }\\n        }\\n    \"],\r\n            template: \"\\n    <div class=\\\"scroll-container\\\" id=\\\"my-scroll-container\\\">\\n        <img\\n            *ngFor=\\\"let image of images\\\"\\n            src=\\\"https://www.placecage.com/1000/1000\\\"\\n            [errorImage]=\\\"errorImage\\\"\\n            [scrollTarget]=\\\"myScrollCOntainer\\\"\\n            [lazyLoad]=\\\"image\\\">\\n    </div>\\n\\n    <div class=\\\"scroll-container\\\" #scrollableDiv>\\n        <img\\n            *ngFor=\\\"let image of images\\\"\\n            src=\\\"https://www.placecage.com/1000/1000\\\"\\n            [errorImage]=\\\"errorImage\\\"\\n            [scrollTarget]=\\\"scrollableDiv\\\"\\n            [lazyLoad]=\\\"image\\\">\\n    </div>\\n    \",\r\n            changeDetection: core_1.ChangeDetectionStrategy.OnPush\r\n        }), \r\n        __metadata('design:paramtypes', [core_1.ElementRef])\r\n    ], ScrollContainerComponent);\r\n    return ScrollContainerComponent;\r\n}());\r\nexports.ScrollContainerComponent = ScrollContainerComponent;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./example/scroll-container.component.ts\n// module id = 90\n// module chunks = 2","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nrequire('rxjs/add/operator/let');\r\nvar core_1 = require('@angular/core');\r\nvar scroll_listener_1 = require('./scroll-listener');\r\nvar lazyload_image_1 = require('./lazyload-image');\r\nvar LazyLoadImageDirective = (function () {\r\n    function LazyLoadImageDirective(el, ngZone) {\r\n        this.scrollTarget = window;\r\n        this.elementRef = el;\r\n        this.ngZone = ngZone;\r\n    }\r\n    LazyLoadImageDirective.prototype.ngAfterContentInit = function () {\r\n        var _this = this;\r\n        this.ngZone.runOutsideAngular(function () {\r\n            if (_this.scrollObservable) {\r\n                _this.scrollSubscription = _this.scrollObservable\r\n                    .startWith('')\r\n                    .let(lazyload_image_1.lazyLoadImage(_this.elementRef.nativeElement, _this.lazyImage, _this.errorImage, _this.offset))\r\n                    .subscribe(function () { });\r\n            }\r\n            else {\r\n                _this.scrollSubscription = scroll_listener_1.getScrollListener(_this.scrollTarget)\r\n                    .let(lazyload_image_1.lazyLoadImage(_this.elementRef.nativeElement, _this.lazyImage, _this.errorImage, _this.offset))\r\n                    .subscribe(function () { });\r\n            }\r\n        });\r\n    };\r\n    LazyLoadImageDirective.prototype.ngOnDestroy = function () {\r\n        [this.scrollSubscription]\r\n            .filter(function (subscription) { return subscription && !subscription.isUnsubscribed; })\r\n            .forEach(function (subscription) { return subscription.unsubscribe(); });\r\n    };\r\n    __decorate([\r\n        core_1.Input('lazyLoad'), \r\n        __metadata('design:type', Object)\r\n    ], LazyLoadImageDirective.prototype, \"lazyImage\", void 0);\r\n    __decorate([\r\n        core_1.Input(), \r\n        __metadata('design:type', String)\r\n    ], LazyLoadImageDirective.prototype, \"errorImage\", void 0);\r\n    __decorate([\r\n        core_1.Input(), \r\n        __metadata('design:type', Object)\r\n    ], LazyLoadImageDirective.prototype, \"scrollTarget\", void 0);\r\n    __decorate([\r\n        core_1.Input(), \r\n        __metadata('design:type', Object)\r\n    ], LazyLoadImageDirective.prototype, \"scrollObservable\", void 0);\r\n    __decorate([\r\n        core_1.Input(), \r\n        __metadata('design:type', Number)\r\n    ], LazyLoadImageDirective.prototype, \"offset\", void 0);\r\n    LazyLoadImageDirective = __decorate([\r\n        core_1.Directive({\r\n            selector: '[lazyLoad]'\r\n        }), \r\n        __metadata('design:paramtypes', [core_1.ElementRef, core_1.NgZone])\r\n    ], LazyLoadImageDirective);\r\n    return LazyLoadImageDirective;\r\n}());\r\nexports.LazyLoadImageDirective = LazyLoadImageDirective;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/lazyload-image.directive.ts\n// module id = 91\n// module chunks = 2","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar core_1 = require('@angular/core');\r\nvar lazyload_image_directive_1 = require('./lazyload-image.directive');\r\nvar LazyLoadImageModule = (function () {\r\n    function LazyLoadImageModule() {\r\n    }\r\n    LazyLoadImageModule = __decorate([\r\n        core_1.NgModule({\r\n            declarations: [lazyload_image_directive_1.LazyLoadImageDirective],\r\n            exports: [lazyload_image_directive_1.LazyLoadImageDirective]\r\n        }), \r\n        __metadata('design:paramtypes', [])\r\n    ], LazyLoadImageModule);\r\n    return LazyLoadImageModule;\r\n}());\r\nexports.LazyLoadImageModule = LazyLoadImageModule;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/lazyload-image.module.ts\n// module id = 92\n// module chunks = 2","\"use strict\";\r\nrequire('rxjs/add/operator/filter');\r\nrequire('rxjs/add/operator/do');\r\nrequire('rxjs/add/operator/take');\r\nrequire('rxjs/add/operator/mergeMap');\r\nrequire('rxjs/add/operator/catch');\r\nrequire('rxjs/add/observable/of');\r\nvar Observable_1 = require('rxjs/Observable');\r\nfunction isVisible(element, threshold, _window) {\r\n    if (threshold === void 0) { threshold = 0; }\r\n    if (_window === void 0) { _window = window; }\r\n    var rect = element.getBoundingClientRect();\r\n    var elementLargerThenViewport = rect.top <= threshold && rect.bottom >= -threshold;\r\n    var topInsideViewport = rect.top >= 0 && rect.top <= _window.innerHeight;\r\n    var belowInsideViewport = rect.bottom >= 0 && rect.bottom <= _window.innerHeight;\r\n    var rightsideInViewport = rect.right >= -threshold && (rect.right - threshold) <= _window.innerWidth;\r\n    var leftsideInViewport = rect.left >= -threshold && (rect.left - threshold) <= _window.innerWidth;\r\n    return (elementLargerThenViewport ||\r\n        ((topInsideViewport || belowInsideViewport) &&\r\n            (rightsideInViewport || leftsideInViewport)));\r\n}\r\nfunction loadImage(imagePath) {\r\n    return Observable_1.Observable\r\n        .create(function (observer) {\r\n        var img = new Image();\r\n        img.src = imagePath;\r\n        img.onload = function () {\r\n            observer.next(imagePath);\r\n            observer.complete();\r\n        };\r\n        img.onerror = function (err) {\r\n            observer.error(null);\r\n        };\r\n    });\r\n}\r\nfunction setImage(element, imagePath) {\r\n    var isImgNode = element.nodeName.toLowerCase() === 'img';\r\n    if (isImgNode) {\r\n        element.src = imagePath;\r\n    }\r\n    else {\r\n        element.style.backgroundImage = \"url('\" + imagePath + \"')\";\r\n    }\r\n    return element;\r\n}\r\nfunction setLoadedStyle(element) {\r\n    var styles = element.className\r\n        .split(' ')\r\n        .filter(function (s) { return !!s; })\r\n        .filter(function (s) { return s !== 'ng2-lazyloading'; });\r\n    styles.push('ng2-lazyloaded');\r\n    element.className = styles.join(' ');\r\n    return element;\r\n}\r\nfunction lazyLoadImage(image, imagePath, errorImgPath, offset) {\r\n    return function (scrollObservable) {\r\n        return scrollObservable\r\n            .filter(function () { return isVisible(image, offset); })\r\n            .take(1)\r\n            .mergeMap(function () { return loadImage(imagePath); })\r\n            .do(function () { return setImage(image, imagePath); })\r\n            .catch(function () {\r\n            if (errorImgPath) {\r\n                setImage(image, errorImgPath);\r\n            }\r\n            return Observable_1.Observable.of(1);\r\n        })\r\n            .do(function () { return setLoadedStyle(image); });\r\n    };\r\n}\r\nexports.lazyLoadImage = lazyLoadImage;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/lazyload-image.ts\n// module id = 93\n// module chunks = 2","\"use strict\";\r\nrequire('rxjs/add/operator/startWith');\r\nrequire('rxjs/add/operator/sampleTime');\r\nrequire('rxjs/add/operator/share');\r\nrequire('rxjs/add/observable/empty');\r\nvar Observable_1 = require('rxjs/Observable');\r\nvar scrollListeners = new WeakMap();\r\nfunction sampleObservable(obs, scheduler) {\r\n    return obs\r\n        .sampleTime(100, scheduler)\r\n        .share()\r\n        .startWith('');\r\n}\r\nexports.sampleObservable = sampleObservable;\r\nexports.getScrollListener = function (scrollTarget) {\r\n    if (!scrollTarget || typeof scrollTarget.addEventListener !== 'function') {\r\n        console.warn('`addEventListener` on ' + scrollTarget + ' (scrollTarget) is not a function. Skipping this target');\r\n        return Observable_1.Observable.empty();\r\n    }\r\n    if (scrollListeners.has(scrollTarget)) {\r\n        return scrollListeners.get(scrollTarget);\r\n    }\r\n    var srollEvent = Observable_1.Observable.create(function (observer) {\r\n        var eventName = 'scroll';\r\n        var handler = function (event) { return observer.next(event); };\r\n        var options = { passive: true, capture: false };\r\n        scrollTarget.addEventListener(eventName, handler, options);\r\n        return function () { return scrollTarget.removeEventListener(eventName, handler, options); };\r\n    });\r\n    var listener = sampleObservable(srollEvent);\r\n    scrollListeners.set(scrollTarget, listener);\r\n    return listener;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scroll-listener.ts\n// module id = 94\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('./Subject');\nvar ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');\n/**\n * @class BehaviorSubject<T>\n */\nvar BehaviorSubject = (function (_super) {\n    __extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        _super.call(this);\n        this._value = _value;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        if (subscription && !subscription.closed) {\n            subscriber.next(this._value);\n        }\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        if (this.hasError) {\n            throw this.thrownError;\n        }\n        else if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else {\n            return this._value;\n        }\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, this._value = value);\n    };\n    return BehaviorSubject;\n}(Subject_1.Subject));\nexports.BehaviorSubject = BehaviorSubject;\n//# sourceMappingURL=BehaviorSubject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/BehaviorSubject.js\n// module id = 95\n// module chunks = 2","\"use strict\";\nvar Observable_1 = require('./Observable');\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nvar Notification = (function () {\n    function Notification(kind, value, error) {\n        this.kind = kind;\n        this.value = value;\n        this.error = error;\n        this.hasValue = kind === 'N';\n    }\n    /**\n     * Delivers to the given `observer` the value wrapped by this Notification.\n     * @param {Observer} observer\n     * @return\n     */\n    Notification.prototype.observe = function (observer) {\n        switch (this.kind) {\n            case 'N':\n                return observer.next && observer.next(this.value);\n            case 'E':\n                return observer.error && observer.error(this.error);\n            case 'C':\n                return observer.complete && observer.complete();\n        }\n    };\n    /**\n     * Given some {@link Observer} callbacks, deliver the value represented by the\n     * current Notification to the correctly corresponding callback.\n     * @param {function(value: T): void} next An Observer `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.do = function (next, error, complete) {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return next && next(this.value);\n            case 'E':\n                return error && error(this.error);\n            case 'C':\n                return complete && complete();\n        }\n    };\n    /**\n     * Takes an Observer or its individual callback functions, and calls `observe`\n     * or `do` methods accordingly.\n     * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n     * the `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.accept = function (nextOrObserver, error, complete) {\n        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n            return this.observe(nextOrObserver);\n        }\n        else {\n            return this.do(nextOrObserver, error, complete);\n        }\n    };\n    /**\n     * Returns a simple Observable that just delivers the notification represented\n     * by this Notification instance.\n     * @return {any}\n     */\n    Notification.prototype.toObservable = function () {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return Observable_1.Observable.of(this.value);\n            case 'E':\n                return Observable_1.Observable.throw(this.error);\n            case 'C':\n                return Observable_1.Observable.empty();\n        }\n        throw new Error('unexpected notification kind value');\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `next` from a\n     * given value.\n     * @param {T} value The `next` value.\n     * @return {Notification<T>} The \"next\" Notification representing the\n     * argument.\n     */\n    Notification.createNext = function (value) {\n        if (typeof value !== 'undefined') {\n            return new Notification('N', value);\n        }\n        return this.undefinedValueNotification;\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `error` from a\n     * given error.\n     * @param {any} [err] The `error` error.\n     * @return {Notification<T>} The \"error\" Notification representing the\n     * argument.\n     */\n    Notification.createError = function (err) {\n        return new Notification('E', undefined, err);\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `complete`.\n     * @return {Notification<any>} The valueless \"complete\" Notification.\n     */\n    Notification.createComplete = function () {\n        return this.completeNotification;\n    };\n    Notification.completeNotification = new Notification('C');\n    Notification.undefinedValueNotification = new Notification('N', undefined);\n    return Notification;\n}());\nexports.Notification = Notification;\n//# sourceMappingURL=Notification.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Notification.js\n// module id = 97\n// module chunks = 2","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar empty_1 = require('../../observable/empty');\nObservable_1.Observable.empty = empty_1.empty;\n//# sourceMappingURL=empty.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/empty.js\n// module id = 100\n// module chunks = 2","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar catch_1 = require('../../operator/catch');\nObservable_1.Observable.prototype.catch = catch_1._catch;\nObservable_1.Observable.prototype._catch = catch_1._catch;\n//# sourceMappingURL=catch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/catch.js\n// module id = 103\n// module chunks = 2","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar do_1 = require('../../operator/do');\nObservable_1.Observable.prototype.do = do_1._do;\nObservable_1.Observable.prototype._do = do_1._do;\n//# sourceMappingURL=do.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/do.js\n// module id = 104\n// module chunks = 2","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar let_1 = require('../../operator/let');\nObservable_1.Observable.prototype.let = let_1.letProto;\nObservable_1.Observable.prototype.letBind = let_1.letProto;\n//# sourceMappingURL=let.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/let.js\n// module id = 106\n// module chunks = 2","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar mergeMap_1 = require('../../operator/mergeMap');\nObservable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\nObservable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n//# sourceMappingURL=mergeMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/mergeMap.js\n// module id = 108\n// module chunks = 2","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar share_1 = require('../../operator/share');\nObservable_1.Observable.prototype.share = share_1.share;\n//# sourceMappingURL=share.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/share.js\n// module id = 109\n// module chunks = 2","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar startWith_1 = require('../../operator/startWith');\nObservable_1.Observable.prototype.startWith = startWith_1.startWith;\n//# sourceMappingURL=startWith.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/startWith.js\n// module id = 110\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar ScalarObservable_1 = require('./ScalarObservable');\nvar EmptyObservable_1 = require('./EmptyObservable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayLikeObservable = (function (_super) {\n    __extends(ArrayLikeObservable, _super);\n    function ArrayLikeObservable(arrayLike, scheduler) {\n        _super.call(this);\n        this.arrayLike = arrayLike;\n        this.scheduler = scheduler;\n        if (!scheduler && arrayLike.length === 1) {\n            this._isScalar = true;\n            this.value = arrayLike[0];\n        }\n    }\n    ArrayLikeObservable.create = function (arrayLike, scheduler) {\n        var length = arrayLike.length;\n        if (length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else if (length === 1) {\n            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);\n        }\n        else {\n            return new ArrayLikeObservable(arrayLike, scheduler);\n        }\n    };\n    ArrayLikeObservable.dispatch = function (state) {\n        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;\n        if (subscriber.closed) {\n            return;\n        }\n        if (index >= length) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(arrayLike[index]);\n        state.index = index + 1;\n        this.schedule(state);\n    };\n    ArrayLikeObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;\n        var length = arrayLike.length;\n        if (scheduler) {\n            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber\n            });\n        }\n        else {\n            for (var i = 0; i < length && !subscriber.closed; i++) {\n                subscriber.next(arrayLike[i]);\n            }\n            subscriber.complete();\n        }\n    };\n    return ArrayLikeObservable;\n}(Observable_1.Observable));\nexports.ArrayLikeObservable = ArrayLikeObservable;\n//# sourceMappingURL=ArrayLikeObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/ArrayLikeObservable.js\n// module id = 112\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar Observable_1 = require('../Observable');\nvar Subscriber_1 = require('../Subscriber');\nvar Subscription_1 = require('../Subscription');\n/**\n * @class ConnectableObservable<T>\n */\nvar ConnectableObservable = (function (_super) {\n    __extends(ConnectableObservable, _super);\n    function ConnectableObservable(source, subjectFactory) {\n        _super.call(this);\n        this.source = source;\n        this.subjectFactory = subjectFactory;\n        this._refCount = 0;\n    }\n    ConnectableObservable.prototype._subscribe = function (subscriber) {\n        return this.getSubject().subscribe(subscriber);\n    };\n    ConnectableObservable.prototype.getSubject = function () {\n        var subject = this._subject;\n        if (!subject || subject.isStopped) {\n            this._subject = this.subjectFactory();\n        }\n        return this._subject;\n    };\n    ConnectableObservable.prototype.connect = function () {\n        var connection = this._connection;\n        if (!connection) {\n            connection = this._connection = new Subscription_1.Subscription();\n            connection.add(this.source\n                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n            if (connection.closed) {\n                this._connection = null;\n                connection = Subscription_1.Subscription.EMPTY;\n            }\n            else {\n                this._connection = connection;\n            }\n        }\n        return connection;\n    };\n    ConnectableObservable.prototype.refCount = function () {\n        return this.lift(new RefCountOperator(this));\n    };\n    return ConnectableObservable;\n}(Observable_1.Observable));\nexports.ConnectableObservable = ConnectableObservable;\nexports.connectableObservableDescriptor = {\n    operator: { value: null },\n    _refCount: { value: 0, writable: true },\n    _subscribe: { value: ConnectableObservable.prototype._subscribe },\n    getSubject: { value: ConnectableObservable.prototype.getSubject },\n    connect: { value: ConnectableObservable.prototype.connect },\n    refCount: { value: ConnectableObservable.prototype.refCount }\n};\nvar ConnectableSubscriber = (function (_super) {\n    __extends(ConnectableSubscriber, _super);\n    function ConnectableSubscriber(destination, connectable) {\n        _super.call(this, destination);\n        this.connectable = connectable;\n    }\n    ConnectableSubscriber.prototype._error = function (err) {\n        this._unsubscribe();\n        _super.prototype._error.call(this, err);\n    };\n    ConnectableSubscriber.prototype._complete = function () {\n        this._unsubscribe();\n        _super.prototype._complete.call(this);\n    };\n    ConnectableSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (connectable) {\n            this.connectable = null;\n            var connection = connectable._connection;\n            connectable._refCount = 0;\n            connectable._subject = null;\n            connectable._connection = null;\n            if (connection) {\n                connection.unsubscribe();\n            }\n        }\n    };\n    return ConnectableSubscriber;\n}(Subject_1.SubjectSubscriber));\nvar RefCountOperator = (function () {\n    function RefCountOperator(connectable) {\n        this.connectable = connectable;\n    }\n    RefCountOperator.prototype.call = function (subscriber, source) {\n        var connectable = this.connectable;\n        connectable._refCount++;\n        var refCounter = new RefCountSubscriber(subscriber, connectable);\n        var subscription = source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            refCounter.connection = connectable.connect();\n        }\n        return subscription;\n    };\n    return RefCountOperator;\n}());\nvar RefCountSubscriber = (function (_super) {\n    __extends(RefCountSubscriber, _super);\n    function RefCountSubscriber(destination, connectable) {\n        _super.call(this, destination);\n        this.connectable = connectable;\n    }\n    RefCountSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (!connectable) {\n            this.connection = null;\n            return;\n        }\n        this.connectable = null;\n        var refCount = connectable._refCount;\n        if (refCount <= 0) {\n            this.connection = null;\n            return;\n        }\n        connectable._refCount = refCount - 1;\n        if (refCount > 1) {\n            this.connection = null;\n            return;\n        }\n        ///\n        // Compare the local RefCountSubscriber's connection Subscription to the\n        // connection Subscription on the shared ConnectableObservable. In cases\n        // where the ConnectableObservable source synchronously emits values, and\n        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n        // execution continues to here before the RefCountOperator has a chance to\n        // supply the RefCountSubscriber with the shared connection Subscription.\n        // For example:\n        // ```\n        // Observable.range(0, 10)\n        //   .publish()\n        //   .refCount()\n        //   .take(5)\n        //   .subscribe();\n        // ```\n        // In order to account for this case, RefCountSubscriber should only dispose\n        // the ConnectableObservable's shared connection Subscription if the\n        // connection Subscription exists, *and* either:\n        //   a. RefCountSubscriber doesn't have a reference to the shared connection\n        //      Subscription yet, or,\n        //   b. RefCountSubscriber's connection Subscription reference is identical\n        //      to the shared connection Subscription\n        ///\n        var connection = this.connection;\n        var sharedConnection = connectable._connection;\n        this.connection = null;\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\n            sharedConnection.unsubscribe();\n        }\n    };\n    return RefCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=ConnectableObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/ConnectableObservable.js\n// module id = 113\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isArray_1 = require('../util/isArray');\nvar isPromise_1 = require('../util/isPromise');\nvar PromiseObservable_1 = require('./PromiseObservable');\nvar IteratorObservable_1 = require('./IteratorObservable');\nvar ArrayObservable_1 = require('./ArrayObservable');\nvar ArrayLikeObservable_1 = require('./ArrayLikeObservable');\nvar iterator_1 = require('../symbol/iterator');\nvar Observable_1 = require('../Observable');\nvar observeOn_1 = require('../operator/observeOn');\nvar observable_1 = require('../symbol/observable');\nvar isArrayLike = (function (x) { return x && typeof x.length === 'number'; });\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromObservable = (function (_super) {\n    __extends(FromObservable, _super);\n    function FromObservable(ish, scheduler) {\n        _super.call(this, null);\n        this.ish = ish;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable from an Array, an array-like object, a Promise, an\n     * iterable object, or an Observable-like object.\n     *\n     * <span class=\"informal\">Converts almost anything to an Observable.</span>\n     *\n     * <img src=\"./img/from.png\" width=\"100%\">\n     *\n     * Convert various other objects and data types into Observables. `from`\n     * converts a Promise or an array-like or an\n     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n     * object into an Observable that emits the items in that promise or array or\n     * iterable. A String, in this context, is treated as an array of characters.\n     * Observable-like objects (contains a function named with the ES2015 Symbol\n     * for Observable) can also be converted through this operator.\n     *\n     * @example <caption>Converts an array to an Observable</caption>\n     * var array = [10, 20, 30];\n     * var result = Rx.Observable.from(array);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // 10 20 30\n     *\n     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n     * function* generateDoubles(seed) {\n     *   var i = seed;\n     *   while (true) {\n     *     yield i;\n     *     i = 2 * i; // double it\n     *   }\n     * }\n     *\n     * var iterator = generateDoubles(3);\n     * var result = Rx.Observable.from(iterator).take(10);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // 3 6 12 24 48 96 192 384 768 1536\n     *\n     * @see {@link create}\n     * @see {@link fromEvent}\n     * @see {@link fromEventPattern}\n     * @see {@link fromPromise}\n     *\n     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n     * Observable-like, an Array, an iterable or an array-like object to be\n     * converted.\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n     * emissions of values.\n     * @return {Observable<T>} The Observable whose values are originally from the\n     * input object that was converted.\n     * @static true\n     * @name from\n     * @owner Observable\n     */\n    FromObservable.create = function (ish, scheduler) {\n        if (ish != null) {\n            if (typeof ish[observable_1.$$observable] === 'function') {\n                if (ish instanceof Observable_1.Observable && !scheduler) {\n                    return ish;\n                }\n                return new FromObservable(ish, scheduler);\n            }\n            else if (isArray_1.isArray(ish)) {\n                return new ArrayObservable_1.ArrayObservable(ish, scheduler);\n            }\n            else if (isPromise_1.isPromise(ish)) {\n                return new PromiseObservable_1.PromiseObservable(ish, scheduler);\n            }\n            else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {\n                return new IteratorObservable_1.IteratorObservable(ish, scheduler);\n            }\n            else if (isArrayLike(ish)) {\n                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);\n            }\n        }\n        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n    };\n    FromObservable.prototype._subscribe = function (subscriber) {\n        var ish = this.ish;\n        var scheduler = this.scheduler;\n        if (scheduler == null) {\n            return ish[observable_1.$$observable]().subscribe(subscriber);\n        }\n        else {\n            return ish[observable_1.$$observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));\n        }\n    };\n    return FromObservable;\n}(Observable_1.Observable));\nexports.FromObservable = FromObservable;\n//# sourceMappingURL=FromObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/FromObservable.js\n// module id = 115\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../util/root');\nvar Observable_1 = require('../Observable');\nvar iterator_1 = require('../symbol/iterator');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar IteratorObservable = (function (_super) {\n    __extends(IteratorObservable, _super);\n    function IteratorObservable(iterator, scheduler) {\n        _super.call(this);\n        this.scheduler = scheduler;\n        if (iterator == null) {\n            throw new Error('iterator cannot be null.');\n        }\n        this.iterator = getIterator(iterator);\n    }\n    IteratorObservable.create = function (iterator, scheduler) {\n        return new IteratorObservable(iterator, scheduler);\n    };\n    IteratorObservable.dispatch = function (state) {\n        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;\n        if (hasError) {\n            subscriber.error(state.error);\n            return;\n        }\n        var result = iterator.next();\n        if (result.done) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(result.value);\n        state.index = index + 1;\n        if (subscriber.closed) {\n            if (typeof iterator.return === 'function') {\n                iterator.return();\n            }\n            return;\n        }\n        this.schedule(state);\n    };\n    IteratorObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(IteratorObservable.dispatch, 0, {\n                index: index, iterator: iterator, subscriber: subscriber\n            });\n        }\n        else {\n            do {\n                var result = iterator.next();\n                if (result.done) {\n                    subscriber.complete();\n                    break;\n                }\n                else {\n                    subscriber.next(result.value);\n                }\n                if (subscriber.closed) {\n                    if (typeof iterator.return === 'function') {\n                        iterator.return();\n                    }\n                    break;\n                }\n            } while (true);\n        }\n    };\n    return IteratorObservable;\n}(Observable_1.Observable));\nexports.IteratorObservable = IteratorObservable;\nvar StringIterator = (function () {\n    function StringIterator(str, idx, len) {\n        if (idx === void 0) { idx = 0; }\n        if (len === void 0) { len = str.length; }\n        this.str = str;\n        this.idx = idx;\n        this.len = len;\n    }\n    StringIterator.prototype[iterator_1.$$iterator] = function () { return (this); };\n    StringIterator.prototype.next = function () {\n        return this.idx < this.len ? {\n            done: false,\n            value: this.str.charAt(this.idx++)\n        } : {\n            done: true,\n            value: undefined\n        };\n    };\n    return StringIterator;\n}());\nvar ArrayIterator = (function () {\n    function ArrayIterator(arr, idx, len) {\n        if (idx === void 0) { idx = 0; }\n        if (len === void 0) { len = toLength(arr); }\n        this.arr = arr;\n        this.idx = idx;\n        this.len = len;\n    }\n    ArrayIterator.prototype[iterator_1.$$iterator] = function () { return this; };\n    ArrayIterator.prototype.next = function () {\n        return this.idx < this.len ? {\n            done: false,\n            value: this.arr[this.idx++]\n        } : {\n            done: true,\n            value: undefined\n        };\n    };\n    return ArrayIterator;\n}());\nfunction getIterator(obj) {\n    var i = obj[iterator_1.$$iterator];\n    if (!i && typeof obj === 'string') {\n        return new StringIterator(obj);\n    }\n    if (!i && obj.length !== undefined) {\n        return new ArrayIterator(obj);\n    }\n    if (!i) {\n        throw new TypeError('object is not iterable');\n    }\n    return obj[iterator_1.$$iterator]();\n}\nvar maxSafeInteger = Math.pow(2, 53) - 1;\nfunction toLength(o) {\n    var len = +o.length;\n    if (isNaN(len)) {\n        return 0;\n    }\n    if (len === 0 || !numberIsFinite(len)) {\n        return len;\n    }\n    len = sign(len) * Math.floor(Math.abs(len));\n    if (len <= 0) {\n        return 0;\n    }\n    if (len > maxSafeInteger) {\n        return maxSafeInteger;\n    }\n    return len;\n}\nfunction numberIsFinite(value) {\n    return typeof value === 'number' && root_1.root.isFinite(value);\n}\nfunction sign(value) {\n    var valueAsNumber = +value;\n    if (valueAsNumber === 0) {\n        return valueAsNumber;\n    }\n    if (isNaN(valueAsNumber)) {\n        return valueAsNumber;\n    }\n    return valueAsNumber < 0 ? -1 : 1;\n}\n//# sourceMappingURL=IteratorObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/IteratorObservable.js\n// module id = 116\n// module chunks = 2","\"use strict\";\nvar EmptyObservable_1 = require('./EmptyObservable');\nexports.empty = EmptyObservable_1.EmptyObservable.create;\n//# sourceMappingURL=empty.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/empty.js\n// module id = 117\n// module chunks = 2","\"use strict\";\nvar FromObservable_1 = require('./FromObservable');\nexports.from = FromObservable_1.FromObservable.create;\n//# sourceMappingURL=from.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/from.js\n// module id = 118\n// module chunks = 2","\"use strict\";\nvar PromiseObservable_1 = require('./PromiseObservable');\nexports.fromPromise = PromiseObservable_1.PromiseObservable.create;\n//# sourceMappingURL=fromPromise.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/fromPromise.js\n// module id = 120\n// module chunks = 2","\"use strict\";\nvar isScheduler_1 = require('../util/isScheduler');\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar mergeAll_1 = require('./mergeAll');\n/* tslint:disable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {Observable} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional Scheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return this.lift.call(concatStatic.apply(void 0, [this].concat(observables)));\n}\nexports.concat = concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins multiple Observables together by subscribing to them one at a time and\n * merging their results into the output Observable. Will wait for each\n * Observable to complete before moving on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat(timer1, timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {Observable} input1 An input Observable to concatenate with others.\n * @param {Observable} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional Scheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\nfunction concatStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var scheduler = null;\n    var args = observables;\n    if (isScheduler_1.isScheduler(args[observables.length - 1])) {\n        scheduler = args.pop();\n    }\n    if (scheduler === null && observables.length === 1) {\n        return observables[0];\n    }\n    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));\n}\nexports.concatStatic = concatStatic;\n//# sourceMappingURL=concat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/concat.js\n// module id = 122\n// module chunks = 2","\"use strict\";\nvar mergeAll_1 = require('./mergeAll');\n/* tslint:disable:max-line-length */\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * <img src=\"./img/concatAll.png\" width=\"100%\">\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n * var firstOrder = higherOrder.concatAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link combineAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable emitting values from all the inner\n * Observables concatenated.\n * @method concatAll\n * @owner Observable\n */\nfunction concatAll() {\n    return this.lift(new mergeAll_1.MergeAllOperator(1));\n}\nexports.concatAll = concatAll;\n//# sourceMappingURL=concatAll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/concatAll.js\n// module id = 123\n// module chunks = 2","\"use strict\";\nvar mergeMap_1 = require('./mergeMap');\n/* tslint:disable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * <img src=\"./img/concatMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): Observable} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} an observable of values merged from the projected\n * Observables as they were subscribed to, one at a time. Optionally, these\n * values may have been projected from a passed `projectResult` argument.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking values from each projected inner\n * Observable sequentially.\n * @method concatMap\n * @owner Observable\n */\nfunction concatMap(project, resultSelector) {\n    return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));\n}\nexports.concatMap = concatMap;\n//# sourceMappingURL=concatMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/concatMap.js\n// module id = 124\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:disable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @method do\n * @name do\n * @owner Observable\n */\nfunction _do(nextOrObserver, error, complete) {\n    return this.lift(new DoOperator(nextOrObserver, error, complete));\n}\nexports._do = _do;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=do.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/do.js\n// module id = 125\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n * @param {function} predicate a function for determining if an item meets a specified condition.\n * @param {any} [thisArg] optional object to use for `this` in the callback\n * @return {Observable} an Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\nfunction every(predicate, thisArg) {\n    return this.lift(new EveryOperator(predicate, thisArg, this));\n}\nexports.every = every;\nvar EveryOperator = (function () {\n    function EveryOperator(predicate, thisArg, source) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n    }\n    EveryOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n    };\n    return EveryOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar EverySubscriber = (function (_super) {\n    __extends(EverySubscriber, _super);\n    function EverySubscriber(destination, predicate, thisArg, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n        this.index = 0;\n        this.thisArg = thisArg || this;\n    }\n    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {\n        this.destination.next(everyValueMatch);\n        this.destination.complete();\n    };\n    EverySubscriber.prototype._next = function (value) {\n        var result = false;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (!result) {\n            this.notifyComplete(false);\n        }\n    };\n    EverySubscriber.prototype._complete = function () {\n        this.notifyComplete(true);\n    };\n    return EverySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=every.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/every.js\n// module id = 126\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar EmptyError_1 = require('../util/EmptyError');\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {function(value: T, index: number): R} [resultSelector] A function to\n * produce the value on the output Observable based on the values\n * and the indices of the source Observable. The arguments passed to this\n * function are:\n * - `value`: the value that was emitted on the source.\n * - `index`: the \"index\" of the value from the source.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} an Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nfunction first(predicate, resultSelector, defaultValue) {\n    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));\n}\nexports.first = first;\nvar FirstOperator = (function () {\n    function FirstOperator(predicate, resultSelector, defaultValue, source) {\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n    }\n    FirstOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n    };\n    return FirstOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FirstSubscriber = (function (_super) {\n    __extends(FirstSubscriber, _super);\n    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n        this.index = 0;\n        this.hasCompleted = false;\n        this._emitted = false;\n    }\n    FirstSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this._tryPredicate(value, index);\n        }\n        else {\n            this._emit(value, index);\n        }\n    };\n    FirstSubscriber.prototype._tryPredicate = function (value, index) {\n        var result;\n        try {\n            result = this.predicate(value, index, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this._emit(value, index);\n        }\n    };\n    FirstSubscriber.prototype._emit = function (value, index) {\n        if (this.resultSelector) {\n            this._tryResultSelector(value, index);\n            return;\n        }\n        this._emitFinal(value);\n    };\n    FirstSubscriber.prototype._tryResultSelector = function (value, index) {\n        var result;\n        try {\n            result = this.resultSelector(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this._emitFinal(result);\n    };\n    FirstSubscriber.prototype._emitFinal = function (value) {\n        var destination = this.destination;\n        if (!this._emitted) {\n            this._emitted = true;\n            destination.next(value);\n            destination.complete();\n            this.hasCompleted = true;\n        }\n    };\n    FirstSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {\n            destination.next(this.defaultValue);\n            destination.complete();\n        }\n        else if (!this.hasCompleted) {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return FirstSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=first.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/first.js\n// module id = 128\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar EmptyError_1 = require('../util/EmptyError');\n/* tslint:disable:max-line-length */\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * <img src=\"./img/last.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {function} predicate - the condition any source emitted item has to satisfy.\n * @return {Observable} an Observable that emits only the last item satisfying the given condition\n * from the source, or an NoSuchElementException if no such items are emitted.\n * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n * @method last\n * @owner Observable\n */\nfunction last(predicate, resultSelector, defaultValue) {\n    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));\n}\nexports.last = last;\nvar LastOperator = (function () {\n    function LastOperator(predicate, resultSelector, defaultValue, source) {\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n    }\n    LastOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n    };\n    return LastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar LastSubscriber = (function (_super) {\n    __extends(LastSubscriber, _super);\n    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n        this.hasValue = false;\n        this.index = 0;\n        if (typeof defaultValue !== 'undefined') {\n            this.lastValue = defaultValue;\n            this.hasValue = true;\n        }\n    }\n    LastSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this._tryPredicate(value, index);\n        }\n        else {\n            if (this.resultSelector) {\n                this._tryResultSelector(value, index);\n                return;\n            }\n            this.lastValue = value;\n            this.hasValue = true;\n        }\n    };\n    LastSubscriber.prototype._tryPredicate = function (value, index) {\n        var result;\n        try {\n            result = this.predicate(value, index, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            if (this.resultSelector) {\n                this._tryResultSelector(value, index);\n                return;\n            }\n            this.lastValue = value;\n            this.hasValue = true;\n        }\n    };\n    LastSubscriber.prototype._tryResultSelector = function (value, index) {\n        var result;\n        try {\n            result = this.resultSelector(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.lastValue = result;\n        this.hasValue = true;\n    };\n    LastSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.hasValue) {\n            destination.next(this.lastValue);\n            destination.complete();\n        }\n        else {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return LastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=last.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/last.js\n// module id = 129\n// module chunks = 2","\"use strict\";\n/**\n * @param func\n * @return {Observable<R>}\n * @method let\n * @owner Observable\n */\nfunction letProto(func) {\n    return func(this);\n}\nexports.letProto = letProto;\n//# sourceMappingURL=let.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/let.js\n// module id = 130\n// module chunks = 2","\"use strict\";\nvar ConnectableObservable_1 = require('../observable/ConnectableObservable');\n/* tslint:disable:max-line-length */\n/**\n * Returns an Observable that emits the results of invoking a specified selector on items\n * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n *\n * <img src=\"./img/multicast.png\" width=\"100%\">\n *\n * @param {Function|Subject} Factory function to create an intermediate subject through\n * which the source sequence's elements will be multicast to the selector function\n * or Subject to push source elements into.\n * @param {Function} Optional selector function that can use the multicasted source stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the given source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable} an Observable that emits the results of invoking the selector\n * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n * the underlying stream.\n * @method multicast\n * @owner Observable\n */\nfunction multicast(subjectOrSubjectFactory, selector) {\n    var subjectFactory;\n    if (typeof subjectOrSubjectFactory === 'function') {\n        subjectFactory = subjectOrSubjectFactory;\n    }\n    else {\n        subjectFactory = function subjectFactory() {\n            return subjectOrSubjectFactory;\n        };\n    }\n    if (typeof selector === 'function') {\n        return this.lift(new MulticastOperator(subjectFactory, selector));\n    }\n    var connectable = Object.create(this, ConnectableObservable_1.connectableObservableDescriptor);\n    connectable.source = this;\n    connectable.subjectFactory = subjectFactory;\n    return connectable;\n}\nexports.multicast = multicast;\nvar MulticastOperator = (function () {\n    function MulticastOperator(subjectFactory, selector) {\n        this.subjectFactory = subjectFactory;\n        this.selector = selector;\n    }\n    MulticastOperator.prototype.call = function (subscriber, source) {\n        var selector = this.selector;\n        var subject = this.subjectFactory();\n        var subscription = selector(subject).subscribe(subscriber);\n        subscription.add(source.subscribe(subject));\n        return subscription;\n    };\n    return MulticastOperator;\n}());\nexports.MulticastOperator = MulticastOperator;\n//# sourceMappingURL=multicast.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/multicast.js\n// module id = 132\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Notification_1 = require('../Notification');\n/**\n * @see {@link Notification}\n *\n * @param scheduler\n * @param delay\n * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n * @method observeOn\n * @owner Observable\n */\nfunction observeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return this.lift(new ObserveOnOperator(scheduler, delay));\n}\nexports.observeOn = observeOn;\nvar ObserveOnOperator = (function () {\n    function ObserveOnOperator(scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n    };\n    return ObserveOnOperator;\n}());\nexports.ObserveOnOperator = ObserveOnOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ObserveOnSubscriber = (function (_super) {\n    __extends(ObserveOnSubscriber, _super);\n    function ObserveOnSubscriber(destination, scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnSubscriber.dispatch = function (arg) {\n        var notification = arg.notification, destination = arg.destination;\n        notification.observe(destination);\n    };\n    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n    };\n    ObserveOnSubscriber.prototype._next = function (value) {\n        this.scheduleMessage(Notification_1.Notification.createNext(value));\n    };\n    ObserveOnSubscriber.prototype._error = function (err) {\n        this.scheduleMessage(Notification_1.Notification.createError(err));\n    };\n    ObserveOnSubscriber.prototype._complete = function () {\n        this.scheduleMessage(Notification_1.Notification.createComplete());\n    };\n    return ObserveOnSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ObserveOnSubscriber = ObserveOnSubscriber;\nvar ObserveOnMessage = (function () {\n    function ObserveOnMessage(notification, destination) {\n        this.notification = notification;\n        this.destination = destination;\n    }\n    return ObserveOnMessage;\n}());\nexports.ObserveOnMessage = ObserveOnMessage;\n//# sourceMappingURL=observeOn.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/observeOn.js\n// module id = 133\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:disable:max-line-length */\n/**\n * Applies an accumulator function over the source Observable, and returns the\n * accumulated result when the source completes, given an optional seed value.\n *\n * <span class=\"informal\">Combines together all values emitted on the source,\n * using an accumulator function that knows how to join a new source value into\n * the accumulation from the past.</span>\n *\n * <img src=\"./img/reduce.png\" width=\"100%\">\n *\n * Like\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n * `reduce` applies an `accumulator` function against an accumulation and each\n * value of the source Observable (from the past) to reduce it to a single\n * value, emitted on the output Observable. Note that `reduce` will only emit\n * one value, only when the source Observable completes. It is equivalent to\n * applying operator {@link scan} followed by operator {@link last}.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n *   .takeUntil(Rx.Observable.interval(5000));\n * var ones = clicksInFiveSeconds.mapTo(1);\n * var seed = 0;\n * var count = ones.reduce((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link count}\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link scan}\n *\n * @param {function(acc: R, value: T): R} accumulator The accumulator function\n * called on each source value.\n * @param {R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @return {Observable<R>} An Observable that emits a single value that is the\n * result of accumulating the values emitted by the source Observable.\n * @method reduce\n * @owner Observable\n */\nfunction reduce(accumulator, seed) {\n    var hasSeed = false;\n    // providing a seed of `undefined` *should* be valid and trigger\n    // hasSeed! so don't use `seed !== undefined` checks!\n    // For this reason, we have to check it here at the original call site\n    // otherwise inside Operator/Subscriber we won't know if `undefined`\n    // means they didn't provide anything or if they literally provided `undefined`\n    if (arguments.length >= 2) {\n        hasSeed = true;\n    }\n    return this.lift(new ReduceOperator(accumulator, seed, hasSeed));\n}\nexports.reduce = reduce;\nvar ReduceOperator = (function () {\n    function ReduceOperator(accumulator, seed, hasSeed) {\n        if (hasSeed === void 0) { hasSeed = false; }\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.hasSeed = hasSeed;\n    }\n    ReduceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ReduceSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n    };\n    return ReduceOperator;\n}());\nexports.ReduceOperator = ReduceOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ReduceSubscriber = (function (_super) {\n    __extends(ReduceSubscriber, _super);\n    function ReduceSubscriber(destination, accumulator, seed, hasSeed) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this.hasSeed = hasSeed;\n        this.hasValue = false;\n        this.acc = seed;\n    }\n    ReduceSubscriber.prototype._next = function (value) {\n        if (this.hasValue || (this.hasValue = this.hasSeed)) {\n            this._tryReduce(value);\n        }\n        else {\n            this.acc = value;\n            this.hasValue = true;\n        }\n    };\n    ReduceSubscriber.prototype._tryReduce = function (value) {\n        var result;\n        try {\n            result = this.accumulator(this.acc, value);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.acc = result;\n    };\n    ReduceSubscriber.prototype._complete = function () {\n        if (this.hasValue || this.hasSeed) {\n            this.destination.next(this.acc);\n        }\n        this.destination.complete();\n    };\n    return ReduceSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ReduceSubscriber = ReduceSubscriber;\n//# sourceMappingURL=reduce.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/reduce.js\n// module id = 134\n// module chunks = 2","\"use strict\";\nvar multicast_1 = require('./multicast');\nvar Subject_1 = require('../Subject');\nfunction shareSubjectFactory() {\n    return new Subject_1.Subject();\n}\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for .publish().refCount().\n *\n * <img src=\"./img/share.png\" width=\"100%\">\n *\n * @return {Observable<T>} an Observable that upon connection causes the source Observable to emit items to its Observers\n * @method share\n * @owner Observable\n */\nfunction share() {\n    return multicast_1.multicast.call(this, shareSubjectFactory).refCount();\n}\nexports.share = share;\n;\n//# sourceMappingURL=share.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/share.js\n// module id = 136\n// module chunks = 2","\"use strict\";\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar ScalarObservable_1 = require('../observable/ScalarObservable');\nvar EmptyObservable_1 = require('../observable/EmptyObservable');\nvar concat_1 = require('./concat');\nvar isScheduler_1 = require('../util/isScheduler');\n/* tslint:disable:max-line-length */\n/**\n * Returns an Observable that emits the items in a specified Iterable before it begins to emit items emitted by the\n * source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {Values} an Iterable that contains the items you want the modified Observable to emit first.\n * @return {Observable} an Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nfunction startWith() {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        array[_i - 0] = arguments[_i];\n    }\n    var scheduler = array[array.length - 1];\n    if (isScheduler_1.isScheduler(scheduler)) {\n        array.pop();\n    }\n    else {\n        scheduler = null;\n    }\n    var len = array.length;\n    if (len === 1) {\n        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);\n    }\n    else if (len > 1) {\n        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);\n    }\n    else {\n        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);\n    }\n}\nexports.startWith = startWith;\n//# sourceMappingURL=startWith.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/startWith.js\n// module id = 137\n// module chunks = 2"],"sourceRoot":""}